<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anthony-dong.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="​    Golang Gc相关！"><meta property="og:type" content="article"><meta property="og:title" content="Golang的GC的回收"><meta property="og:url" content="https://anthony-dong.github.io/2021/04/01/3a1ab3f1f398e2c69489c00767a5a560/index.html"><meta property="og:site_name" content="Anthony-Dong"><meta property="og:description" content="​    Golang Gc相关！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2021/3-31/21cfb0e870534fa081d892edd206b151.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/ea08431ef6b04f7bbf577f171432d723.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/5bd1742f9f7d450e9bcf583bf6c3bb70.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/568a1756f53c45e692bac0604c1eec2b.png"><meta property="article:published_time" content="2021-04-01T13:15:29.000Z"><meta property="article:modified_time" content="2023-04-06T10:03:18.152Z"><meta property="article:author" content="Anthony-Dong"><meta property="article:tag" content="Golang"><meta property="article:tag" content="GC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2021/3-31/21cfb0e870534fa081d892edd206b151.png"><link rel="canonical" href="https://anthony-dong.github.io/2021/04/01/3a1ab3f1f398e2c69489c00767a5a560/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>Golang的GC的回收 | Anthony-Dong</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?899b2a5c34078209c5f30853eaaa7846";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anthony-Dong</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Anthony-Dong技术博客</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Anthony-Dong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anthony-dong.github.io/2021/04/01/3a1ab3f1f398e2c69489c00767a5a560/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Anthony-Dong"><meta itemprop="description" content="追寻技术的本质！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anthony-Dong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Golang的GC的回收</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2021-04-01 21:15:29" itemprop="dateCreated datePublished" datetime="2021-04-01T21:15:29+08:00">2021-04-01</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-04-06 18:03:18" itemprop="dateModified" datetime="2023-04-06T18:03:18+08:00">2023-04-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Golang/" itemprop="url" rel="index"><span itemprop="name">Golang</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>32k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>29 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>​ Golang Gc相关！</p><span id="more"></span><h2 id="程序启动"><a href="#程序启动" class="headerlink" title="程序启动"></a>程序启动</h2><blockquote><p>​ Go程序启动，首先绝对是初始化一堆资源，关于如何启动需要看Go的转汇编代码了 ！</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The bootstrap sequence is:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	call osinit</span></span><br><span class="line"><span class="comment">//	call schedinit</span></span><br><span class="line"><span class="comment">//	make &amp; queue new G</span></span><br><span class="line"><span class="comment">//	call runtime·mstart</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The new G calls runtime·main.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// raceinit must be the first call to race detector.</span></span><br><span class="line">	<span class="comment">// In particular, it must be done before mallocinit below calls racemapshadow.</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">	gcinit()</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先在一个Go程序启动的时候会调用 <a target="_blank" rel="noopener" href="https://golang.org/src/runtime/proc.go">https://golang.org/src/runtime/proc.go</a> ，大致启动逻辑就和这个注释上一样，会先启动os，然后schedle，然后再启动</p><h2 id="gc初始化"><a href="#gc初始化" class="headerlink" title="gc初始化"></a>gc初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> unsafe.Sizeof(workbuf&#123;&#125;) != _WorkbufSize &#123;</span><br><span class="line">		throw(<span class="string">&quot;size of Workbuf is suboptimal&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// No sweep on the first cycle.</span></span><br><span class="line">	mheap_.sweepdone = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set a reasonable initial GC trigger. 核心关注与这个！就是触发GC回收的阈值，默认是0.875</span></span><br><span class="line">	memstats.triggerRatio = <span class="number">7</span> / <span class="number">8.0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Fake a heap_marked value so it looks like a trigger at</span></span><br><span class="line">	<span class="comment">// heapminimum is the appropriate growth from heap_marked.</span></span><br><span class="line">	<span class="comment">// This will go into computing the initial GC goal.</span></span><br><span class="line">	memstats.heap_marked = <span class="keyword">uint64</span>(<span class="keyword">float64</span>(heapminimum) / (<span class="number">1</span> + memstats.triggerRatio))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Set gcpercent from the environment. This will also compute</span></span><br><span class="line">	<span class="comment">// and set the GC trigger and goal.</span></span><br><span class="line">	_ = setGCPercent(readgogc())</span><br><span class="line"></span><br><span class="line">	work.startSema = <span class="number">1</span></span><br><span class="line">	work.markDoneSema = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、triggerRatio"><a href="#1、triggerRatio" class="headerlink" title="1、triggerRatio"></a>1、triggerRatio</h3><p>Set a reasonable initial GC trigger. 核心关注与这个！就是触发GC回收的阈值，默认是0.875，含义是这次堆中存活的对象是上一次的 <code>1+(7/0.8)</code>值要大的时候就回收</p><p>假如上次完成后堆内存是 <code>100M</code> 现在是 <code>200M</code>，此时 <code>(200M-100M)/100M&gt;7/0.8</code>的，所以需要进行回收！</p><p>具体这个值可以根据<code>GOGC/100</code> 进行设置，根据具体业务来，<code>GOGC = off</code>将完全禁用垃圾收集</p><h3 id="2、heapminimum"><a href="#2、heapminimum" class="headerlink" title="2、heapminimum"></a>2、heapminimum</h3><p>heapminimum是触发GC的最小堆大小。</p><p>在初始化期间，此设置为4MB * GOGC / 100</p><h2 id="GC执行分类"><a href="#GC执行分类" class="headerlink" title="GC执行分类"></a>GC执行分类</h2><p>gogc 执行会分配下面大致几类</p><ul><li><code>gcTriggerHeap</code></li><li><code>gcTriggerTime</code></li><li><code>gcTriggerCycle</code></li></ul><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2021/3-31/21cfb0e870534fa081d892edd206b151.png" alt="garbage-collector-trigger"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span> <span class="title">test</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">	<span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">		<span class="comment">// Non-atomic access to heap_live for performance. If</span></span><br><span class="line">		<span class="comment">// we are going to trigger on this, this thread just</span></span><br><span class="line">		<span class="comment">// atomically wrote heap_live anyway and we&#x27;ll see our</span></span><br><span class="line">		<span class="comment">// own write.</span></span><br><span class="line">    <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger <span class="comment">// heap中存活的对象大于gc需要触发的阈值(这个阈值时上一次gc设置的)</span></span><br><span class="line">	<span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">		<span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		lastgc := <span class="keyword">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">		<span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod <span class="comment">// 当前时间与上次gc时间相差2分钟</span></span><br><span class="line">	<span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">		<span class="comment">// t.n &gt; work.cycles, but accounting for wraparound.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、周期性GC"><a href="#1、周期性GC" class="headerlink" title="1、周期性GC"></a>1、周期性GC</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">	forcegc.g = getg()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		lock(&amp;forcegc.lock)</span><br><span class="line">		<span class="keyword">if</span> forcegc.idle != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;forcegc: phase error&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		atomic.Store(&amp;forcegc.idle, <span class="number">1</span>)</span><br><span class="line">		goparkunlock(&amp;forcegc.lock, waitReasonForceGGIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">		<span class="comment">// this goroutine is explicitly resumed by sysmon</span></span><br><span class="line">		<span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="built_in">println</span>(<span class="string">&quot;GC forced&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Time-triggered, fully concurrent.</span></span><br><span class="line">		gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到当调用的时候自己给自己加了把锁，然后把自己挂起等待别人唤醒去执行gc，然后看一下 <code>sysmon函数</code>,这个值一般不会改变！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forcegcperiod is the maximum time in nanoseconds between garbage</span></span><br><span class="line"><span class="comment">// collections. If we go this long without a garbage collection, one</span></span><br><span class="line"><span class="comment">// is forced to run.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This is a variable for testing purposes. It normally doesn&#x27;t change.</span></span><br><span class="line"><span class="keyword">var</span> forcegcperiod <span class="keyword">int64</span> = <span class="number">2</span> * <span class="number">60</span> * <span class="number">1e9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Always runs without a P, so write barriers are not allowed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//go:nowritebarrierrec</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 。。。。。。。。</span></span><br><span class="line">		<span class="comment">// check if we need to force a GC</span></span><br><span class="line">  <span class="comment">// 要求第一符合gc周期，第二 forcegc.idle 不为0</span></span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">			lock(&amp;forcegc.lock)</span><br><span class="line">			forcegc.idle = <span class="number">0</span></span><br><span class="line">			<span class="keyword">var</span> list gList</span><br><span class="line">			list.push(forcegc.g)</span><br><span class="line">			injectglist(&amp;list)</span><br><span class="line">			unlock(&amp;forcegc.lock)</span><br><span class="line">		&#125;</span><br><span class="line">  <span class="comment">////。。。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、malloc-gc"><a href="#2、malloc-gc" class="headerlink" title="2、malloc gc"></a>2、malloc gc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Allocate an object of size bytes.</span></span><br><span class="line"><span class="comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span></span><br><span class="line"><span class="comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">	<span class="comment">// ........</span></span><br><span class="line">  <span class="comment">// 是否需要gc</span></span><br><span class="line">	shouldhelpgc := <span class="literal">false</span></span><br><span class="line">	<span class="keyword">if</span> size &lt;= maxSmallSize &#123; <span class="comment">// 小于32k</span></span><br><span class="line">		<span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123; <span class="comment">//小于16字节</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">var</span> s *mspan</span><br><span class="line">		shouldhelpgc = <span class="literal">true</span></span><br><span class="line">		systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			s = largeAlloc(size, needzero, noscan)</span><br><span class="line">		&#125;)</span><br><span class="line">		s.freeindex = <span class="number">1</span></span><br><span class="line">		s.allocCount = <span class="number">1</span></span><br><span class="line">		x = unsafe.Pointer(s.base())</span><br><span class="line">		size = s.elemsize</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 。。。。。。。</span></span><br><span class="line">	<span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line">		<span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">			gcStart(t)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到需要判断是否需要执行gc，大致如果分配大于32k的对象时都会去check一下gc</p><h3 id="3、强制GC"><a href="#3、强制GC" class="headerlink" title="3、强制GC"></a>3、强制GC</h3><p>这个行为一般不推荐用户自己去执行，首先他会强制的阻塞程序！所以不推荐，第二个就是go的GC并不会回收实际分配的物理内存，所以依旧是依赖于系统去强制回收！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GC runs a garbage collection and blocks the caller until the</span></span><br><span class="line"><span class="comment">// garbage collection is complete. It may also block the entire</span></span><br><span class="line"><span class="comment">// program.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// We consider a cycle to be: sweep termination, mark, mark</span></span><br><span class="line">	<span class="comment">// termination, and sweep. This function shouldn&#x27;t return</span></span><br><span class="line">	<span class="comment">// until a full cycle has been completed, from beginning to</span></span><br><span class="line">	<span class="comment">// end. Hence, we always want to finish up the current cycle</span></span><br><span class="line">	<span class="comment">// and start a new one. That means:</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 1. In sweep termination, mark, or mark termination of cycle</span></span><br><span class="line">	<span class="comment">// N, wait until mark termination N completes and transitions</span></span><br><span class="line">	<span class="comment">// to sweep N.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 2. In sweep N, help with sweep N.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// At this point we can begin a full cycle N+1.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 3. Trigger cycle N+1 by starting sweep termination N+1.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 4. Wait for mark termination N+1 to complete.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 5. Help with sweep N+1 until it&#x27;s done.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// This all has to be written to deal with the fact that the</span></span><br><span class="line">	<span class="comment">// GC may move ahead on its own. For example, when we block</span></span><br><span class="line">	<span class="comment">// until mark termination N, we may wake up in cycle N+2.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait until the current sweep termination, mark, and mark</span></span><br><span class="line">	<span class="comment">// termination complete.</span></span><br><span class="line">	n := atomic.Load(&amp;work.cycles)</span><br><span class="line">	gcWaitOnMark(n)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We&#x27;re now in sweep N or later. Trigger GC cycle N+1, which</span></span><br><span class="line">	<span class="comment">// will first finish sweep N if necessary and then enter sweep</span></span><br><span class="line">	<span class="comment">// termination N+1.</span></span><br><span class="line">	gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait for mark termination N+1 to complete.</span></span><br><span class="line">	gcWaitOnMark(n + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GC测试"><a href="#GC测试" class="headerlink" title="GC测试"></a>GC测试</h2><h3 id="1、内存扩容GC测试"><a href="#1、内存扩容GC测试" class="headerlink" title="1、内存扩容GC测试"></a>1、内存扩容GC测试</h3><p>这里来测试一下 malloc 的方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	appender = <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// GODEBUG=gctrace=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ticker := time.NewTicker(time.Second * <span class="number">1</span>)</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	alloc := <span class="number">4</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		&lt;-ticker.C</span><br><span class="line">		appender = <span class="built_in">append</span>(appender, <span class="built_in">make</span>([]<span class="keyword">byte</span>, alloc))</span><br><span class="line">		count++</span><br><span class="line">		fmt.Printf(<span class="string">&quot;第%d次分配空间: %dm\n&quot;</span>, count, alloc&gt;&gt;<span class="number">20</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、执行，配置 <code>GOGC=100 GODEBUG=gctrace=1</code>， 更多关于<code>GODEBUG</code>的配置是 <a target="_blank" rel="noopener" href="https://golang.org/src/runtime/extern.go">https://golang.org/src/runtime/extern.go</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">➜  gc git:(master) ✗ GOGC=100 GODEBUG=gctrace=1 bin/app</span><br><span class="line">第1次分配空间: 4m</span><br><span class="line">gc 1 @1.001s 0%: 0.010+0.19+0.023 ms clock, 0.12+0.11/0.060/0.11+0.28 ms cpu, 4-&gt;4-&gt;4 MB, 5 MB goal, 12 P</span><br><span class="line">第2次分配空间: 4m</span><br><span class="line">gc 2 @2.003s 0%: 0.003+0.082+0.024 ms clock, 0.040+0.060/0.019/0.059+0.29 ms cpu, 8-&gt;8-&gt;8 MB, 9 MB goal, 12 P</span><br><span class="line">第3次分配空间: 4m</span><br><span class="line">第4次分配空间: 4m</span><br><span class="line">gc 3 @4.005s 0%: 0.021+0.20+0.009 ms clock, 0.25+0.10/0.099/0.12+0.11 ms cpu, 16-&gt;16-&gt;16 MB, 17 MB goal, 12 P</span><br><span class="line">第5次分配空间: 4m</span><br><span class="line">第6次分配空间: 4m</span><br><span class="line">第7次分配空间: 4m</span><br><span class="line">第8次分配空间: 4m</span><br><span class="line">gc 4 @8.005s 0%: 0.005+0.19+0.008 ms clock, 0.061+0.10/0.074/0.086+0.10 ms cpu, 32-&gt;32-&gt;32 MB, 33 MB goal, 12 P</span><br><span class="line">第9次分配空间: 4m</span><br><span class="line">第10次分配空间: 4m</span><br><span class="line">第11次分配空间: 4m</span><br><span class="line">第12次分配空间: 4m</span><br><span class="line">第13次分配空间: 4m</span><br><span class="line">第14次分配空间: 4m</span><br><span class="line">第15次分配空间: 4m</span><br><span class="line">第16次分配空间: 4m</span><br><span class="line">gc 5 @16.005s 0%: 0.015+0.21+0.011 ms clock, 0.18+0.14/0.062/0.15+0.13 ms cpu, 64-&gt;64-&gt;64 MB, 65 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>2、这里可以看到第一次分配就进行了GC，完全符合默认的设置，当内存第二次分配的时候，由于8/4&gt;1进行了gc，那么下一次触发的阈值就会是 16，假如我们将 <code>GOGC=50</code>，继续执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  gc git:(master) ✗ GOGC=50 GODEBUG=gctrace=1 bin/app</span><br><span class="line">gc 第1次分配空间: 4m</span><br><span class="line">1 @1.000s 0%: 0.011+0.18+0.016 ms clock, 0.13+0.10/0.024/0.16+0.19 ms cpu, 4-&gt;4-&gt;4 MB, 5 MB goal, 12 P</span><br><span class="line">第2次分配空间: 4m</span><br><span class="line">gc 2 @2.002s 0%: 0.006+0.27+0.010 ms clock, 0.078+0.12/0.12/0.12+0.12 ms cpu, 8-&gt;8-&gt;8 MB, 9 MB goal, 12 P</span><br><span class="line">第3次分配空间: 4m</span><br><span class="line">gc 3 @3.001s 0%: 0.006+0.21+0.010 ms clock, 0.083+0.10/0.12/0.11+0.12 ms cpu, 12-&gt;12-&gt;12 MB, 13 MB goal, 12 P</span><br><span class="line">第4次分配空间: 4m</span><br><span class="line">第5次分配空间: 4m</span><br><span class="line">gc 4 @5.005s 0%: 0.006+0.24+0.012 ms clock, 0.080+0.10/0.055/0.22+0.14 ms cpu, 20-&gt;20-&gt;20 MB, 21 MB goal, 12 P</span><br></pre></td></tr></table></figure><p>可以看到第3次gc的内存是12m，原因是上次gc后堆内存为8m,那么下一次就是 8m*1.5=12m，所以完全符合！</p><p>3、假如关闭垃圾回收</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">➜  gc git:(master) ✗ GOGC=off GODEBUG=gctrace=1 bin/app</span><br><span class="line">第1次分配空间: 4m</span><br><span class="line">第2次分配空间: 4m</span><br><span class="line">第3次分配空间: 4m</span><br><span class="line">第4次分配空间: 4m</span><br><span class="line">第5次分配空间: 4m</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关于gc日志学习"><a href="#关于gc日志学习" class="headerlink" title="关于gc日志学习"></a>关于gc日志学习</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard</span><br><span class="line">error at each collection, summarizing the amount of memory collected and the</span><br><span class="line">length of the pause. The format of this line is subject to change.</span><br><span class="line">Currently, it is:</span><br><span class="line">  gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P</span><br><span class="line">where the fields are as follows:</span><br><span class="line">  gc #        the GC number, incremented at each GC</span><br><span class="line"><span class="meta">  @#</span><span class="bash">s         time <span class="keyword">in</span> seconds since program start，距离程序的启动时间，单位s</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">%          percentage of time spent <span class="keyword">in</span> GC since program start，花费时间的百分比</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">+...+<span class="comment">#     wall-clock/CPU times for the phases of the GC， cpu花费的时间</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash">-&gt;<span class="comment">#-&gt;# MB  heap size at GC start, at GC end, and live heap，gc开始-gc结束-存活的对象 （堆内存）</span></span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> MB goal   goal heap size （全局堆内存大小）</span></span><br><span class="line"><span class="meta">  #</span><span class="bash"> P         number of processors used p的数量</span></span><br></pre></td></tr></table></figure><h3 id="2、强制gc"><a href="#2、强制gc" class="headerlink" title="2、强制gc"></a>2、强制gc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOGC=100 GODEBUG=gctrace=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">3</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">	runtime.GC()</span><br><span class="line">	time.Sleep(time.Second * <span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  gc git:(master) ✗ GOGC=100 GODEBUG=gctrace=1 bin/app</span><br><span class="line">gc 1 @0.000s 2%: 0.003+0.11+0.006 ms clock, 0.037+0/0.089/0.10+0.080 ms cpu, 3-&gt;3-&gt;0 MB, 4 MB goal, 12 P (forced)</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>可以看到结果是堆中最后存活的对象是 <code>0M</code>，可以发现我们申明的那个3m对象被回收，也没有触发系统mem回收！</p><h3 id="3、周期清理"><a href="#3、周期清理" class="headerlink" title="3、周期清理"></a>3、周期清理</h3><p>这个其实不好测试，因为那个周期值无法做配置！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOGC=100 GODEBUG=gctrace=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">3</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">	time.Sleep(time.Second * <span class="number">130</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待120s的到来！……….. 结果没有</p><h2 id="获取Runtime信息"><a href="#获取Runtime信息" class="headerlink" title="获取Runtime信息"></a>获取Runtime信息</h2><blockquote><p>​ 使用prometheus 获取 proc信息，必须是linux/windows，所以mac不能使用</p></blockquote><h3 id="1、mem信息"><a href="#1、mem信息" class="headerlink" title="1、mem信息"></a>1、mem信息</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;github.com/prometheus/procfs&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// GOGC=100 GODEBUG=gctrace=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	memInfo()</span><br><span class="line">	_ = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">3</span>&lt;&lt;<span class="number">20</span>)</span><br><span class="line">	memInfo()</span><br><span class="line">	runtime.GC()</span><br><span class="line">	memInfo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memInfo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	stats := runtime.MemStats&#123;&#125;</span><br><span class="line">	runtime.ReadMemStats(&amp;stats)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, stats)</span><br><span class="line">	procMem()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">procMem</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p, err := procfs.NewProc(os.Getpid())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	procStat, err := p.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	procStat.ResidentMemory() <span class="comment">// 进程所占用的RES</span></span><br><span class="line">	procStat.VirtualMemory()  <span class="comment">// 进程所占用的VIRT</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;res: %dM, virt: %dM\n&quot;</span>, procStat.ResidentMemory()&gt;&gt;<span class="number">20</span>, procStat.VirtualMemory()&gt;&gt;<span class="number">20</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面函数以下结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">➜  gc git:(master) ✗ GOGC=<span class="number">100</span> GODEBUG=gctrace=<span class="number">1</span>  bin/app</span><br><span class="line">&#123;Alloc:<span class="number">158760</span> TotalAlloc:<span class="number">158760</span> Sys:<span class="number">69928960</span> Lookups:<span class="number">0</span> Mallocs:<span class="number">173</span> Frees:<span class="number">3</span> HeapAlloc:<span class="number">158760</span> HeapSys:<span class="number">66879488</span> HeapIdle:<span class="number">66535424</span> HeapInuse:<span class="number">344064</span> HeapReleased:<span class="number">66469888</span> HeapObjects:<span class="number">170</span> StackInuse:<span class="number">229376</span> StackSys:<span class="number">229376</span> MSpanInuse:<span class="number">5168</span> MSpanSys:<span class="number">16384</span> MCacheInuse:<span class="number">20832</span> MCacheSys:<span class="number">32768</span> BuckHashSys:<span class="number">2203</span> GCSys:<span class="number">2240512</span> OtherSys:<span class="number">528229</span> NextGC:<span class="number">4473924</span> LastGC:<span class="number">0</span> PauseTotalNs:<span class="number">0</span> PauseNs:[<span class="number">0</span> <span class="number">0.</span>..] PauseEnd:[<span class="number">0</span> <span class="number">0</span> .....] NumGC:<span class="number">0</span> NumForcedGC:<span class="number">0</span> GCCPUFraction:<span class="number">0</span> EnableGC:<span class="literal">true</span> DebugGC:<span class="literal">false</span> BySize:[&#123;Size:<span class="number">0</span> Mallocs:<span class="number">0</span> Frees:<span class="number">0</span>&#125; &#123;Size:<span class="number">8</span> Mallocs:<span class="number">5</span> Frees:<span class="number">0</span>&#125; &#123;Size:<span class="number">16</span> Mallocs:<span class="number">42</span> Frees:<span class="number">0</span>&#125; ......]&#125;</span><br><span class="line"></span><br><span class="line">res: <span class="number">3</span>M, virt: <span class="number">211</span>M</span><br><span class="line"></span><br><span class="line">&#123;Alloc:<span class="number">3328688</span> TotalAlloc:<span class="number">3328688</span> Sys:<span class="number">69928960</span> Lookups:<span class="number">0</span> Mallocs:<span class="number">406</span> Frees:<span class="number">111</span> HeapAlloc:<span class="number">3328688</span> HeapSys:<span class="number">66879488</span> HeapIdle:<span class="number">63250432</span> HeapInuse:<span class="number">3629056</span> HeapReleased:<span class="number">63250432</span> HeapObjects:<span class="number">295</span> StackInuse:<span class="number">229376</span> StackSys:<span class="number">229376</span> MSpanInuse:<span class="number">6528</span> MSpanSys:<span class="number">16384</span> MCacheInuse:<span class="number">20832</span> MCacheSys:<span class="number">32768</span> BuckHashSys:<span class="number">2203</span> GCSys:<span class="number">2240512</span> OtherSys:<span class="number">528229</span> NextGC:<span class="number">4473924</span> LastGC:<span class="number">0</span> PauseTotalNs:<span class="number">0</span> PauseNs:[<span class="number">0</span> <span class="number">0</span> ......] PauseEnd:[<span class="number">0</span> <span class="number">0</span> .......] NumGC:<span class="number">0</span> NumForcedGC:<span class="number">0</span> GCCPUFraction:<span class="number">0</span> EnableGC:<span class="literal">true</span> DebugGC:<span class="literal">false</span> BySize:[&#123;Size:<span class="number">0</span> Mallocs:<span class="number">0</span> Frees:<span class="number">0</span>&#125; &#123;Size:<span class="number">8</span> Mallocs:<span class="number">6</span> Frees:<span class="number">0</span>&#125; &#123;Size:<span class="number">16</span> Mallocs:<span class="number">151</span> Frees:<span class="number">0</span>&#125; .....]&#125;</span><br><span class="line"></span><br><span class="line">res: <span class="number">3</span>M, virt: <span class="number">211</span>M</span><br><span class="line"></span><br><span class="line">gc <span class="number">1</span> @<span class="number">0.002</span>s <span class="number">0</span>%: <span class="number">0.006</span>+<span class="number">0.17</span>+<span class="number">0.004</span> ms clock, <span class="number">0.075</span>+<span class="number">0</span>/<span class="number">0.098</span>/<span class="number">0.20</span>+<span class="number">0.052</span> ms cpu, <span class="number">3</span>-&gt;<span class="number">3</span>-&gt;<span class="number">0</span> MB, <span class="number">4</span> MB goal, <span class="number">12</span> P (forced)</span><br><span class="line"></span><br><span class="line">&#123;Alloc:<span class="number">158248</span> TotalAlloc:<span class="number">3345520</span> Sys:<span class="number">70256640</span> Lookups:<span class="number">0</span> Mallocs:<span class="number">656</span> Frees:<span class="number">484</span> HeapAlloc:<span class="number">158248</span> HeapSys:<span class="number">66781184</span> HeapIdle:<span class="number">66</span>,<span class="number">396</span>,<span class="number">160</span> HeapInuse:<span class="number">385</span>,<span class="number">024</span> HeapReleased:<span class="number">62</span>,<span class="number">996</span>,<span class="number">480</span> HeapObjects:<span class="number">172</span> StackInuse:<span class="number">327680</span> StackSys:<span class="number">327680</span> MSpanInuse:<span class="number">7072</span> MSpanSys:<span class="number">16384</span> MCacheInuse:<span class="number">20832</span> MCacheSys:<span class="number">32768</span> BuckHashSys:<span class="number">2203</span> GCSys:<span class="number">2312192</span> OtherSys:<span class="number">784229</span> NextGC:<span class="number">4194304</span> LastGC:<span class="number">1617196841921944000</span> PauseTotalNs:<span class="number">10675</span> PauseNs:[<span class="number">10675</span> <span class="number">0</span> <span class="number">0</span> ......] PauseEnd:[<span class="number">1617196841921944000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.</span>.....] NumGC:<span class="number">1</span> NumForcedGC:<span class="number">1</span> GCCPUFraction:<span class="number">0.007580984200182396</span> EnableGC:<span class="literal">true</span> DebugGC:<span class="literal">false</span> BySize:[&#123;Size:<span class="number">0</span> Mallocs:<span class="number">0</span> Frees:<span class="number">0</span>&#125; &#123;Size:<span class="number">8</span> Mallocs:<span class="number">6</span> Frees:<span class="number">1</span>&#125; ........]&#125;</span><br><span class="line"></span><br><span class="line">res: <span class="number">3</span>M, virt: <span class="number">283</span>M</span><br></pre></td></tr></table></figure><p>可以看到gc前内存是3m，gc后内存是0m</p><ul><li><code>Alloc</code> 158,760-&gt;3,328,688-&gt;158,248 （和 <code>HeapAlloc</code> 一样）</li><li><code>TotalAlloc</code> 158,760-&gt; 3,328,688-&gt; 3,345,520（一共分配的内存）</li><li><code>Sys</code> 69,928,960-&gt;69,928,960-&gt;70,256,640（系统分配的内存，它表示占用操作系统的全部内存！）</li><li><code>HeapAlloc</code> 158,760-&gt;3,328,688-&gt;158,248 （堆分配的内存）</li><li><code>HeapSys</code> 66,879,488-&gt;66,879,488-&gt;66,781,184</li><li><code>HeapIdle</code> 66,535,424-&gt;63,250,432-&gt;66,396,160（未被使用的span字节树，其实就是未被分配的堆内存，当内存被回收时这个数量会增加回收的内存）</li><li><code>HeapInuse</code> 344,064-&gt;3,629,056-&gt;385,024 (正在使用的字节数)</li><li><code>HeapReleased</code> 66,469,888-&gt;63,250,432-&gt;62,996,480 （返还给操作系统的内存，它统计了从idle span中返还给操作系统，没有被重新获取的内存大小.）</li><li><code>PauseNs</code> 表示GC停顿时常， <code>PauseNs[NumGC%256]</code> 表示第多少次GC的时长，记录最近256次的GC！</li><li><code>NextGC</code> 4,473,924-&gt; 4,473,924 -&gt; 4,194,304, 表示下次GC触发的阈值</li><li><code>GCSys</code> 229,376-&gt;2,240,512-&gt;2,312,192</li></ul><p>其他指标讲解请看 <a target="_blank" rel="noopener" href="https://golang.org/src/runtime/mstats.go">https://golang.org/src/runtime/mstats.go</a></p><h3 id="2、监控进程的指标"><a href="#2、监控进程的指标" class="headerlink" title="2、监控进程的指标"></a>2、监控进程的指标</h3><p>这里需要使用 <code>github.com/prometheus/procfs</code> 包，很好的解决了跨平台问题！</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/prometheus/procfs&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p, err := procfs.NewProc(os.Getpid())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	procStat, err := p.Stat()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	procStat.ResidentMemory() <span class="comment">// 进程所占用的RES</span></span><br><span class="line">	procStat.VirtualMemory()  <span class="comment">// 进程所占用的VIRT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、使用prometheus-监控"><a href="#3、使用prometheus-监控" class="headerlink" title="3、使用prometheus 监控"></a>3、使用prometheus 监控</h3><p>下面是一个线上服务的metrics</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HELP go_gc_duration_seconds A summary of the pause duration of garbage collection cycles.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0&quot;&#125; 5.6827e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.25&quot;&#125; 8.1842e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.5&quot;&#125; 9.8818e-05</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;0.75&quot;&#125; 0.000125499</span><br><span class="line">go_gc_duration_seconds&#123;quantile=&quot;1&quot;&#125; 0.000555719</span><br><span class="line">go_gc_duration_seconds_sum 0.247680951</span><br><span class="line">go_gc_duration_seconds_count 2366</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_goroutines Number of goroutines that currently exist.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_goroutines gauge</span></span><br><span class="line">go_goroutines 50</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_info Information about the Go environment.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_info gauge</span></span><br><span class="line">go_info&#123;version=&quot;go1.13.5&quot;&#125; 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_memstats_alloc_bytes Number of bytes allocated and still <span class="keyword">in</span> use.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_memstats_alloc_bytes gauge</span></span><br><span class="line">go_memstats_alloc_bytes 8.338104e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_memstats_alloc_bytes_total Total number of bytes allocated, even <span class="keyword">if</span> freed.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_memstats_alloc_bytes_total counter</span></span><br><span class="line">go_memstats_alloc_bytes_total 1.3874634688e+10</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_memstats_buck_hash_sys_bytes Number of bytes used by the profiling bucket <span class="built_in">hash</span> table.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_memstats_buck_hash_sys_bytes gauge</span></span><br><span class="line">go_memstats_buck_hash_sys_bytes 1.922436e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_memstats_frees_total Total number of frees.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> TYPE go_memstats_frees_total counter</span></span><br><span class="line">go_memstats_frees_total 8.9915565e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"> HELP go_memstats_gc_cpu_fraction The fraction of this program<span class="string">&#x27;s available CPU time used by the GC since the program started.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_gc_cpu_fraction gauge</span></span></span><br><span class="line">go_memstats_gc_cpu_fraction 5.2633836319412915e-06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_gc_sys_bytes Number of bytes used for garbage collection system metadata.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_gc_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_gc_sys_bytes 2.398208e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_alloc_bytes Number of heap bytes allocated and still in use.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_alloc_bytes gauge</span></span></span><br><span class="line">go_memstats_heap_alloc_bytes 8.338104e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_idle_bytes Number of heap bytes waiting to be used.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_idle_bytes gauge</span></span></span><br><span class="line">go_memstats_heap_idle_bytes 5.1625984e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_inuse_bytes Number of heap bytes that are in use.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_inuse_bytes gauge</span></span></span><br><span class="line">go_memstats_heap_inuse_bytes 1.0829824e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_objects Number of allocated objects.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_objects gauge</span></span></span><br><span class="line">go_memstats_heap_objects 42405</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_released_bytes Number of heap bytes released to OS.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_released_bytes gauge</span></span></span><br><span class="line">go_memstats_heap_released_bytes 4.9709056e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_heap_sys_bytes Number of heap bytes obtained from system.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_heap_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_heap_sys_bytes 6.2455808e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_last_gc_time_seconds Number of seconds since 1970 of last garbage collection.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_last_gc_time_seconds gauge</span></span></span><br><span class="line">go_memstats_last_gc_time_seconds 1.6172457774344466e+09</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_lookups_total Total number of pointer lookups.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_lookups_total counter</span></span></span><br><span class="line">go_memstats_lookups_total 0</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_mallocs_total Total number of mallocs.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_mallocs_total counter</span></span></span><br><span class="line">go_memstats_mallocs_total 8.995797e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_mcache_inuse_bytes Number of bytes in use by mcache structures.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_mcache_inuse_bytes gauge</span></span></span><br><span class="line">go_memstats_mcache_inuse_bytes 83328</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_mcache_sys_bytes Number of bytes used for mcache structures obtained from system.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_mcache_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_mcache_sys_bytes 98304</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_mspan_inuse_bytes Number of bytes in use by mspan structures.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_mspan_inuse_bytes gauge</span></span></span><br><span class="line">go_memstats_mspan_inuse_bytes 142528</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_mspan_sys_bytes Number of bytes used for mspan structures obtained from system.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_mspan_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_mspan_sys_bytes 196608</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_next_gc_bytes Number of heap bytes when next garbage collection will take place.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_next_gc_bytes gauge</span></span></span><br><span class="line">go_memstats_next_gc_bytes 1.0362992e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_other_sys_bytes Number of bytes used for other system allocations.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_other_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_other_sys_bytes 5.542772e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_stack_inuse_bytes Number of bytes in use by the stack allocator.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_stack_inuse_bytes gauge</span></span></span><br><span class="line">go_memstats_stack_inuse_bytes 4.653056e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_stack_sys_bytes Number of bytes obtained from system for stack allocator.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_stack_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_stack_sys_bytes 4.653056e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_memstats_sys_bytes Number of bytes obtained from system.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_memstats_sys_bytes gauge</span></span></span><br><span class="line">go_memstats_sys_bytes 7.7267192e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP go_threads Number of OS threads created.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE go_threads gauge</span></span></span><br><span class="line">go_threads 48</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_cpu_seconds_total Total user and system CPU time spent in seconds.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_cpu_seconds_total counter</span></span></span><br><span class="line">process_cpu_seconds_total 3875.24</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_max_fds Maximum number of open file descriptors.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_max_fds gauge</span></span></span><br><span class="line">process_max_fds 1.048576e+06</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_open_fds Number of open file descriptors.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_open_fds gauge</span></span></span><br><span class="line">process_open_fds 29</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_resident_memory_bytes Resident memory size in bytes.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_resident_memory_bytes gauge</span></span></span><br><span class="line">process_resident_memory_bytes 7.5575296e+07</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_start_time_seconds Start time of the process since unix epoch in seconds.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_start_time_seconds gauge</span></span></span><br><span class="line">process_start_time_seconds 1.61709350436e+09</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_virtual_memory_bytes Virtual memory size in bytes.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_virtual_memory_bytes gauge</span></span></span><br><span class="line">process_virtual_memory_bytes 2.018103296e+09</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP process_virtual_memory_max_bytes Maximum amount of virtual memory available in bytes.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE process_virtual_memory_max_bytes gauge</span></span></span><br><span class="line">process_virtual_memory_max_bytes -1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP promhttp_metric_handler_requests_in_flight Current number of scrapes being served.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE promhttp_metric_handler_requests_in_flight gauge</span></span></span><br><span class="line">promhttp_metric_handler_requests_in_flight 1</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> HELP promhttp_metric_handler_requests_total Total number of scrapes by HTTP status code.</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> TYPE promhttp_metric_handler_requests_total counter</span></span></span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=&quot;200&quot;&#125; 25373</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=&quot;500&quot;&#125; 0</span><br><span class="line">promhttp_metric_handler_requests_total&#123;code=&quot;503&quot;&#125; 0</span><br></pre></td></tr></table></figure><p>核心关注的指标：</p><blockquote><p>​ 7.5575296e+07 含义是 7.5575296*10^7 ，所以转换为 <code>M</code>，快速计算只需要 / 10^6， 所以就 -6即可，也就是<code>7.5575296e+01</code> 所以就是 <code>75M</code></p></blockquote><ul><li><code>process_resident_memory_bytes</code> - <code>RES</code> 进程所占用的物理内存 （75M）</li><li><code>process_virtual_memory_bytes</code> - <code>VIRT</code> 进程所占用的虚拟内存 (Go的虚拟内存往往很大，2G)</li><li><code>go_memstats_heap_alloc_bytes</code> - <code>HeapAlloc</code> 堆内存大小(当前堆实际使用的大小 , 8M)</li><li><code>go_memstats_next_gc_bytes</code> - <code>NextGC</code> 表示下次触发GC的阈值 （10M）</li><li><code>go_memstats_heap_idle_bytes</code> - <code>HeapIdle</code> 表示堆中空闲的内存( 59M)</li><li><code>go_memstats_heap_inuse_bytes</code> - <code>HeapInuse</code>表示正在使用的堆内存 (10M，可能包含有碎片，这个就是实际占用的内存，可以参考的，因为空闲内存可能被回收/未被分配的也是可能实际没有分配)</li><li><code>process_open_fds</code> 打开的文件 （29）</li><li><code>go_goroutines</code> 表示 go的goroutine 个数 (50)</li><li><code>go_memstats_buck_hash_sys_bytes</code> 表示hash表中的数据 (8M)</li></ul><p>下面是我们公司对于Go服务的监控</p><p>这个容器里放的是一个站内信服务，服务部署在容器中4c_4g（宿主机是128G_64C），可以看到24小时内，服务的内存还是相对来说很稳定的，堆内存基本维持在10m-15m左右，gc基本在100us内！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/ea08431ef6b04f7bbf577f171432d723.png" alt="image-20210401145115111"></p><h3 id="4、使用-net-http-pprof"><a href="#4、使用-net-http-pprof" class="headerlink" title="4、使用 net/http/pprof"></a>4、使用 <code>net/http/pprof</code></h3><p>只需要引入 <code>_ &quot;net/http/pprof&quot;</code></p><p>然后加一行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 未占用的端口</span></span><br><span class="line">	http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h4 id="1、mem"><a href="#1、mem" class="headerlink" title="1、mem"></a>1、mem</h4><p>最后执行一下下面的，也就是当前的 <code>runtime.MemStats</code>， 不用说核心关注 <code>HeapAlloc</code> 和 <code>HeapInuse</code> 以及 <code>NextGC</code> , <code>PauseNs</code> , <code>NumGC</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http:<span class="comment">//localhost:8080/debug/pprof/allocs\?debug\=1 -v</span></span><br><span class="line"></span><br><span class="line"># runtime.MemStats</span><br><span class="line"># Alloc = <span class="number">457531928</span></span><br><span class="line"># TotalAlloc = <span class="number">672404416</span></span><br><span class="line"># Sys = <span class="number">556939512</span></span><br><span class="line"># Lookups = <span class="number">0</span></span><br><span class="line"># Mallocs = <span class="number">24449</span></span><br><span class="line"># Frees = <span class="number">23362</span></span><br><span class="line"># HeapAlloc = <span class="number">457531928</span></span><br><span class="line"># HeapSys = <span class="number">536248320</span></span><br><span class="line"># HeapIdle = <span class="number">77873152</span></span><br><span class="line"># HeapInuse = <span class="number">458375168</span></span><br><span class="line"># HeapReleased = <span class="number">44040192</span></span><br><span class="line"># HeapObjects = <span class="number">1087</span></span><br><span class="line"># Stack = <span class="number">622592</span> / <span class="number">622592</span></span><br><span class="line"># MSpan = <span class="number">29512</span> / <span class="number">32768</span></span><br><span class="line"># MCache = <span class="number">20832</span> / <span class="number">32768</span></span><br><span class="line"># BuckHashSys = <span class="number">1443701</span></span><br><span class="line"># GCSys = <span class="number">17530880</span></span><br><span class="line"># OtherSys = <span class="number">1028483</span></span><br><span class="line"># NextGC = <span class="number">915023280</span></span><br><span class="line"># LastGC = <span class="number">1617268469532778000</span></span><br><span class="line"># PauseNs = [<span class="number">35105</span> <span class="number">36373</span> <span class="number">34839</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"># PauseEnd = [<span class="number">1617268337687730000</span> <span class="number">1617268338545459000</span> <span class="number">1617268469532778000</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"># NumGC = <span class="number">3</span></span><br><span class="line"># NumForcedGC = <span class="number">0</span></span><br><span class="line"># GCCPUFraction = <span class="number">1.2248226722456959e-06</span></span><br><span class="line"># DebugGC = <span class="literal">false</span></span><br><span class="line">* Connection #<span class="number">0</span> to host localhost left intact</span><br><span class="line">* Closing connection <span class="number">0</span></span><br></pre></td></tr></table></figure><h4 id="2、goroutine-thread"><a href="#2、goroutine-thread" class="headerlink" title="2、goroutine / thread"></a>2、goroutine / thread</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http://localhost:8080/debug/pprof/goroutine\?debug\=1 -v</span><br><span class="line">goroutine profile: total 6</span><br><span class="line"></span><br><span class="line">➜  ~ curl http://localhost:8080/debug/pprof/threadcreate\?debug\=1 -v</span><br><span class="line">threadcreate profile: total 14</span><br></pre></td></tr></table></figure><h4 id="3、配合go-tool-pprof-命令"><a href="#3、配合go-tool-pprof-命令" class="headerlink" title="3、配合go tool pprof  命令"></a>3、配合<code>go tool pprof</code> 命令</h4><blockquote><p>​ 主要需要加参数 <code>seconds</code>，默认收集30s，下面例子是10s</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="keyword">go</span> tool  pprof -http <span class="string">&quot;:8888&quot;</span>  http:<span class="comment">//localhost:62316/debug/pprof/allocs\?seconds\=10</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:62316/debug/pprof/allocs?seconds=10</span></span><br><span class="line">Saved profile in /Users/fanhaodong/pprof/pprof.alloc_objects.alloc_space.inuse_objects.inuse_space<span class="number">.011</span>.pb.gz</span><br><span class="line">Serving web UI on http:<span class="comment">//localhost:8888</span></span><br></pre></td></tr></table></figure><p>可以看到采集10s最后效果</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/5bd1742f9f7d450e9bcf583bf6c3bb70.png" alt="image-20210401172808989"></p><h5 id="1、比如查找goroutine-使用率较高！"><a href="#1、比如查找goroutine-使用率较高！" class="headerlink" title="1、比如查找goroutine 使用率较高！"></a>1、比如查找<code>goroutine</code> 使用率较高！</h5><p>我们首先要查询 个数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl http:<span class="comment">//localhost:62316/debug/pprof/goroutine\?debug\=1</span></span><br><span class="line">goroutine profile: total <span class="number">100</span></span><br></pre></td></tr></table></figure><p>为啥这么多来</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ <span class="keyword">go</span> tool  pprof -http <span class="string">&quot;:8888&quot;</span>  http:<span class="comment">//localhost:62316/debug/pprof/goroutine\?seconds\=10</span></span><br><span class="line">Fetching profile over HTTP from http:<span class="comment">//localhost:62316/debug/pprof/goroutine?seconds=10</span></span><br><span class="line">Saved profile in /Users/fanhaodong/pprof/pprof.goroutine<span class="number">.001</span>.pb.gz</span><br><span class="line">Serving web UI on http:<span class="comment">//localhost:8888</span></span><br></pre></td></tr></table></figure><p>可以查看csv图，前提是你是在本地，首先如果在线上服务器，显然是不可能的！线上需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go tool pprof   http://localhost:62316/debug/pprof/goroutine\?seconds\=</span><br></pre></td></tr></table></figure><p>然后去查看</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2021/4-1/568a1756f53c45e692bac0604c1eec2b.png" alt="image-20210401211045488"></p><p>查看trace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ go tool pprof   http://localhost:62316/debug/pprof/goroutine\?seconds\=5</span><br><span class="line">Fetching profile over HTTP from http://localhost:62316/debug/pprof/goroutine?seconds=5</span><br><span class="line">(pprof) tree</span><br><span class="line">Showing nodes accounting for 102, 98.08% of 104 total</span><br><span class="line">Showing top 80 nodes out of 129</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">      flat  flat%   sum%        cum   cum%   calls calls% + context</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                                53 51.96% |   runtime.selectgo</span><br><span class="line">                                                26 25.49% |   runtime.goparkunlock</span><br><span class="line">                                                23 22.55% |   runtime.netpollblock</span><br><span class="line">       102 98.08% 98.08%        102 98.08%                | runtime.gopark</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">         0     0% 98.08%         54 51.92%                | github.com/apache/rocketmq-client-go/v2/primitive.WithRecover</span><br><span class="line">                                                 9 16.67% |   github.com/apache/rocketmq-client-go/v2/internal/remote.(*remotingClient).connect.func1</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*pushConsumer).pullMessage.func1</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func1</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func2</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func3</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func4</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func5</span><br><span class="line">                                                 5  9.26% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func6</span><br><span class="line">                                                 2  3.70% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.2</span><br><span class="line">                                                 2  3.70% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.3</span><br><span class="line">                                                 2  3.70% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.4</span><br><span class="line">                                                 2  3.70% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.5</span><br><span class="line">                                                 2  3.70% |   github.com/apache/rocketmq-client-go/v2/internal.(*traceDispatcher).Start.func1</span><br><span class="line">----------------------------------------------------------+-------------</span><br><span class="line">                                                 5  9.43% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func1</span><br><span class="line">                                                 5  9.43% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func2</span><br><span class="line">                                                 5  9.43% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func3</span><br><span class="line">                                                 5  9.43% |   github.com/apache/rocketmq-client-go/v2/consumer.(*statsItemSet).init.func4</span><br><span class="line">                                                 5  9.43% |   github.com/apache/rocketmq-client-go/v2/internal/remote.(*ResponseFuture).waitResponse</span><br><span class="line">                                                 5  9.43% |   net/http.(*persistConn).writeLoop</span><br><span class="line">                                                 2  3.77% |   database/sql.(*DB).connectionOpener</span><br><span class="line">                                                 2  3.77% |   database/sql.(*DB).connectionResetter</span><br><span class="line">                                                 2  3.77% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.2</span><br><span class="line">                                                 2  3.77% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.3</span><br><span class="line">                                                 2  3.77% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.4</span><br><span class="line">                                                 2  3.77% |   github.com/apache/rocketmq-client-go/v2/internal.(*rmqClient).Start.func1.5</span><br><span class="line">                                                 2  3.77% |   github.com/apache/rocketmq-client-go/v2/internal.(*traceDispatcher).process</span><br><span class="line">                                                 2  3.77% |   github.com/go-sql-driver/mysql.(*mysqlConn).startWatcher.func1</span><br><span class="line">                                                 1  1.89% |   github.com/SkyAPM/go2sky/reporter/grpc/management.(*managementServiceClient).KeepAlive</span><br><span class="line">                                                 1  1.89% |   github.com/apache/rocketmq-client-go/v2/consumer.(*pushConsumer).Start.func1.1</span><br><span class="line">                                                 1  1.89% |   github.com/nacos-group/nacos-sdk-go/common/http_agent.post</span><br><span class="line">         0     0% 98.08%         53 50.96%                | runtime.selectgo</span><br><span class="line">                                                53   100% |   runtime.gopark</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Go的内存模型和GC策略总结一下，堆属于Go最大的空间，堆大小基本用不完，对于GC来说(因为分配的是虚拟内存，同时会定期释放内存)，Go采用的是能复用即复用，也就是说如果我开辟了3M然后回收了3M下次就复用这空间，其次就是Go的堆内存并不会回收，也就是说如果我某一时刻堆空间开辟了很大的空间，其实对于程序来说，内存并不会回收！</p><p>Go的GC时间主要是根据堆的大小有关，我们线上来说，Go的堆大小基本很小，不到100M，所以GC时长也不会很大！</p><p>Go的GC优化就是能回收的在程序/请求运行结束就立马回收，如果开辟大量内存介意用<code>sync.Pool</code>！</p><p>其次减少GC频率可以在程序初始化的时候先开辟一个和程序稳定运行时大小的一个空间，那么对于Go来说，会减少GC回收的次数，但是GC回收的时间就会增加！</p><p>Go的GC回收时间主要是受机器的CPU限制，cpu越牛逼的机器回收越快！</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><h3 id="mem-信息字段"><a href="#mem-信息字段" class="headerlink" title="mem 信息字段"></a>mem 信息字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A MemStats records statistics about the memory allocator.</span></span><br><span class="line"><span class="keyword">type</span> MemStats <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 常规统计。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Alloc 是已分配的堆内存对象占用的内存量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这个值和 基本和HeapAlloc 一致（看下面）。</span></span><br><span class="line">	Alloc <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// TotalAlloc 是累积的堆内存对象分配的内存量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// TotalAlloc 会随着堆内存对象分配慢慢增长，但不像 Alloc 和 HeapAlloc，</span></span><br><span class="line">	<span class="comment">// 这个值不会随着对象被释放而缩小。</span></span><br><span class="line">	TotalAlloc <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Sys 是从 OS 获得的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Sys 是下面列出的 XSys 字段的综合。Sys 维护着为 Go 运行时预留的虚拟内存空间地址，</span></span><br><span class="line">	<span class="comment">// 里面包含了：堆、栈，以及其他内部数据结构。</span></span><br><span class="line">	Sys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Lookups 是 runtime 执行的指针查询的数量。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这主要在针对 runtime 内部进行 debugging 的时候比较有用。</span></span><br><span class="line">	Lookups <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Mallocs 是累积被分配的堆内存对象数量。</span></span><br><span class="line">	<span class="comment">// 存活堆内存对象数量是 Mallocs - Frees。</span></span><br><span class="line">	Mallocs <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Frees 是累积被释放掉的堆内存对象数量。</span></span><br><span class="line">	Frees <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 堆内存统计。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 理解堆内存统计需要一些 Go 是如何管理内存的知识。Go 将堆内存虚拟内存空间以 &quot;spans&quot; 为单位进行分割。</span></span><br><span class="line">	<span class="comment">// spans 是 8K（或更大）的连续内存空间。一个 span 可能会在以下三种状态之一：</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 一个 &quot;空闲 idle&quot; 的 span 内部不含任何对象或其他数据。</span></span><br><span class="line">	<span class="comment">// 占用物理内存空间的空闲状态 span 可以被释放回 OS（但虚拟内存空间不会），</span></span><br><span class="line">	<span class="comment">// 或者也可以被转化成为 &quot;使用中 in use&quot; 或 &quot;堆栈 stack&quot; 状态。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 一个 &quot;使用中 in use&quot; span 包含了至少一个堆内存对象且可能还有富余的空间可以分配更多的堆内存对象。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 一个 &quot;堆栈 stack&quot; span 是被用作 goroutine stack 的 内存空间。</span></span><br><span class="line">	<span class="comment">// 堆栈状态的 span 不被视作是堆内存的一部分。一个 span 可以在堆内存和栈内存之间切换；</span></span><br><span class="line">	<span class="comment">// 但不可能同时作为两者。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapAlloc 是已分配的堆内存对象占用的内存量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// &quot;已分配&quot;的堆内存对象包含了所有可达的对象，以及所有垃圾回收器已知但仍未回收的不可达对象。</span></span><br><span class="line">	<span class="comment">// 确切的说，HeapAlloc 随着堆内存对象分配而增长，并随着内存清理、不可达对象的释放而缩小。</span></span><br><span class="line">	<span class="comment">// 清理会随着 GC 循环渐进发生，所有增长和缩小这两个情况是同时存在的，</span></span><br><span class="line">	<span class="comment">// 作为结果 HeapAlloc 的变动趋势是平滑的（与传统的 stop-the-world 型垃圾回收器的锯齿状趋势成对比）。</span></span><br><span class="line">	HeapAlloc <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapSys 是堆内存从 OS 获得的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// HeapSys 维护着为堆内存而保留的虚拟内存空间。这包括被保留但尚未使用的虚拟内存空间，</span></span><br><span class="line">	<span class="comment">// 这部分是不占用实际物理内存的，但趋向于缩小，</span></span><br><span class="line">	<span class="comment">// 和那些占用物理内存但后续因不再使用而释放回 OS 的虚拟内存空间一样。（查看 HeapReleased 作为校对）</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// HeapSys 用来评估堆内存曾经到过的最大尺寸。</span></span><br><span class="line">	HeapSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapIdle 是处于&quot;空闲状态（未使用）&quot;的 spans 占用的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 空闲状态的 spans 内部不含对象。这些 spans 可以（并可能已经被）释放回 OS，</span></span><br><span class="line">	<span class="comment">// 或者它们可以在堆内存分配中重新被利用起来，或者也可以被重新作为栈内存利用起来。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// HeapIdle 减去 HeapReleased 用来评估可以被释放回 OS 的内存总量，</span></span><br><span class="line">	<span class="comment">// 但因为这些内存已经被 runtime 占用了（已经从 OS 申请下来了）所以堆内存可以重新使用这些内存，</span></span><br><span class="line">	<span class="comment">// 就不用再向 OS 申请更多内存了。如果这个差值显著大于堆内存尺寸，这意味着近期堆内存存活对象数量存在一个短时峰值。</span></span><br><span class="line">	HeapIdle <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapInuse 是处于&quot;使用中&quot;状态的 spans 占用的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 使用中的 spans 内部存在至少一个对象。这些 spans 仅可以被用来存储其他尺寸接近的对象。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// HeapInuse 减去 HeapAlloc 用来评估被用来存储特定尺寸对象的内存空间的总量，</span></span><br><span class="line">	<span class="comment">// 但目前并没有被使用。这是内存碎片的上界，但通常来说这些内存会被高效重用。</span></span><br><span class="line">	HeapInuse <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapReleased 是被释放回 OS 的物理内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这个值计算为已经被释放回 OS 的空闲状态的 spans 堆内存空间，且尚未重新被堆内存分配。</span></span><br><span class="line">	HeapReleased <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// HeapObjects 是堆内存中的对象总量。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 和 HeapAlloc 一样，这个值随着对象分配而上涨，随着堆内存清理不可达对象而缩小。</span></span><br><span class="line">	HeapObjects <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 栈内存统计。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 栈内存不被认为是堆内存的一部分，但 runtime 会将一个堆内存中的 span 用作为栈内存，反之亦然。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// StackInuse 是栈内存使用的 spans 占用的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 使用中状态的栈内存 spans 其中至少有一个栈内存。这些 spans 只能被用来存储其他尺寸接近的栈内存。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 并不存在 StackIdle，因为未使用的栈内存 spans 会被释放回堆内存（因此被计入 HeapIdle）。</span></span><br><span class="line">	StackInuse <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// StackSys 是栈内存从 OS 获得的内存总量（bytes）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// StackSys 是 StackInuse 加上一些为了 OS 线程栈而直接从 OS 获取的内存（应该很小）。</span></span><br><span class="line">	StackSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 堆外（off-heap）内存统计。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 下列的统计信息描述了并不会从堆内存进行分配的运行时内部（runtime-internal）结构体（通常因为它们是堆内存实现的一部分）。</span></span><br><span class="line">	<span class="comment">// 不像堆内存或栈内存，任何这些结构体的内存分配仅只是为这些结构服务。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这些统计信息对 debugging runtime 内存额外开销非常有用。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MSpanInuse 是 mspan 结构体分配的内存量（bytes）。</span></span><br><span class="line">	MSpanInuse <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MSpanSys 是为 mspan 结构体从 OS 申请过来的内存量（bytes）。</span></span><br><span class="line">	MSpanSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MCacheInuse 是 mcache 结构体分配的内存量（bytes）。</span></span><br><span class="line">	MCacheInuse <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// MCacheSys 是为 mcache 结构体从 OS 申请过来的内存量（bytes）。</span></span><br><span class="line">	MCacheSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// BuckHashSys 是用来 profiling bucket hash tables 的内存量（bytes）。</span></span><br><span class="line">	BuckHashSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// GCSys 是在垃圾回收中使用的 metadata 的内存量（bytes）。 </span></span><br><span class="line">	GCSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// OtherSys 是各种各样的 runtime 分配的堆外内存量（bytes）。</span></span><br><span class="line">	OtherSys <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 垃圾回收统计。</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NextGC 是下一次 GC 循环的目标堆内存尺寸。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 垃圾回收器的目标是保持 HeapAlloc ≤ NextGC。</span></span><br><span class="line">	<span class="comment">// 在每一轮 GC 循环末尾，下一次循环的目标值会基于当前可达对象数据量以及 GOGC 的值来进行计算。</span></span><br><span class="line">	NextGC <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// LastGC 是上一次垃圾回收完成的时间，其值为自 1970 年纸巾的 nanoseconds（UNIX epoch）。</span></span><br><span class="line">	LastGC <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PauseTotalNs 是自程序启动开始，在 GC stop-the-world 中暂停的累积时长，以 nanoseconds 计数。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 在一次 stop-the-world 暂停期间，所有的 goroutines 都会被暂停，仅垃圾回收器在运行。</span></span><br><span class="line">	PauseTotalNs <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PauseNs 是最近的 GC stop-the-world 暂停耗时的环形缓冲区（以 nanoseconds 计数）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 最近一次的暂停耗时在 PauseNs[(NumGC+255)%256] 这个位置。</span></span><br><span class="line">	<span class="comment">// 通常来说，PauseNs[N%256] 记录着最近第 N%256th 次 GC 循环的暂停耗时。</span></span><br><span class="line">	<span class="comment">// 在每次 GC 循环中可能会有多次暂停；这是在一次循环中的所有暂停时长的总合。</span></span><br><span class="line">	PauseNs [<span class="number">256</span>]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// PauseEnd 是最近的 GC 暂停结束时间的环形缓冲区，其值为自 1970 年纸巾的 nanoseconds（UNIX epoch）。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这个缓冲区的填充方式和 PauseNs 是一致的。</span></span><br><span class="line">	<span class="comment">// 每次 GC 循环可能有多次暂停；这个缓冲区记录的是每个循环的最后一次暂停的结束时间。</span></span><br><span class="line">	PauseEnd [<span class="number">256</span>]<span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumGC 是完成过的 GC 循环的数量。</span></span><br><span class="line">	NumGC <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// NumForcedGC 是应用程序经由调用 GC 函数来强制发起的 GC 循环的数量。</span></span><br><span class="line">	NumForcedGC <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// GCCPUFraction 是自程序启动以来，应用程序的可用 CPU 时间被 GC 消耗的时长部分。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// GCCPUFraction 是一个 0 和 1 之间的数字，0 代表 GC 并没有消耗该应用程序的任何 CPU。</span></span><br><span class="line">	<span class="comment">// 一个应用程序的可用 CPU 时间定义为：自应用程序启动以来 GOMAXPROCS 的积分。</span></span><br><span class="line">	<span class="comment">// 举例来说，如果 GOMAXPROCS 是 2 且应用程序已经运行了 10 秒，那么&quot;可用 CPU 时长&quot;就是 20 秒。</span></span><br><span class="line">	<span class="comment">// GCCPUFraction 并未包含写屏障行为消耗的 CPU 时长。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 该值和经由 GODEBUG=gctrace=1 报告出来的 CPU 时长是一致的。 </span></span><br><span class="line">	GCCPUFraction <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// EnableGC 显示 GC 是否被启用了。该值永远为真，即便 GOGC=off 被启用。</span></span><br><span class="line">	EnableGC <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// DebugGC 目前并未被使用。</span></span><br><span class="line">	DebugGC <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// BySize 汇报了按大小划分的 span 级别内存分配统计信息。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// BySize[N] 给出了尺寸 S 对象的内存分配统计信息，尺寸大小是：</span></span><br><span class="line">	<span class="comment">// BySize[N-1].Size &lt; S ≤ BySize[N].Size。</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 这个结构里的数据并未汇报尺寸大于 BySize[60].Size 的内存分配数据。</span></span><br><span class="line">	BySize [<span class="number">61</span>]<span class="keyword">struct</span> &#123;</span><br><span class="line">		<span class="comment">// Size 是当前尺寸级别可容纳的最大对象的 byte 大小。</span></span><br><span class="line">		Size <span class="keyword">uint32</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Mallocs 是分配到这个尺寸级别的堆内存对象的累积数量。</span></span><br><span class="line">		<span class="comment">// 累积分配的内存容量（bytes）可用：Size*Mallocs 进行计算。</span></span><br><span class="line">		<span class="comment">// 当前尺寸级别内存活的对象数量可以用 Mallocs - Frees 进行计算。</span></span><br><span class="line">		Mallocs <span class="keyword">uint64</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Frees 是当前尺寸级别累积释放的堆内存对象的数量。</span></span><br><span class="line">		Frees <span class="keyword">uint64</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用初始化内存，减少gc周期测试代码"><a href="#使用初始化内存，减少gc周期测试代码" class="headerlink" title="使用初始化内存，减少gc周期测试代码"></a>使用初始化内存，减少gc周期测试代码</h3><blockquote><p>​ 可以看到这个代码很自由初始化240m内存的时候触发了GC，所以后续分配内存没有发生一次GC</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	buffer = makeArr(<span class="number">240</span> &lt;&lt; <span class="number">20</span>) <span class="comment">// 240m ,意思就是堆2*240M是不会触发gc的</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	appender = <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// GODEBUG=gctrace=1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	alloc := <span class="number">4</span> &lt;&lt; <span class="number">20</span></span><br><span class="line">	<span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">		appender = <span class="built_in">append</span>(appender, makeArr(alloc))</span><br><span class="line">		count++</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 到50就回收历史的数据，那么内存达到 480m的时候就会触发gc，所以这个程序结束后内存使用一般是在480m左右</span></span><br><span class="line">		<span class="keyword">if</span> x == <span class="number">50</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> index := <span class="keyword">range</span> appender &#123;</span><br><span class="line">				appender[index] = <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">println</span>(<span class="built_in">len</span>(appender))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeArr</span><span class="params">(<span class="built_in">len</span> <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;分配堆内存: %dM\n&quot;</span>, <span class="built_in">len</span>&gt;&gt;<span class="number">20</span>)</span><br><span class="line">	bytes := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="built_in">len</span>)</span><br><span class="line">	<span class="keyword">for</span> index, _ := <span class="keyword">range</span> bytes &#123;</span><br><span class="line">		bytes[index] = <span class="string">&#x27;x&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bytes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比一下使用buffer和不使用buffer的gc总时间</p><p>分配buffer的gc次数两次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gc 1 @0.009s 0%: 0.016+191+0.034 ms clock, 0.064+0.007/0.13/191+0.13 ms cpu, 240-&gt;240-&gt;240 MB, 241 MB goal, 4 P</span><br><span class="line">gc 2 @1.251s 0%: 0.030+8.8+0.025 ms clock, 0.12+0/0.13/8.6+0.10 ms cpu, 468-&gt;468-&gt;264 MB, 480 MB goal, 4 P</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> gc时间</span></span><br><span class="line">283700 302700 =586400 ns</span><br></pre></td></tr></table></figure><p>未分配buffer的gc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 工9次gc</span></span><br><span class="line">122800 81400 55000 78900 103200 39400 88400 66800 33900  = 669800 ns</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后一次gc</span></span><br><span class="line">gc 9 @1.830s 0%: 0.016+2.2+0.017 ms clock, 0.066+0/0/2.2+0.069 ms cpu, 188-&gt;188-&gt;188 MB, 192 MB goal, 4 P</span><br><span class="line">res: 263M, virt: 355M</span><br></pre></td></tr></table></figure><p>所以整体来说，gc时间基本一致，但是降低gc次数也是一个不错的选择</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://xenojoshua.com/2019/03/golang-memory/">https://xenojoshua.com/2019/03/golang-memory/</a></p></div><div class="reward-container"><div>本人坚持原创技术分享，如果你觉得文章对您有用，请随意打赏! 如果有需要咨询的请发送到我的邮箱!</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Anthony-Dong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="Anthony-Dong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Anthony-Dong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anthony-dong.github.io/2021/04/01/3a1ab3f1f398e2c69489c00767a5a560/" title="Golang的GC的回收">https://anthony-dong.github.io/2021/04/01/3a1ab3f1f398e2c69489c00767a5a560/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Golang/" rel="tag"># Golang</a> <a href="/tags/GC/" rel="tag"># GC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2021/03/29/a22db6b9984d48fcdf4adcc9ff16c659/" rel="prev" title="tcpdump"><i class="fa fa-chevron-left"></i> tcpdump</a></div><div class="post-nav-item"><a href="/2021/05/27/ed44e381cbc098d95c5091eb11450b7e/" rel="next" title="Golang的调度模型">Golang的调度模型 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8"><span class="nav-number">1.</span> <span class="nav-text">程序启动</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gc%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">2.</span> <span class="nav-text">gc初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81triggerRatio"><span class="nav-number">2.1.</span> <span class="nav-text">1、triggerRatio</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81heapminimum"><span class="nav-number">2.2.</span> <span class="nav-text">2、heapminimum</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E6%89%A7%E8%A1%8C%E5%88%86%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">GC执行分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%91%A8%E6%9C%9F%E6%80%A7GC"><span class="nav-number">3.1.</span> <span class="nav-text">1、周期性GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81malloc-gc"><span class="nav-number">3.2.</span> <span class="nav-text">2、malloc gc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%BC%BA%E5%88%B6GC"><span class="nav-number">3.3.</span> <span class="nav-text">3、强制GC</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC%E6%B5%8B%E8%AF%95"><span class="nav-number">4.</span> <span class="nav-text">GC测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81%E5%86%85%E5%AD%98%E6%89%A9%E5%AE%B9GC%E6%B5%8B%E8%AF%95"><span class="nav-number">4.1.</span> <span class="nav-text">1、内存扩容GC测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8Egc%E6%97%A5%E5%BF%97%E5%AD%A6%E4%B9%A0"><span class="nav-number">4.1.1.</span> <span class="nav-text">关于gc日志学习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E5%BC%BA%E5%88%B6gc"><span class="nav-number">4.2.</span> <span class="nav-text">2、强制gc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E5%91%A8%E6%9C%9F%E6%B8%85%E7%90%86"><span class="nav-number">4.3.</span> <span class="nav-text">3、周期清理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Runtime%E4%BF%A1%E6%81%AF"><span class="nav-number">5.</span> <span class="nav-text">获取Runtime信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1%E3%80%81mem%E4%BF%A1%E6%81%AF"><span class="nav-number">5.1.</span> <span class="nav-text">1、mem信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2%E3%80%81%E7%9B%91%E6%8E%A7%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8C%87%E6%A0%87"><span class="nav-number">5.2.</span> <span class="nav-text">2、监控进程的指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3%E3%80%81%E4%BD%BF%E7%94%A8prometheus-%E7%9B%91%E6%8E%A7"><span class="nav-number">5.3.</span> <span class="nav-text">3、使用prometheus 监控</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4%E3%80%81%E4%BD%BF%E7%94%A8-net-http-pprof"><span class="nav-number">5.4.</span> <span class="nav-text">4、使用 net&#x2F;http&#x2F;pprof</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%E3%80%81mem"><span class="nav-number">5.4.1.</span> <span class="nav-text">1、mem</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%E3%80%81goroutine-thread"><span class="nav-number">5.4.2.</span> <span class="nav-text">2、goroutine &#x2F; thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3%E3%80%81%E9%85%8D%E5%90%88go-tool-pprof-%E5%91%BD%E4%BB%A4"><span class="nav-number">5.4.3.</span> <span class="nav-text">3、配合go tool pprof 命令</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1%E3%80%81%E6%AF%94%E5%A6%82%E6%9F%A5%E6%89%BEgoroutine-%E4%BD%BF%E7%94%A8%E7%8E%87%E8%BE%83%E9%AB%98%EF%BC%81"><span class="nav-number">5.4.3.1.</span> <span class="nav-text">1、比如查找goroutine 使用率较高！</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">7.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#mem-%E4%BF%A1%E6%81%AF%E5%AD%97%E6%AE%B5"><span class="nav-number">7.1.</span> <span class="nav-text">mem 信息字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E5%AD%98%EF%BC%8C%E5%87%8F%E5%B0%91gc%E5%91%A8%E6%9C%9F%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="nav-number">7.2.</span> <span class="nav-text">使用初始化内存，减少gc周期测试代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Anthony-Dong" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Anthony-Dong</p><div class="site-description" itemprop="description">追寻技术的本质！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anthony-dong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anthony-dong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@gmail.com" title="E-Mail → mailto:fanhaodong516@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/4248168663101320" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4248168663101320" rel="noopener" target="_blank"><i class="fas fa-book fa-fw"></i>掘金</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@163.com" title="国内邮箱 → mailto:fanhaodong516@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>国内邮箱</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Anthony-Dong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">395k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:01</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/medium-zoom.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.js",()=>{new Gitalk({clientID:"b1c466a9c5677a8d374a",clientSecret:"7cf9512c7e4b46b574e901b18983be7ae5b47d74",repo:"anthony-dong.github.io",owner:"Anthony-Dong",admin:["Anthony-Dong"],id:"353ea3305619dea25bf024a6d08d79d5",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>
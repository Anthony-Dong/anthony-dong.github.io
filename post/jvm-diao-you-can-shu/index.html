<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="shortcut icon"href="https://anthony-dong.github.io/favicon.ico"type="image/x-icon"/><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"/><meta name="description"content="Anthony-Dong的个人博客"/><meta charset="UTF-8"/><title>JVM - 调优参数 | Anthony-Dong</title><link href="https://anthony-dong.github.io/styles/main.css"type="text/css"rel="stylesheet"/><script src="https://anthony-dong.github.io/media/js/magnify.min.js"></script>
	<link rel="canonical" href="https://anthony-dong.github.io/post/jvm-diao-you-can-shu/" />
</head>
<body>
	<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://anthony-dong.github.io"><img alt="logo" style="display:inline-block;" src="https://anthony-dong.github.io/images/avatar.png"/></a><h1 title="Anthony-Dong" class="weaklink shift"><a  href="/">Anthony-Dong</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div>
<div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form-1" data-update="1614223360682" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

	<div class="main">
		<div class="main-inner">
			<div class="content">
				<article class="post">
					<script src='https://anthony-dong.github.io/media/js/Valine.min.js'></script><style>.v .vlist .vcard .vh .vmeta .vat{font-size:.8125em;color:#9d7873;cursor:pointer;float:right}.v .vlist .vcard .vhead .vsys{display:none}</style ><script type="text/javascript">new Valine(ValineInfo)</script>
					<h2 class="post_title sm_margin"><a>JVM - 调优参数</a></h2>
					<script>
						function lan() {
							if (document.getElementById("lan").innerText == "繁") {
								var s = document.getElementById("tongwenlet_cn");
								if (s != null) {
									document.body.removeChild(s)
								}
								var s = document.createElement("script");
								s.language = "javascript";
								s.type = "text/javascript";
								s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";
								s.id = "tongwenlet_cn";
								document.body.appendChild(s);
								document.getElementById("lan").innerHTML = "简"
							} else {
								if (document.getElementById("lan").innerText == "簡") {
									var s = document.getElementById("tongwenlet_cn");
									if (s != null) {
										document.body.removeChild(s)
									}
									var s = document.createElement("script");
									s.language = "javascript";
									s.type = "text/javascript";
									s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";
									s.id = "tongwenlet_cn";
									document.body.appendChild(s);
									document.getElementById("lan").innerHTML = "繁"
								}
							}
						};
					</script>
					<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px">
							2019-11-03</span><i class="iconfont icon-browse"></i>
							<span class="leancloud_visitors" style="margin-right:15px" id="/post/jvm-diao-you-can-shu/">views <i class="leancloud-visitors-count" style="font-style: normal"></i></span>
							<span class="weaklink" style="margin-right:15px"><i class="iconfont icon-category"></i> <a
								href="https://anthony-dong.github.io/tag/eZB86V-Dzpp/"
								class="tag">jvm</a></span><i class="iconfont icon-caret-down"></i><span
							style="margin-right:15px">3940字</span><i
							class="iconfont icon-naozhong"></i><span
							style="margin-right:15px">18 min read</span><a id="lan"
							href="javascript:void(0);" onclick="lan();" title="调整简繁体" style="margin-right:15px;">繁</a>
						</section>

						<div style="display:flex">
							<div class="md_block" id="md_block">
								<div class="round-shape-one"></div>
								<blockquote>
<p>​		首先声明一下我的 JVM版本 ： <code>Java HotSpot(TM) 64-Bit Server VM版本 25.221-b11</code>   ，不同的版本可能结果不用，有很大的差异 。 我的JDK版本是 1.8 。</p>
</blockquote>
<h2 id="1-垃圾回收-gc">1. 垃圾回收 - GC</h2>
<p>​		Java的一大特色就是支持自动的垃圾回收(Garbage Collection) 简称GC . 但是有的时候呢 , 如果垃圾回收频繁的出现, 会出现占用太长的CPU时间, 就不得不引我们的重视了 , 就需要一些 跟踪参数进行查看GC 回收的效率和效果 .</p>
<p>​		对于GC的一些算法以及一些配置参数,下一篇文章讲解 , <a href="https://anthony-dong.github.io/post/jvm-gc-hui-shou-suan-fa">地址</a> : https://anthony-dong.github.io/post/jvm-gc-hui-shou-suan-fa</p>
<p>​		常用的GC 参数有 <code>-XX:+PrintGC</code>   或者是 <code>-XX:+PrintGCDetails</code>  , 更加详细 <code>-XX:+PrintHeapAtGC</code>  , 或者打印 GC回收的时间偏移量   <code>-XX:+PrintGCTimeStamps</code>, 每次GC消耗时间 <code>-XX:+PrintGCApplicationConcurrentTime</code> ,GC的日志文件位置 :  <code>-Xloggc:log/gc.log</code></p>
<p>​		下面这段代码我们尝试运行一下 . 简单体验一下 ：</p>
<pre><code class="language-java">public class TestAllocateStack {

    static class User{
        String name;
    }
    
    private static User user;

    static void allocUser1(){
        user = new User();
        user.name = &quot;name&quot;;
    }
    public static void main(String[] args) {
        long b = System.currentTimeMillis();
        // 2000W次实例化
        for(int i = 0;i&lt; 20000000;i++){
            allocUser1();
        }
        long e = System.currentTimeMillis();
        System.out.println(&quot;main进程 结束 ：&quot;+ (e-b));
        System.out.println(&quot;初始化堆内存最大值 : &quot;+Runtime.getRuntime().maxMemory() / 1000 / 1000+&quot;M&quot;);
    }
}

运行时请输入一下参数 ：  
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps-XX:+PrintGCApplicationConcurrentTime -XX:+PrintCommandLineFlags
</code></pre>
<p>​		日志结果 :</p>
<pre><code class="language-java">// GC消耗了 0.0826751 seconds , 从0.286开始GC
0.286: Application time: 0.0826751 seconds  
// GC 回收了 81920K - &gt; 952K的大小
0.287: [GC (Allocation Failure) [PSYoungGen: 81920K-&gt;952K(95232K)] 81920K-&gt;960K(312320K), 0.0012166 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.311: Application time: 0.0230909 seconds
0.311: [GC (Allocation Failure) [PSYoungGen: 82872K-&gt;808K(95232K)] 82880K-&gt;816K(312320K), 0.0014887 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.334: Application time: 0.0211095 seconds
0.334: [GC (Allocation Failure) [PSYoungGen: 82728K-&gt;760K(95232K)] 82736K-&gt;768K(312320K), 0.0012838 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
main进程 结束 ：148
初始化堆内存最大值 : 4725M
Heap
// 新生代情况
 PSYoungGen      total 95232K, used 75780K [0x0000000756600000, 0x0000000762000000, 0x00000007c0000000)
 // Eden 区域 , 默认和survivor区域的比例是8:1 的关系(也不一定,反正挺高的),可以通过其他参数配置比例
  eden space 81920K, 91% used [0x0000000756600000,0x000000075af43340,0x000000075b600000)
 // Survivor  区域     from                    
  from space 13312K, 5% used [0x000000075b600000,0x000000075b6be030,0x000000075c300000)
 // Survivor  区域      to                           
  to   space 13312K, 0% used [0x0000000761300000,0x0000000761300000,0x0000000762000000)
// 老年代情况                              
 ParOldGen       total 217088K, used 8K [0x0000000683200000, 0x0000000690600000, 0x0000000756600000)
  object space 217088K, 0% used [0x0000000683200000,0x0000000683202000,0x0000000690600000)
//  元数据                              
 Metaspace       used 3274K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
0.357: Application time: 0.0222731 seconds
</code></pre>
<p>​		我们发现 , 系统经历了 3次GC回收 ,  其中每次回收了对应的内存 .</p>
<p>​		对于<code>[0x0000000756600000,0x000000075af43340,0x000000075b600000)</code>这是16进制 , 代表着地址值 , 我们知道堆内存划分位置会对应着一个个地址值 , 这几个数字就代表着地址值 ,  其中 :</p>
<p>第一个参数 : low_boundary ,  可以称之为 low , 这是commited space的最低地址边界</p>
<p>第二个参数 : high, 这是 commited space的最高地址边界</p>
<p>第三个参数 : high_boundary, 这是 reserved space的最高地址边界</p>
<h2 id="2-类的加载和卸载">2. 类的加载和卸载</h2>
<p>​		JAVA程序离不开类的加载与卸载 , 为了更好的了解程序的执行 , 有的时候知道系统加载了哪些类. 基于动态代理和AOP等技术的普遍使用 , 系统可能运行时生成某些类 ,这些类比较隐蔽 ,无法用文件系统查找到, 因此需要类的追踪 .</p>
<p>​		可以使用 参数 <code>-XX:+TraceClassLoading</code> 跟踪类的加载 和  <code>-XX:+TraceClassUnloading</code>跟踪类的卸载</p>
<pre><code class="language-java">public class TraceClassLoading {
    public static void main(String[] args) throws ClassNotFoundException {
        Class.forName(&quot;com.jvm.trace_class_load.C&quot;);
    }
}
interface InterP{}
interface InterC extends InterP{}

class P implements  InterC{}

class C extends P{}
</code></pre>
<p>打印结果  .....</p>
<pre><code class="language-java">[Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar]
[Loaded java.io.Serializable from C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar]
.....
.......
[Loaded com.jvm.trace_class_load.TraceClassLoading from file:/D:/%e4%bb%a3%e7%a0%81%e5%ba%93/javase%e5%ad%a6%e4%b9%a0/DevelopmentJAVA/java-jvm-optimize/target/classes/]
[Loaded sun.launcher.LauncherHelper$FXHelper from C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar]
[Loaded java.lang.Class$MethodArray from C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar]
[Loaded java.lang.Void from C:\Program Files\Java\jdk1.8.0_221\jre\lib\rt.jar]
[Loaded com.jvm.trace_class_load.InterP from file:/D:/%e4%bb%a3%e7%a0%81%e5%ba%93/javase%e5%ad%a6%e4%b9%a0/DevelopmentJAVA/java-jvm-optimize/target/classes/]
[Loaded com.jvm.trace_class_load.InterC from file:/D:/%e4%bb%a3%e7%a0%81%e5%ba%93/javase%e5%ad%a6%e4%b9%a0/DevelopmentJAVA/java-jvm-optimize/target/classes/]
[Loaded com.jvm.trace_class_load.P from file:/D:/%e4%bb%a3%e7%a0%81%e5%ba%93/javase%e5%ad%a6%e4%b9%a0/DevelopmentJAVA/java-jvm-optimize/target/classes/]
[Loaded com.jvm.trace_class_load.C from file:/D:/%e4%bb%a3%e7%a0%81%e5%ba%93/javase%e5%ad%a6%e4%b9%a0/DevelopmentJAVA/java-jvm-optimize/target/classes/]    
</code></pre>
<p>我们发现首先加载的类是 Object 类 , 最后会加载 我们实现的类</p>
<h2 id="3-堆内存">3. 堆内存</h2>
<h3 id="1-最大堆-初始化堆">1. 最大堆 &amp; 初始化堆</h3>
<blockquote>
<p>​	 	当JVM 启动时, 虚拟机就会分配一块初始堆的空间 , 可以使用参数<code>-Xms10m</code> 指定这块空间的大小(此时设置为10m) , 一般来说 , 虚拟机会尽可能的维持在初始堆的空间范围内运行 , 但是当初始堆消耗完,会将堆空间进一步的拓展,其拓展上限为 最大堆空间 ,可以通过 <code>-Xmx20m</code> 进行设置 (此时设置的最大堆空间为20m) .</p>
</blockquote>
<pre><code class="language-java">public class HeapAlloc {
    public static void main(String[] args) {
        System.out.println(&quot;======================================&quot;);

        System.out.println(&quot;初始化&quot;);
        System.out.println(&quot;最大堆空间 : &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;空闲堆空间 : &quot;+Runtime.getRuntime().freeMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;初始化堆空间 : &quot;+Runtime.getRuntime().totalMemory()/1024/1024+&quot;M&quot;);

        System.out.println(&quot;======================================&quot;);

        // byte  是 一个字节 , 所以是 10M
        byte[] b = new byte[2 * 1024 * 1024];
        System.out.println(&quot;分配2M的内存空间&quot;);
        System.out.println(&quot;最大堆空间 : &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;空闲堆空间 : &quot;+Runtime.getRuntime().freeMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;初始化堆空间 : &quot;+Runtime.getRuntime().totalMemory()/1024/1024+&quot;M&quot;);

        System.out.println(&quot;======================================&quot;);

        // byte  是 一个字节 , 所以是 10M
        byte[] b2 = new byte[5 * 1024 * 1024];
        System.out.println(&quot;分配5M的内存空间&quot;);
        System.out.println(&quot;最大堆空间 : &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;空闲堆空间 : &quot;+Runtime.getRuntime().freeMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;初始化堆空间 : &quot;+Runtime.getRuntime().totalMemory()/1024/1024+&quot;M&quot;);

        System.out.println(&quot;======================================&quot;);
    }
}

输入一下指令运行 : 
-Xmx20m -Xms5m -XX:+PrintCommandLineFlags -XX:+PrintGCDetails
</code></pre>
<p>运行结果 ：</p>
<pre><code class="language-java">-XX:InitialHeapSize=5242880 -XX:MaxHeapSize=20971520 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;504K(1536K)] 1024K-&gt;632K(5632K), 0.0009089 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 1518K-&gt;512K(1536K)] 1646K-&gt;927K(5632K), 0.0010350 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
======================================
初始化
// 最大堆空间由于JVM还要给其他空间分配内存,所以可能会占用一部分
最大堆空间 : 18M
空闲堆空间 : 4M
初始化堆空间 : 5M
======================================
分配2M的内存空间
最大堆空间 : 18M
空闲堆空间 : 2M
初始化堆空间 : 5M
======================================
分配5M的内存空间
最大堆空间 : 18M
空闲堆空间 : 2M
// 由于初始堆空间不够 , 会拓展堆空间大小
初始化堆空间 : 11M
======================================
Heap
 PSYoungGen      total 1536K, used 814K [0x00000000ff980000, 0x00000000ffc80000, 0x0000000100000000)
  eden space 1024K, 29% used [0x00000000ff980000,0x00000000ff9cba50,0x00000000ffa80000)
  from space 512K, 100% used [0x00000000ffb00000,0x00000000ffb80000,0x00000000ffb80000)
  to   space 512K, 0% used [0x00000000ffa80000,0x00000000ffa80000,0x00000000ffb00000)
 ParOldGen       total 9728K, used 7583K [0x00000000fec00000, 0x00000000ff580000, 0x00000000ff980000)
  object space 9728K, 77% used [0x00000000fec00000,0x00000000ff367ef8,0x00000000ff580000)
 Metaspace       used 3258K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K

</code></pre>
<h4 id="注意">注意 ：</h4>
<pre><code>	在实际工作中可以将 -Xms 和 -Xmx 的值设置为相同 , 这样可以减少程序运行时进行的垃圾回收次数 , 从而提高程序性能 .  所以当我们将俩个参数值设置为相同时 ,上诉代码就不会进行GC回收了 ,大家可以试一试.
</code></pre>
<h3 id="2-新生代-老年代">2. 新生代 &amp; 老年代</h3>
<blockquote>
<p>​		我们可以通过 <code>-Xmn20m</code> 设置新生代的大小 , 设置一个较大的新生代会减少老年带的大小, 这个参数对于系统的性能以及GC行为会有很大的影响 . 所以我们需要一个比例 , 一般新生代的大小设置为整个堆大小的 <code>[1/3,1/4]</code> 左右 .</p>
<p>​		可以通过参数 <code>-XX:SurvivorRatio=&lt;N&gt;</code>  用来设置新生代中 eden空间和survivor空间的比例关系 . 他们的比例关系一般是 :  <code>-XX:SurvivorRatio=eden/from=eden/to</code>   , 当我们了解了 GC 机制,就知道 如何配置这个比例了 .</p>
<p>​		可以通过 <code>-XX:NewRatio=&lt;N&gt;</code> 设置新生代与老年代的比例 . 下面是一个默认比例。</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://tyut.oss-cn-beijing.aliyuncs.com/image/2019-11-03/a10d0600-ebb7-46ed-9030-fa03e5887186.png?x-oss-process=style/template01" alt="" loading="lazy"></figure>
<pre><code class="language-java">public class SeriallyAllocateHeap {
    public static void main(String[] args) {
        byte[] menory = null;

        System.out.println(&quot;============= 初始化内存空间 =========================&quot;);
        System.out.println(&quot;最大堆空间 : &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;空闲堆空间 : &quot;+Runtime.getRuntime().freeMemory()/1024/1024+&quot;M&quot;);
        System.out.println(&quot;初始化堆空间 : &quot;+Runtime.getRuntime().totalMemory()/1024/1024+&quot;M&quot;);

        for (int i = 0; i &lt; 5; i++) {
            // 创建一块 1M 大小的 空间
            menory = new byte[2 * 1024 * 1024];
            System.out.println(&quot;==============&quot;+&quot;分配第&quot;+(i+1)+&quot;次&quot;+&quot;========================&quot;);
            System.out.println(&quot;最大堆空间 : &quot;+Runtime.getRuntime().maxMemory()/1024/1024+&quot;M&quot;);
            System.out.println(&quot;空闲堆空间 : &quot;+Runtime.getRuntime().freeMemory()/1024/1024+&quot;M&quot;);
            System.out.println(&quot;初始化堆空间 : &quot;+Runtime.getRuntime().totalMemory()/1024/1024+&quot;M&quot;);

        }
        System.out.println(&quot;============= 结束 =========================&quot;);
    }
}

运行时请输入以下参数 : 
-Xmx20m -Xms20m -XX:+PrintGCDetails -XX:+PrintCommandLineFlags -Xmn2m -XX:SurvivorRatio=2
</code></pre>
<p>运行结果 :</p>
<pre><code class="language-java">-XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=2097152 -XX:NewSize=2097152 -XX:+PrintCommandLineFlags -XX:+PrintGCDetails -XX:SurvivorRatio=2 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
[GC (Allocation Failure) [PSYoungGen: 1024K-&gt;504K(1536K)] 1024K-&gt;616K(19968K), 0.0008850 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (Allocation Failure) [PSYoungGen: 1528K-&gt;504K(1536K)] 1640K-&gt;827K(19968K), 0.0008248 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
============= 初始化内存空间 =========================
最大堆空间 : 19M
空闲堆空间 : 18M
初始化堆空间 : 19M
==============分配第1次========================
最大堆空间 : 19M
空闲堆空间 : 16M
初始化堆空间 : 19M
==============分配第2次========================
最大堆空间 : 19M
空闲堆空间 : 14M
初始化堆空间 : 19M
==============分配第3次========================
最大堆空间 : 19M
空闲堆空间 : 12M
初始化堆空间 : 19M
==============分配第4次========================
最大堆空间 : 19M
空闲堆空间 : 10M
初始化堆空间 : 19M
==============分配第5次========================
最大堆空间 : 19M
空闲堆空间 : 8M
初始化堆空间 : 19M
============= 结束 =========================
Heap
// 这里一共是 1536K ,其中eden 为1024K , from 为 512K ,那么 1024K/512k = 2 ,1024K+512k=1536K
 PSYoungGen      total 1536K, used 785K [0x00000000ffe00000, 0x0000000100000000, 0x0000000100000000)
  eden space 1024K, 27% used [0x00000000ffe00000,0x00000000ffe466d0,0x00000000fff00000)
  from space 512K, 98% used [0x00000000fff80000,0x00000000ffffe010,0x0000000100000000)
  to   space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)
 ParOldGen       total 18432K, used 10563K [0x00000000fec00000, 0x00000000ffe00000, 0x00000000ffe00000)
  object space 18432K, 57% used [0x00000000fec00000,0x00000000ff650f38,0x00000000ffe00000)
 Metaspace       used 3244K, capacity 4500K, committed 4864K, reserved 1056768K
  class space    used 350K, capacity 388K, committed 512K, reserved 1048576K
</code></pre>
<h3 id="3-eden-from-to-是什么">3. Eden &amp; From &amp; To 是什么</h3>
<figure data-type="image" tabindex="2"><img src="https://tyut.oss-cn-beijing.aliyuncs.com/image/2019-11-02/8226297e-1fe0-4580-811f-bbbc95cc8ed9.jpg" alt="" loading="lazy"></figure>
<p>​				       	<strong>这是内存划分图(JDK 1.8 将 permanent 区域移到了堆外内存 ,改名为 Metaspace )</strong></p>
<p>​	 	 1、为什么要分代 ？</p>
<p>​	  	其实不分代完全可以，分代的唯一理由就是优化GC性能 . 我们可以想想，如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描 , 此时会消耗很长的时间去查找 。而我们的很多对象都是会死亡的 ,而且伴随着阶段性，如果分代的话，我们把新创建的对象放到某一地方，当GC的时候先把这块存“会死亡的”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p>​		2、其次就是  <code>Eden</code>  , <code>From</code> , <code>To</code>   这三个到底是什么 ?</p>
<p>​		<code>Eden</code>在英文中是 伊甸园的意思,代表着新生 , 而  <code>From</code> , <code>To</code>  空间 其实就是 <code>Survivor</code> 区域, 在用<code>Jconsole工具</code> 时 ,并没有说明这个  <code>From</code> , <code>To</code>   空间 .所以我们不能依靠那个工具去看 .  一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理) , 这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>​		3、关于详细过程 ，下一篇文章讲到 ， <a href="https://anthony-dong.github.io/post/jvm-gc-hui-shou-suan-fa">地址</a> ： https://anthony-dong.github.io/post/jvm-gc-hui-shou-suan-fa</p>
<h2 id="4-非堆内存">4. 非堆内存</h2>
<h3 id="1-方法区元数据区">1. 方法区(元数据区)</h3>
<p>​		方法区主要是存放类的元信息 , 在JDK 1.6 , 1.7 的版本中 , 可以通过使用 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 配置永久区的大小 , 一个是初始的,一个是最大的</p>
<p>​		在JDK1.8中 , 永久区被彻底删除, 使用了新的元数据区域存放类的元数据 . 默认情况下 ,元数据只收系统可用内存的限制 , 但是依旧可以使用参数 <code>-XX:MaxMetaspaceSize</code> 指定元数据区域的最大可用值 .</p>
<h3 id="2-栈">2. 栈</h3>
<p>​		栈是每个线程私有的内存空间 , 在java 虚拟机中可以使用<code>-Xss</code>参数 指定线程的栈大小 .</p>
<h3 id="3-直接内存">3. 直接内存</h3>
<p>​    	直接内存主要是在NIO中应用广泛 , 使用非常的普遍 ,直接内存可以跳过Java 堆 , 使Java 程序可以直接访问原生堆空间 , 因此一定程度上加快了内存空间的访问速度 .</p>
<p>​		最大直接内存可以用 <code>-XX:MaxDirectMemorySize</code> 设置</p>
<h4 id="优势">优势 :</h4>
<p>​		读写能力,直接内存如果被 server 优化后 , 比堆内存提升了一个量级 , 下面是一个测试代码 :</p>
<pre><code class="language-java">public class TestDirectMemory {

    public void directAccess(){
        long start = System.currentTimeMillis();

        ByteBuffer buffer = ByteBuffer.allocateDirect(4000);

        for (int i = 0; i &lt; 10000; i++) {
            for (int j = 0; j &lt; 1000; j++) {
                buffer.put((byte) j);
            }
            buffer.flip();
            while (buffer.hasRemaining()) {
                buffer.get();
            }
            buffer.clear();
        }

        System.out.println(&quot;directAccess : &quot;+(System.currentTimeMillis() - start));
    }


    public void bufferAccess(){
        long start = System.currentTimeMillis();
        ByteBuffer buffer = ByteBuffer.allocate(4000);
        for (int i = 0; i &lt; 100000; i++) {
            for (int j = 0; j &lt; 1000; j++) {
                buffer.put((byte) j);
            }
            buffer.flip();
            while (buffer.hasRemaining()) {
                buffer.get();
            }
            buffer.clear();
        }

        System.out.println(&quot;bufferAccess : &quot;+(System.currentTimeMillis() - start));
    }

    public static void main(String[] args) {
        TestDirectMemory directMemory = new TestDirectMemory();
        directMemory.bufferAccess();
        directMemory.directAccess();

        System.out.println(&quot;=====================&quot;);

        directMemory.bufferAccess();
        directMemory.directAccess();
    }
}

启动 -server 模式
</code></pre>
<p>执行结果 :</p>
<pre><code class="language-java">bufferAccess : 164
directAccess : 46
=====================
bufferAccess : 350
directAccess : 10
</code></pre>
<h4 id="劣势">劣势 :</h4>
<p>对于内存空间的申请上 , 直接内存毫无优势可言 ,所以还是要分情况的</p>
<pre><code class="language-java">public class TestAllocDirectBuffer {

    public void allocDirect() {
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 300000; i++) {
            ByteBuffer.allocateDirect(1024);
        }
        System.out.println(&quot;allocDirect : &quot;+(System.currentTimeMillis() - start));
    }


    public void allocBuffer() {
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 300000; i++) {
            ByteBuffer.allocate(1024);
        }
        System.out.println(&quot;allocBuffer : &quot;+(System.currentTimeMillis() - start));
    }

    public static void main(String[] args) {
        TestAllocDirectBuffer allocDirectBuffer = new TestAllocDirectBuffer();

        allocDirectBuffer.allocBuffer();
        allocDirectBuffer.allocDirect();

        System.out.println(&quot;===============================&quot;);

        allocDirectBuffer.allocBuffer();
        allocDirectBuffer.allocDirect();
    }
}
启动 -server 模式
</code></pre>
<p>结果 :</p>
<pre><code class="language-java">allocBuffer : 114
allocDirect : 313
===============================
allocBuffer : 196
allocDirect : 290
</code></pre>
<h4 id="结论">结论 :</h4>
<p>通过上面我们发现 直接内存适合于申请次数比较少, 访问比较频繁的场合 .</p>
<h2 id="5-server-client-模式">5. Server &amp; Client 模式</h2>
<p>​		目前java的虚拟机都是支持 Client  和 Server 两种运行模式的, 使用 <code>java -version</code> 就可以看出当前虚拟机模式</p>
<pre><code class="language-java">C:\WINDOWS\system32&gt;java -version
java version &quot;1.8.0_221&quot;
Java(TM) SE Runtime Environment (build 1.8.0_221-b11)
Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)
</code></pre>
<p>​		与 client 模式相比 ,server 模式启动比较慢 , 因为server 模式启动会收集更多的系统性能信息 , 使用更复杂的算法对程序进行优化 , 因此当程序进入稳定期以后, server模式的执行速度会远远快于client模式 . 一般64位系统的默认是server 模式</p>
<p>​		关于这两种模式的区别,大家可以网上收集一下 ,下面我只提供 书上讲的 .</p>
<p>​		client模式中 CompileThreshold (编译 阈值 ) 默认是 1500 ,当程序即函数被调用 1500次 后 ,会进行JIT编译 , 而server 模式下 这个阈值是 10000 . 所以server模式更有可能解释执行,但是一旦编译,server模式优化效果会远远好于client模式 .</p>

								<span id="footnote"></span>
								<div id="warn"></div>
							</div>
							<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6-gc">1. 垃圾回收 - GC</a></li>
<li><a href="#2-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%8D%B8%E8%BD%BD">2. 类的加载和卸载</a></li>
<li><a href="#3-%E5%A0%86%E5%86%85%E5%AD%98">3. 堆内存</a>
<ul>
<li><a href="#1-%E6%9C%80%E5%A4%A7%E5%A0%86-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%A0%86">1. 最大堆 &amp; 初始化堆</a>
<ul>
<li><a href="#%E6%B3%A8%E6%84%8F">注意 ：</a></li>
</ul>
</li>
<li><a href="#2-%E6%96%B0%E7%94%9F%E4%BB%A3-%E8%80%81%E5%B9%B4%E4%BB%A3">2. 新生代 &amp; 老年代</a></li>
<li><a href="#3-eden-from-to-%E6%98%AF%E4%BB%80%E4%B9%88">3. Eden &amp; From &amp; To 是什么</a></li>
</ul>
</li>
<li><a href="#4-%E9%9D%9E%E5%A0%86%E5%86%85%E5%AD%98">4. 非堆内存</a>
<ul>
<li><a href="#1-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%85%83%E6%95%B0%E6%8D%AE%E5%8C%BA">1. 方法区(元数据区)</a></li>
<li><a href="#2-%E6%A0%88">2. 栈</a></li>
<li><a href="#3-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98">3. 直接内存</a>
<ul>
<li><a href="#%E4%BC%98%E5%8A%BF">优势 :</a></li>
<li><a href="#%E5%8A%A3%E5%8A%BF">劣势 :</a></li>
<li><a href="#%E7%BB%93%E8%AE%BA">结论 :</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-server-client-%E6%A8%A1%E5%BC%8F">5. Server &amp; Client 模式</a></li>
</ul>
</li>
</ul>
</div>
						</div>
						<div id="fullPage"><canvas id="canvas"></canvas></div>
				</article>
				<div id="eof"><span>EOF</span></div>
				<div class="round-shape-one"></div>
				<section>
					<div class="doc_comments">
							<div id="valine-container"></div>
					</div>
				</section>
			</div>
		</div>
	</div>
	<script>
		"use strict";
		! function () {
			for (var n = document.getElementsByTagName("pre"), e = n.length, s = 0; s < e; s++) {
				n[s].innerHTML = '<span class="line-number"></span>' + n[s].innerHTML + '<span class="cl"></span>';
				for (var a = n[s].innerHTML.split(/\n/).length, r = 0; r < a - 1; r++) {
					n[s].getElementsByTagName("span")[0].innerHTML += "<span>" + (r + 1) + "</span>"
				}
			}
		}();
		let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
		window.addEventListener("scroll", event => {
			let fromTop = window.scrollY;
			mainNavLinks.forEach((link, index) => {
				let section = document.getElementById(decodeURI(link.hash).substring(1));
				let nextSection = null
				if (mainNavLinks[index + 1]) {
					nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(
						1));
				}
				if (section.offsetTop <= fromTop) {
					if (nextSection) {
						if (nextSection.offsetTop > fromTop) {
							link.classList.add("currentToc");
						} else {
							link.classList.remove("currentToc");
						}
					} else {
						link.classList.add("currentToc");
					}
				} else {
					link.classList.remove("currentToc");
				}
			});
		});
		var list = document.querySelectorAll(".katex");
		for (var i = 0; i < list.length; i++) {
			list[i].style.display = "unset"
		};
		var h = document.documentElement,
			b = document.body,
			st = "scrollTop",
			sh = "scrollHeight",
			progress = document.querySelector(".progress"),
			scroll;
		document.addEventListener("scroll", function () {
			scroll = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
			progress.style.setProperty("--scroll", scroll + "%")
		});
		var wxScale = new WxScale({
			fullPage: document.querySelector("#fullPage"),
			canvas: document.querySelector("#canvas")
		});
		var imgBox = document.querySelectorAll("#md_block img");
		for (var i = 0; i < imgBox.length; i++) {
			imgBox[i].onclick = function (e) {
				wxScale.start(this)
			}
		};
	</script>
	<style>
		#magnifyImg {
			position: fixed;
			left: 0;
			top: 0;
			text-align: center;
			width: 100%;
			display: none;
			z-index: 9999
		}

		#magnifyImg img {
			object-fit: contain;
			background: #eaecef;
			padding: 15px;
			border-radius: 10px;
			height: auto;
			width: auto;
			vertical-align: middle
		}
	</style>
	<a id="scrollUp"href="#top"style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"><a href="https://github.com/Anthony-Dong"title="github"><i class="iconfont icon-github"></i></a><a href="fanhaodong516@gmail.com"title="envelope"><i class="iconfont icon-envelope"></i></a></div></div><div class="copyright"id="copyright">You Are My Everything. <a href="mailto:574986060@qq.com" target="blank">Send Email</a>Copyright©2018-2020<a href="https://anthony-dong.github.io"style="margin:0;">Serence</a>.</div><span style="display: inline;margin-right:15px;">👁<strong><span id="count-page">168271</span></strong></span><span id="busuanzi_container_page_pv"style="display: inline;"><span>📚<strong>186</strong>posts</span></div></div><script>console.log("\n %c \u26a1Anthony-Dong's Blog:https://anthony-dong.gitee.io ,Github:https://github.com/Anthony-Dong ,Email:574986060@qq.com ,有事情欢迎联系. \n\n","color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;",);</script>
	<script type="text/javascript" async src="https://anthony-dong.github.io/media/js/prism.js"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="shortcut icon"href="https://anthony-dong.github.io/favicon.ico"type="image/x-icon"/><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"/><meta name="description"content="Anthony-Dong的个人博客"/><meta charset="UTF-8"/><title>Quartz框架设计以及原理 | Anthony-Dong</title><link href="https://anthony-dong.github.io/styles/main.css"type="text/css"rel="stylesheet"/><script src="https://anthony-dong.github.io/media/js/magnify.min.js"></script>
	<link rel="canonical" href="https://anthony-dong.github.io/post/yaoZolVYC/" />
</head>
<body>
	<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://anthony-dong.github.io"><img alt="logo" style="display:inline-block;" src="https://anthony-dong.github.io/images/avatar.png"/></a><h1 title="Anthony-Dong" class="weaklink shift"><a  href="/">Anthony-Dong</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div>
<div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form-1" data-update="1614223342286" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

	<div class="main">
		<div class="main-inner">
			<div class="content">
				<article class="post">
					<script src='https://anthony-dong.github.io/media/js/Valine.min.js'></script><style>.v .vlist .vcard .vh .vmeta .vat{font-size:.8125em;color:#9d7873;cursor:pointer;float:right}.v .vlist .vcard .vhead .vsys{display:none}</style ><script type="text/javascript">new Valine(ValineInfo)</script>
					<h2 class="post_title sm_margin"><a>Quartz框架设计以及原理</a></h2>
					<script>
						function lan() {
							if (document.getElementById("lan").innerText == "繁") {
								var s = document.getElementById("tongwenlet_cn");
								if (s != null) {
									document.body.removeChild(s)
								}
								var s = document.createElement("script");
								s.language = "javascript";
								s.type = "text/javascript";
								s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";
								s.id = "tongwenlet_cn";
								document.body.appendChild(s);
								document.getElementById("lan").innerHTML = "简"
							} else {
								if (document.getElementById("lan").innerText == "簡") {
									var s = document.getElementById("tongwenlet_cn");
									if (s != null) {
										document.body.removeChild(s)
									}
									var s = document.createElement("script");
									s.language = "javascript";
									s.type = "text/javascript";
									s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";
									s.id = "tongwenlet_cn";
									document.body.appendChild(s);
									document.getElementById("lan").innerHTML = "繁"
								}
							}
						};
					</script>
					<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px">
							2020-01-23</span><i class="iconfont icon-browse"></i>
							<span class="leancloud_visitors" style="margin-right:15px" id="/post/yaoZolVYC/">views <i class="leancloud-visitors-count" style="font-style: normal"></i></span>
							<span class="weaklink" style="margin-right:15px"><i class="iconfont icon-category"></i> <a
								href="https://anthony-dong.github.io/tag/tKL7bR-rqBr/"
								class="tag">Quartz</a></span><i class="iconfont icon-caret-down"></i><span
							style="margin-right:15px">3365字</span><i
							class="iconfont icon-naozhong"></i><span
							style="margin-right:15px">17 min read</span><a id="lan"
							href="javascript:void(0);" onclick="lan();" title="调整简繁体" style="margin-right:15px;">繁</a>
						</section>

						<div style="display:flex">
							<div class="md_block" id="md_block">
								<div class="round-shape-one"></div>
								<blockquote>
<p>​	前面8节都是这个框架的几个组件 , 第9节讲的是全部执行流程,最后一节就是总结了 .  希望有兴趣的可以看看 , 提升一下自己 , 不难</p>
</blockquote>
<h2 id="1-schedulerfactory">1. SchedulerFactory</h2>
<figure data-type="image" tabindex="1"><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020-10-11/4b2e500b-d6da-463c-99ef-f7499908073e.png?x-oss-process=style/template01" alt="" loading="lazy"></figure>
<p>有俩实现类, 前面一节我们使用的是StanderScheduleFactory , 其实对于快速使用的话, DirectScheduleFactory 比较好用 .</p>
<p>启动 :</p>
<pre><code class="language-java">// 直接默认启动
Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();

// 或者手动注入配置
Properties properties = new Properties();
properties.setProperty(&quot;org.quartz.scheduler.instanceName&quot;, &quot;MyScheduler&quot;);
properties.setProperty(&quot;org.quartz.threadPool.threadCount&quot;, &quot;4&quot;);
properties.setProperty(&quot;org.quartz.jobStore.class&quot;, &quot;org.quartz.simpl.RAMJobStore&quot;);
StdSchedulerFactory factory = new StdSchedulerFactory(properties);
Scheduler scheduler = factory.getScheduler();

// 3. 系统传参,指定配置文件位置 : org.quartz.properties=quartz.properties

//4. 直接不用传参 ,在Classpath下面建立一个 quartz.properties文件就行了. 
</code></pre>
<p>做了什么 ?  配置咋加载进去的, 其实就在这里 <code>org.quartz.impl.StdSchedulerFactory#getDefaultScheduler</code></p>
<p>他里面实例化了一堆 properties , 具体实现,我真的觉得么写, 代码太简单 了 . 他会有一个默认的实现, 所以不怕因为配置不写, 就启动错误. 或者你直接构造方法传入配置也行 .</p>
<pre><code class="language-java">public static Scheduler getDefaultScheduler() throws SchedulerException {
    StdSchedulerFactory fact = new StdSchedulerFactory();
    return fact.getScheduler();
}
</code></pre>
<p>对于 <code>org.quartz.impl.StdSchedulerFactory#instantiate()</code> 方法比较核心  获取 Scheduler核心方法 代码有上千行,不展示了 , 主要目的就是 初始化一堆的东西 , 封装一堆的东西</p>
<p>主要就是下面这几个</p>
<pre><code class="language-java">JobStore js = null;
ThreadPool tp = null;
QuartzScheduler qs = null;
DBConnectionManager dbMgr = null;
</code></pre>
<p>这四个都有共同的特点,</p>
<ul>
<li>第一 properties注入全部采用的是 set方法反射注入 , <code>org.quartz.impl.StdSchedulerFactory#setBeanProps</code> 这个方法里, 会set注入进去.</li>
<li>第二 全部初始化都是 initialize方法</li>
</ul>
<h2 id="2-jobstore">2. JobStore</h2>
<blockquote>
<p>​	The interface to be implemented by classes that want to provide a Job and Trigger storage mechanism for the org.quartz.core.QuartzScheduler's use.</p>
<p>Storage of Job s and Trigger s should be keyed on the combination of their name and group for uniqueness.</p>
<p>解释很清楚 : 提供 <strong>a Job and Trigger</strong> 存储的给QuartzScheduler's 使用. 同时Job s and Trigger的key应该是独一无二的.</p>
</blockquote>
<p><code>org.quartz.spi.JobStore</code> 很显然就是存储我们Job的东西, 我们如果自己不去告诉他用哪个, 默认实现的是 <code>org.quartz.simpl.RAMJobStore</code></p>
<p>一个基于内存的存储, 很简单一堆集合包住就行了 .  主要注意的是 他会将<code>Job</code> 包装一下称为 <code>JobWrapper</code></p>
<p>主要是支持 三种存储配置  :</p>
<ul>
<li>RAM (直接JVM进程的)</li>
<li>terracotta  (Terracotta是一款由美国Terracotta公司开发的著名开源<a href="https://baike.baidu.com/item/Java/85979">Java</a>集群平台。)</li>
<li>JDBC  (MySQL 之类的 ....)</li>
</ul>
<h2 id="3-threadpool">3. ThreadPool</h2>
<blockquote>
<p>The interface to be implemented by classes that want to provide a thread pool for the org.quartz.core.QuartzScheduler's use.</p>
<p>ThreadPool implementation instances should ideally be made for the sole use of Quartz. Most importantly, when the method blockForAvailableThreads() returns a value of 1 or greater, there must still be at least one available thread in the pool when the method runInThread(Runnable) is called a few moments (or many moments) later. If this assumption does not hold true, it may result in extra JobStore queries and updates, and if clustering features are being used, it may result in greater imballance of load.</p>
</blockquote>
<h2 id="4-quartzschedulerresources">4. QuartzSchedulerResources</h2>
<p>这个就是整个Quartz 的核心资源, 所有资源都在这里.</p>
<h2 id="5-quartzscheduler">5. QuartzScheduler</h2>
<p>整个框架的心脏 ....</p>
<blockquote>
<p>​	This is the heart of Quartz, an indirect implementation of the Scheduler interface, containing methods to schedule Jobs, register JobListener instances, etc.</p>
<p>​	是 quartz的核心, 包含调用job的方法, 注册listener</p>
</blockquote>
<p>构造器  , 所以把核心资源 <code>QuartzSchedulerResources</code> 也给<code>QuartzScheduler</code>了</p>
<pre><code class="language-java">public QuartzScheduler(QuartzSchedulerResources resources, long idleWaitTime, @Deprecated long dbRetryInterval){....}
</code></pre>
<h4 id="quartzschedulerresources">QuartzSchedulerResources</h4>
<blockquote>
<p>​	Contains all of the resources (JobStore,ThreadPool, etc.) necessary to create a QuartzScheduler instance.</p>
<p>​	resources 资源管理器, 包含job和线程池</p>
</blockquote>
<h4 id="idlewaittime">idleWaitTime</h4>
<blockquote>
<p>​	 When the scheduler finds there is no current trigger to fire, how long  it should wait until checking again...</p>
<p>​	就是等待实现, 这个是个死循环, 如果等待时间过短, 会空转很快, 所以就是这个意思, 默认是 30S</p>
</blockquote>
<h4 id="dbretryinterval">dbRetryInterval</h4>
<p><code>deprecated</code> 废弃了, 所以就是交给别人管理了 ,</p>
<p>主要实现 : 就他自己....</p>
<figure data-type="image" tabindex="2"><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020-10-11/b7f6a352-f78d-4c66-a1b6-7f7ebee08bed.png?x-oss-process=style/template01" alt="" loading="lazy"></figure>
<h2 id="6-dbconnectionmanager">6. DBConnectionManager</h2>
<blockquote>
<p>​	Manages a collection of ConnectionProviders, and provides transparent access to their connections.</p>
<p>管理 ConnectionProviders , 提供透明的连接访问 .</p>
</blockquote>
<p>其实他就是</p>
<p>JobStore -&gt; DBConnectionManager -&gt; ConnectionProviders  , 这个可以说是桥接模式. 有一个管理者管理连接的提供者, 然后JobStore 可以通过他获取连接.</p>
<h2 id="7-joblistener-和-triggerlistener">7. JobListener 和  TriggerListener</h2>
<p>首先一点就是 这些都是 <code>ListenerManager</code> 进行管理的 , 他的实现类时 <code>ListenerManagerImpl</code></p>
<p>我们看看  JobListener</p>
<blockquote>
<p>​	The interface to be implemented by classes that want to be informed when a JobDetail executes. In general, applications that use a Scheduler will not have use for this mechanism.</p>
<p>​	a JobDetail executes.会通知你 , 通常使用Scheduler的应用是不会使用这个listener的</p>
</blockquote>
<pre><code class="language-java">public interface JobListener {
    String getName();

    // Job调用前
    void jobToBeExecuted(JobExecutionContext context);

    // veto 否决的意思 , 由 org.quartz.TriggerListener#vetoJobExecution 决定
    void jobExecutionVetoed(JobExecutionContext context);

    // Job调用后
    void jobWasExecuted(JobExecutionContext context,
            JobExecutionException jobException);
}
</code></pre>
<pre><code class="language-java">public interface TriggerListener {

    String getName();

    // 触发Trigger
    void triggerFired(Trigger trigger, JobExecutionContext context);

    // 禁止执行JobExecution
    boolean vetoJobExecution(Trigger trigger, JobExecutionContext context);

    // triggerMisfired
    void triggerMisfired(Trigger trigger);

    void triggerComplete(Trigger trigger, JobExecutionContext context,
            CompletedExecutionInstruction triggerInstructionCode);

}
</code></pre>
<p>执行流程就是下面的 .</p>
<p>triggerFired  -&gt;</p>
<p>​						vetoJobExecution ? false    -&gt; 	jobToBeExecuted - &gt; 调用Job接口中的方法 - &gt; jobWasExecuted</p>
<p>​													 ? true     -&gt;     jobExecutionVetoed</p>
<p>​</p>
<p>使用很简单 实现俩接口就行了,</p>
<pre><code class="language-java">org.quartz.jobListener.j1.class=com.example.springquartz.MyJobListener
// 比如属性设置可以这么做, 只要实现set方法就可以
// org.quartz.jobListener.l1.name=MyJobListener

org.quartz.triggerListener.t1.class=com.example.springquartz.MyTriggerListener
</code></pre>
<h2 id="8-scheduler">8. Scheduler</h2>
<blockquote>
<p>​	This is the main interface of a Quartz Scheduler.</p>
<p>这个是 一个Quartz Scheduler的主接口 , 对外暴露的唯一接口, 可以操作所有资源对象.  主要原因还是他里面包含了 <code>QuartzScheduler</code> , 所以可以操作其他对象.</p>
</blockquote>
<p>我们一般是 <code>StdSchedule</code></p>
<p>主要实现 :</p>
<figure data-type="image" tabindex="3"><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020-10-11/3a70fb1f-0eaa-40e4-a6cf-f678cc654344.png?x-oss-process=style/template01" alt="" loading="lazy"></figure>
<h2 id="9-核心运作流程">9.  核心运作流程 .</h2>
<p><code>QuartzSchedulerResources</code> 把所有东西都放进去了</p>
<p><code>org.quartz.core.QuartzScheduler#QuartzScheduler</code>  是执行的任务的核心 , 就是心脏 .  然后交给了 -&gt; <code>QuartzSchedulerThread</code> 轮询处理</p>
<pre><code class="language-java">public QuartzScheduler(QuartzSchedulerResources resources, long idleWaitTime, @Deprecated long dbRetryInterval)
    throws SchedulerException {
    this.resources = resources;
    if (resources.getJobStore() instanceof JobListener) {
        addInternalJobListener((JobListener)resources.getJobStore());
    }

    // 核心处理线程 - &gt; 这个就是整个心脏 
    this.schedThread = new QuartzSchedulerThread(this, resources);
    ThreadExecutor schedThreadExecutor = resources.getThreadExecutor();
    // 心脏启动 
    schedThreadExecutor.execute(this.schedThread);
    if (idleWaitTime &gt; 0) {
        this.schedThread.setIdleWaitTime(idleWaitTime);
    }

    jobMgr = new ExecutingJobsManager();
    addInternalJobListener(jobMgr);
    errLogger = new ErrorLogger();
    addInternalSchedulerListener(errLogger);

    signaler = new SchedulerSignalerImpl(this, this.schedThread);

    getLog().info(&quot;Quartz Scheduler v.&quot; + getVersion() + &quot; created.&quot;);
}
</code></pre>
<p><code>org.quartz.core.QuartzSchedulerThread#run</code> -&gt;  这里描述是 <code>The main processing loop of the QuartzSchedulerThread.</code></p>
<p>我也不清楚是做啥的 , 但是主要是用来处理Job的 , 封装Job</p>
<pre><code class="language-java">@Override
public void run() {
    int acquiresFailed = 0;

    while (!halted.get()) {
        try {
            // 因为提前开启了 , 所以需要等待真正启动了- &gt; 调用start, 才能继续执行. paused暂停.在
            // org.quartz.core.QuartzScheduler#start执行. 
            // check if we're supposed to pause...
            synchronized (sigLock) {
                while (paused &amp;&amp; !halted.get()) {
                    try {
                        // wait until togglePause(false) is called...
                        sigLock.wait(1000L);
                    } catch (InterruptedException ignore) {
                    }

                    // reset failure counter when paused, so that we don't
                    // wait again after unpausing
                    acquiresFailed = 0;
                }

                if (halted.get()) {
                    break;
                }
            }

            // wait a bit, if reading from job store is consistently
            // failing (e.g. DB is down or restarting)..
            if (acquiresFailed &gt; 1) {
                try {
                    long delay = computeDelayForRepeatedErrors(qsRsrcs.getJobStore(), acquiresFailed);
                    Thread.sleep(delay);
                } catch (Exception ignore) {
                }
            }

            // 这里是获取正在等待的ThreadPool中的线程 . 如果有执行,你要知道`QuartzSchedulerResources` 把所有东西都放进去了
            int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();
            if(availThreadCount &gt; 0) { // will always be true, due to semantics of blockForAvailableThreads...

                // 获取当前时刻的triggers
                List&lt;OperableTrigger&gt; triggers;

                long now = System.currentTimeMillis();

                clearSignaledSchedulingChange();
                try {
                    triggers = qsRsrcs.getJobStore().acquireNextTriggers(
                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());
                    acquiresFailed = 0;
                    if (log.isDebugEnabled())
                        log.debug(&quot;batch acquisition of &quot; + (triggers == null ? 0 : triggers.size()) + &quot; triggers&quot;);
                } catch (JobPersistenceException jpe) {
                    if (acquiresFailed == 0) {
                        // 打印日志
                        qs.notifySchedulerListenersError(
                            &quot;An error occurred while scanning for the next triggers to fire.&quot;,
                            jpe);
                    }
                    if (acquiresFailed &lt; Integer.MAX_VALUE)
                        acquiresFailed++;
                    continue;
                } catch (RuntimeException e) {
                    if (acquiresFailed == 0) {
                        getLog().error(&quot;quartzSchedulerThreadLoop: RuntimeException &quot;
                                +e.getMessage(), e);
                    }
                    if (acquiresFailed &lt; Integer.MAX_VALUE)
                        acquiresFailed++;
                    continue;
                }

                // 这里就是如果有triggers继续执行
                if (triggers != null &amp;&amp; !triggers.isEmpty()) {
                    now = System.currentTimeMillis();
                    long triggerTime = triggers.get(0).getNextFireTime().getTime();
                    long timeUntilTrigger = triggerTime - now;
                    // 这个处理比较灵性.. 死循环, 你差多久, 我就 wait多久
                    while(timeUntilTrigger &gt; 2) {
                        synchronized (sigLock) {
                            if (halted.get()) {
                                break;
                            }
                            if (!isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {
                                try {
                                    // wait
                                    // we could have blocked a long while
                                    // on 'synchronize', so we must recompute
                                    now = System.currentTimeMillis();
                                    timeUntilTrigger = triggerTime - now;
                                    if(timeUntilTrigger &gt;= 1)
                                        sigLock.wait(timeUntilTrigger);
                                } catch (InterruptedException ignore) {
                                }
                            }
                        }
                        if(releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {
                            break;
                        }
                        now = System.currentTimeMillis();
                        timeUntilTrigger = triggerTime - now;
                    }

                    // this happens if releaseIfScheduleChangedSignificantly decided to release triggers
                    // 防止其他发生
                    if(triggers.isEmpty())
                        continue;

                    // 初始化一个 TriggerFiredResult
                    // set triggers to 'executing'
                    List&lt;TriggerFiredResult&gt; bndles = new ArrayList&lt;TriggerFiredResult&gt;();

                    boolean goAhead = true;
                    synchronized(sigLock) {
                        goAhead = !halted.get();
                    }
                    if(goAhead) {
                        try {
                            List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);
                            if(res != null)
                                bndles = res;
                        } catch (SchedulerException se) {
                            qs.notifySchedulerListenersError(
                                    &quot;An error occurred while firing triggers '&quot;
                                            + triggers + &quot;'&quot;, se);
                            //QTZ-179 : a problem occurred interacting with the triggers from the db
                            //we release them and loop again
                            for (int i = 0; i &lt; triggers.size(); i++) {
                                qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            }
                            continue;
                        }

                    }

                    // 循环执行
                    for (int i = 0; i &lt; bndles.size(); i++) {
                        // 
                        TriggerFiredResult result =  bndles.get(i);
                        TriggerFiredBundle bndle =  result.getTriggerFiredBundle();
                        Exception exception = result.getException();

                        if (exception instanceof RuntimeException) {
                            getLog().error(&quot;RuntimeException while firing trigger &quot; + triggers.get(i), exception);
                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            continue;
                        }

                        // it's possible to get 'null' if the triggers was paused,
                        // blocked, or other similar occurrences that prevent it being
                        // fired at this time...  or if the scheduler was shutdown (halted)
                        if (bndle == null) {
                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));
                            continue;
                        }

                        // 初始化任务 
                        JobRunShell shell = null;
                        try {
                            // 初始化流程
                            shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);
                            shell.initialize(qs);
                        } catch (SchedulerException se) {
                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                            continue;
                        }

                        // 这里就是任务执行了. ... 这里就涉及到 -&gt; `org.quartz.simpl.SimpleThreadPool.WorkerThread#run()` 这里了
                        if (qsRsrcs.getThreadPool().runInThread(shell) == false) {
                            // this case should never happen, as it is indicative of the
                            // scheduler being shutdown or a bug in the thread pool or
                            // a thread pool being used concurrently - which the docs
                            // say not to do...
                            getLog().error(&quot;ThreadPool.runInThread() return false!&quot;);
                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);
                        }

                    }

                    continue; // while (!halted)
                }
            } else { // if(availThreadCount &gt; 0)
                // should never happen, if threadPool.blockForAvailableThreads() follows contract
                continue; // while (!halted)
            }

            long now = System.currentTimeMillis();
            long waitTime = now + getRandomizedIdleWaitTime();
            long timeUntilContinue = waitTime - now;
            synchronized(sigLock) {
                try {
                  if(!halted.get()) {
                    // QTZ-336 A job might have been completed in the mean time and we might have
                    // missed the scheduled changed signal by not waiting for the notify() yet
                    // Check that before waiting for too long in case this very job needs to be
                    // scheduled very soon
                    if (!isScheduleChanged()) {
                      sigLock.wait(timeUntilContinue);
                    }
                  }
                } catch (InterruptedException ignore) {
                }
            }

        } catch(RuntimeException re) {
            getLog().error(&quot;Runtime error occurred in main trigger firing loop.&quot;, re);
        }
    } // while (!halted)

    // drop references to scheduler stuff to aid garbage collection...
    qs = null;
    qsRsrcs = null;
}
</code></pre>
<p>这个是启动器, 我们知道启动必须执行一个 Thread.start , 所以不出意外, 上面这个线程他绝对是守护线程, 所有都是, 因为我们start后不阻塞, 直接GG , JVM退出.</p>
<p><code>org.quartz.core.QuartzScheduler#start</code>  -&gt; 这里开始. 核心是 <code>schedThread.togglePause(false)</code> ,</p>
<pre><code class="language-java">public void start() throws SchedulerException {
    if (shuttingDown|| closed) {
        throw new SchedulerException(
                &quot;The Scheduler cannot be restarted after shutdown() has been called.&quot;);
    }

    // QTZ-212 : calling new schedulerStarting() method on the listeners
    // right after entering start()
    notifySchedulerListenersStarting();

    if (initialStart == null) {
        initialStart = new Date();
        this.resources.getJobStore().schedulerStarted();            
        startPlugins();
    } else {
        resources.getJobStore().schedulerResumed();
    }

    // 这里设置的目的就是将它继续执行 -&gt; `org.quartz.core.QuartzSchedulerThread#run`252取消暂停.
    schedThread.togglePause(false);

    getLog().info(
            &quot;Scheduler &quot; + resources.getUniqueIdentifier() + &quot; started.&quot;);

    notifySchedulerListenersStarted();
}
</code></pre>
<p>调用  <code>qsRsrcs.getThreadPool().runInThread(shell)</code> -&gt;  调用 <code>org.quartz.simpl.SimpleThreadPool#runInThread</code> -&gt; 这个然后下面</p>
<pre><code class="language-java">public boolean runInThread(Runnable runnable) {
    if (runnable == null) {
        return false;
    }

    synchronized (nextRunnableLock) {

        handoffPending = true;

        // Wait until a worker thread is available , 这里就是等 , 等有可用的线程,这里我不理解为啥不使用队列... 其实可以使用队列的. 
        while ((availWorkers.size() &lt; 1) &amp;&amp; !isShutdown) {
            try {
                nextRunnableLock.wait(500);
            } catch (InterruptedException ignore) {
            }
        }

        if (!isShutdown) {
            // 等到了, 拿着第一个可用线程执行 
            WorkerThread wt = (WorkerThread)availWorkers.removeFirst();
            busyWorkers.add(wt);
            wt.run(runnable);
        } else {
            // If the thread pool is going down, execute the Runnable
            // within a new additional worker thread (no thread from the pool).
            WorkerThread wt = new WorkerThread(this, threadGroup,
                    &quot;WorkerThread-LastJob&quot;, prio, isMakeThreadsDaemons(), runnable);
            busyWorkers.add(wt);
            workers.add(wt);
            wt.start();
        }
        // 释放锁
        nextRunnableLock.notifyAll();
        handoffPending = false;
    }

    // 返回OK , 这里其实是异步的 , 因为处理流程交给了子线程, 他只是返回了他已经处理了, 但是有一个问题就是线程处理时间过长, 就会影响周期性.(所以建议设置多点,但是也不好,线程一直处于不断运行阶段)
    return true;
}

</code></pre>
<p>调用  <code>wt.run(runnable);</code> -&gt; 调用<code>org.quartz.simpl.SimpleThreadPool.WorkerThread#run(java.lang.Runnable)</code> 执行 run方法</p>
<pre><code class="language-java">public void run(Runnable newRunnable) {
    synchronized(lock) {
        if(runnable != null) {
            throw new IllegalStateException(&quot;Already running a Runnable!&quot;);
        }

        runnable = newRunnable;
        lock.notifyAll();
    }
}
</code></pre>
<p>然后执行等待着的线程中 , 死死的等哇 -&gt;  等下面这个执行 ..</p>
<p><code>org.quartz.simpl.SimpleThreadPool.WorkerThread#run()</code>  每一个工作线程初始化的时候都是在这里一直的等待哇. 等哇等 , 等哇等.</p>
<pre><code class="language-java">@Override
public void run() {
    boolean ran = false;

    // 转 ....
    while (run.get()) {
        try {
            // 同步等待. 500ms , 直到有 runnable ... 很可怜, 其实基本大多都是这么实现的 eventloop
            synchronized(lock) {
                while (runnable == null &amp;&amp; run.get()) {
                    lock.wait(500);
                }

                if (runnable != null) {
                    ran = true;
                    // 启动任务, 这里直接将Runnable对象启动, 而不是new thread(runnable).start,而是直接调用的方式. 让这个线程去处理. 
                    runnable.run();
                }
            }
        } catch (InterruptedException unblock) {
            // do nothing (loop will terminate if shutdown() was called
            try {
                getLog().error(&quot;Worker thread was interrupt()'ed.&quot;, unblock);
            } catch(Exception e) {
                // ignore to help with a tomcat glitch
            }
        } catch (Throwable exceptionInRunnable) {
            try {
                getLog().error(&quot;Error while executing the Runnable: &quot;,
                    exceptionInRunnable);
            } catch(Exception e) {
                // ignore to help with a tomcat glitch
            }
        } finally {
            synchronized(lock) {
                runnable = null;
            }
            // repair the thread in case the runnable mucked it up...
            if(getPriority() != tp.getThreadPriority()) {
                setPriority(tp.getThreadPriority());
            }

            if (runOnce) {
                   run.set(false);
                clearFromBusyWorkersList(this);
            } else if(ran) {
                ran = false;
                makeAvailable(this);
            }
        }
    }

    //if (log.isDebugEnabled())
    try {
        getLog().debug(&quot;WorkerThread is shut down.&quot;);
    } catch(Exception e) {
        // ignore to help with a tomcat glitch
    }
}
</code></pre>
<h4 id="wait-使用">wait 使用</h4>
<pre><code class="language-java">public class Demo {
    public static final Object OBJECT = new Object();

    public static void main(String[] args) throws InterruptedException {
        long start = System.currentTimeMillis();
        while (true) {
            synchronized (OBJECT) {
                System.out.println(&quot;time : &quot; + (System.currentTimeMillis() - start) + &quot;ms.&quot;);
                OBJECT.wait(1000L);
            }
        }
    }
}
</code></pre>
<p>输出</p>
<pre><code class="language-java">time : 0ms.
time : 1000ms.
time : 2001ms.
time : 3002ms.
time : 4002ms.
time : 5003ms.
</code></pre>
<h2 id="10-总结">10. 总结</h2>
<p>Quartz框架分析了一波, 主要就是类似于NIO的思想 , 主线程不断的监听和轮询worker线程, 同时还要监听Trigger , 看看能不能触发了, 可以了,找个闲着的work线程去处理  ,  所以就是NIO的思想.</p>
<p>但是有几个问题, 如果初始化线程(work线程)过多, 那么这些线程在初始化阶段就已经启动了 , 所以很消耗CPU资源,</p>
<p>如果初始化线程(work线程)过少  , 那么就容易发生阻塞的现象, 所以 ..................</p>
<p>他的设计架构还是很不错的 , 可以说是设计模式, 整体的设计完全解耦 . 相当nice.  其实学习框架就是提高自己的设计思想, 不断的学习不断的发现新大陆 .</p>

								<span id="footnote"></span>
								<div id="warn"></div>
							</div>
							<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#1-schedulerfactory">1. SchedulerFactory</a></li>
<li><a href="#2-jobstore">2. JobStore</a></li>
<li><a href="#3-threadpool">3. ThreadPool</a></li>
<li><a href="#4-quartzschedulerresources">4. QuartzSchedulerResources</a></li>
<li><a href="#5-quartzscheduler">5. QuartzScheduler</a><br>
*
<ul>
<li><a href="#quartzschedulerresources">QuartzSchedulerResources</a></li>
<li><a href="#idlewaittime">idleWaitTime</a></li>
<li><a href="#dbretryinterval">dbRetryInterval</a></li>
</ul>
</li>
<li><a href="#6-dbconnectionmanager">6. DBConnectionManager</a></li>
<li><a href="#7-joblistener-%E5%92%8C-triggerlistener">7. JobListener 和  TriggerListener</a></li>
<li><a href="#8-scheduler">8. Scheduler</a></li>
<li><a href="#9-%E6%A0%B8%E5%BF%83%E8%BF%90%E4%BD%9C%E6%B5%81%E7%A8%8B">9.  核心运作流程 .</a><br>
*
<ul>
<li><a href="#wait-%E4%BD%BF%E7%94%A8">wait 使用</a></li>
</ul>
</li>
<li><a href="#10-%E6%80%BB%E7%BB%93">10. 总结</a></li>
</ul>
</li>
</ul>
</div>
						</div>
						<div id="fullPage"><canvas id="canvas"></canvas></div>
				</article>
				<div id="eof"><span>EOF</span></div>
				<div class="round-shape-one"></div>
				<section>
					<div class="doc_comments">
							<div id="valine-container"></div>
					</div>
				</section>
			</div>
		</div>
	</div>
	<script>
		"use strict";
		! function () {
			for (var n = document.getElementsByTagName("pre"), e = n.length, s = 0; s < e; s++) {
				n[s].innerHTML = '<span class="line-number"></span>' + n[s].innerHTML + '<span class="cl"></span>';
				for (var a = n[s].innerHTML.split(/\n/).length, r = 0; r < a - 1; r++) {
					n[s].getElementsByTagName("span")[0].innerHTML += "<span>" + (r + 1) + "</span>"
				}
			}
		}();
		let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
		window.addEventListener("scroll", event => {
			let fromTop = window.scrollY;
			mainNavLinks.forEach((link, index) => {
				let section = document.getElementById(decodeURI(link.hash).substring(1));
				let nextSection = null
				if (mainNavLinks[index + 1]) {
					nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(
						1));
				}
				if (section.offsetTop <= fromTop) {
					if (nextSection) {
						if (nextSection.offsetTop > fromTop) {
							link.classList.add("currentToc");
						} else {
							link.classList.remove("currentToc");
						}
					} else {
						link.classList.add("currentToc");
					}
				} else {
					link.classList.remove("currentToc");
				}
			});
		});
		var list = document.querySelectorAll(".katex");
		for (var i = 0; i < list.length; i++) {
			list[i].style.display = "unset"
		};
		var h = document.documentElement,
			b = document.body,
			st = "scrollTop",
			sh = "scrollHeight",
			progress = document.querySelector(".progress"),
			scroll;
		document.addEventListener("scroll", function () {
			scroll = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
			progress.style.setProperty("--scroll", scroll + "%")
		});
		var wxScale = new WxScale({
			fullPage: document.querySelector("#fullPage"),
			canvas: document.querySelector("#canvas")
		});
		var imgBox = document.querySelectorAll("#md_block img");
		for (var i = 0; i < imgBox.length; i++) {
			imgBox[i].onclick = function (e) {
				wxScale.start(this)
			}
		};
	</script>
	<style>
		#magnifyImg {
			position: fixed;
			left: 0;
			top: 0;
			text-align: center;
			width: 100%;
			display: none;
			z-index: 9999
		}

		#magnifyImg img {
			object-fit: contain;
			background: #eaecef;
			padding: 15px;
			border-radius: 10px;
			height: auto;
			width: auto;
			vertical-align: middle
		}
	</style>
	<a id="scrollUp"href="#top"style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"><a href="https://github.com/Anthony-Dong"title="github"><i class="iconfont icon-github"></i></a><a href="fanhaodong516@gmail.com"title="envelope"><i class="iconfont icon-envelope"></i></a></div></div><div class="copyright"id="copyright">You Are My Everything. <a href="mailto:574986060@qq.com" target="blank">Send Email</a>Copyright©2018-2020<a href="https://anthony-dong.github.io"style="margin:0;">Serence</a>.</div><span style="display: inline;margin-right:15px;">👁<strong><span id="count-page">168271</span></strong></span><span id="busuanzi_container_page_pv"style="display: inline;"><span>📚<strong>186</strong>posts</span></div></div><script>console.log("\n %c \u26a1Anthony-Dong's Blog:https://anthony-dong.gitee.io ,Github:https://github.com/Anthony-Dong ,Email:574986060@qq.com ,有事情欢迎联系. \n\n","color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;",);</script>
	<script type="text/javascript" async src="https://anthony-dong.github.io/media/js/prism.js"></script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
	<link rel="shortcut icon"href="https://anthony-dong.github.io/favicon.ico"type="image/x-icon"/><meta name="viewport"content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"/><meta name="apple-mobile-web-app-capable"content="yes"/><meta name="apple-mobile-web-app-status-bar-style"content="black"/><meta name="format-detection"content="telephone=no"/><meta name="renderer"content="webkit"/><meta name="description"content="Anthony-Dong的个人博客"/><meta charset="UTF-8"/><title>CGLIB - 源码分析和深入理解 | Anthony-Dong</title><link href="https://anthony-dong.github.io/styles/main.css"type="text/css"rel="stylesheet"/><script src="https://anthony-dong.github.io/media/js/magnify.min.js"></script>
	<link rel="canonical" href="https://anthony-dong.github.io/post/MxGQZU6bO/" />
</head>
<body>
	<div class="progress"></div><style>.progress{background:linear-gradient(to right,#87ceeb var(--scroll),transparent 0);background-repeat:no-repeat;position:fixed;width:100%;height:4px;z-index:1}</style><div class="darkmode-background"></div><div class="darkmode-layer"></div>
<noscript><p class="warn" >本页面需要浏览器支持（启用）JavaScript</p></noscript><div class="header"><div class="logo_title"><div class="title animated fadeInDown"><a href="https://anthony-dong.github.io"><img alt="logo" style="display:inline-block;" src="https://anthony-dong.github.io/images/avatar.png"/></a><h1 title="Anthony-Dong" class="weaklink shift"><a  href="/">Anthony-Dong</a></h1>

<div class="navbar weaklink">
<div class="normal_nav">
<div class="bitcron_nav_container"><div class="bitcron_nav"><div class="bitcron_nav"><div style="display:flex;justify-content:center;"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul></nav>
<div style="float:right;margin-top:1em"><form id="gridea-search-form" data-update="1578893743252" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="Search..."></form></div>
<div style="margin-left:0.5em;margin-top:1.2em"><input id="switch_default" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
<div class="clear clear_nav_inline_end"></div></div></div><div class="clear clear_nav_end"></div></div></div><div class="hamberger" href="javascript:void(0)" onclick="btn_toggle();"><i class="iconfont icon-category"></i></div></div></div></div>
<div id="hn" class="no-js hidden_nav animated fadeInDown"><div class="bitcron_nav_container"><div class="bitcron_nav"><nav class="mixed_site_nav_wrap site_nav_wrap"><ul class="mixed_site_nav site_nav sm sm-base">	<li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/" class="selected active current nav__item" >首页</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/archives" class="selected active current nav__item" >归档</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/tags" class="selected active current nav__item" >标签</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/about" class="selected active current nav__item" >关于</a></li><li><a id="d2ef19af68cc211e98f8a0242ac110003" href="/post/link" class="selected active current nav__item" >友链</a></li></ul><div class="clear clear_nav_inline_end"></div></nav></div><div class="clear clear_nav_end"></div></div>
<div style="display:flex;justify-content:center;inline-block;text-align:center;margin-top:7%"><div><form id="gridea-search-form-1" data-update="1614223360682" action="/search/index.html"><input class="search-input" autocomplete="off" spellcheck="false" name="q"  placeholder="Search..." /></form></div><div style="margin-left:0.5em"><input id="switch_default_h" onclick="mobileBtn()" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div>
</div></div>
<script>function enableDarkmode(){document.body.classList.add("darkmode"),document.getElementById("switch_default").checked=1,document.getElementById("switch_default_h").checked=1}function removeDarkmode(){document.body.classList.remove("darkmode"),document.getElementById("switch_default").checked=0,document.getElementById("switch_default_h").checked=0}function getCookie(a){var b,c=new RegExp("(^| )"+a+"=([^;]*)(;|$)");return(b=document.cookie.match(c))?unescape(b[2]):null}cookie=getCookie("darkmode"),"enable"==cookie&&enableDarkmode(),window.matchMedia("(prefers-color-scheme: dark)").matches&&"disable"!==cookie&&(enableDarkmode(),document.cookie="darkmode=enable; path=/");var mobileBtn=function(){1==document.getElementById("switch_default").checked?(enableDarkmode(),document.cookie="darkmode=enable; path=/"):(removeDarkmode(),document.cookie="darkmode=disable; path=/")};</script>

	<div class="main">
		<div class="main-inner">
			<div class="content">
				<article class="post">
					<script src='https://anthony-dong.github.io/media/js/Valine.min.js'></script><style>.v .vlist .vcard .vh .vmeta .vat{font-size:.8125em;color:#9d7873;cursor:pointer;float:right}.v .vlist .vcard .vhead .vsys{display:none}</style ><script type="text/javascript">new Valine(ValineInfo)</script>
					<h2 class="post_title sm_margin"><a>CGLIB - 源码分析和深入理解</a></h2>
					<script>
						function lan() {
							if (document.getElementById("lan").innerText == "繁") {
								var s = document.getElementById("tongwenlet_cn");
								if (s != null) {
									document.body.removeChild(s)
								}
								var s = document.createElement("script");
								s.language = "javascript";
								s.type = "text/javascript";
								s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_tw.js";
								s.id = "tongwenlet_cn";
								document.body.appendChild(s);
								document.getElementById("lan").innerHTML = "简"
							} else {
								if (document.getElementById("lan").innerText == "簡") {
									var s = document.getElementById("tongwenlet_cn");
									if (s != null) {
										document.body.removeChild(s)
									}
									var s = document.createElement("script");
									s.language = "javascript";
									s.type = "text/javascript";
									s.src = "https://cdn.jsdelivr.net/gh/qyxtim/Static@1.1/bookmarklet_cn.js";
									s.id = "tongwenlet_cn";
									document.body.appendChild(s);
									document.getElementById("lan").innerHTML = "繁"
								}
							}
						};
					</script>
					<section class="post_details"><i class="iconfont icon-calendar"></i><span style="margin-right:15px">
							2020-03-22</span><i class="iconfont icon-browse"></i>
							<span class="leancloud_visitors" style="margin-right:15px" id="/post/MxGQZU6bO/">views <i class="leancloud-visitors-count" style="font-style: normal"></i></span>
							<span class="weaklink" style="margin-right:15px"><i class="iconfont icon-category"></i> <a
								href="https://anthony-dong.github.io/tag/VGFs7LxPgW/"
								class="tag">中间件</a> |
							 <a
								href="https://anthony-dong.github.io/tag/Vyew36Twpl/"
								class="tag">Java基础</a> |
							 <a
								href="https://anthony-dong.github.io/tag/30KjDURvPf/"
								class="tag">spring</a></span><i class="iconfont icon-caret-down"></i><span
							style="margin-right:15px">4836字</span><i
							class="iconfont icon-naozhong"></i><span
							style="margin-right:15px">24 min read</span><a id="lan"
							href="javascript:void(0);" onclick="lan();" title="调整简繁体" style="margin-right:15px;">繁</a>
						</section>

						<div style="display:flex">
							<div class="md_block" id="md_block">
								<div class="round-shape-one"></div>
								<blockquote>
<p>​	CGLIB 呢, 相对于Java的代理来说, 更加灵活和富有弹性, 他的功能提供的更加的强大, 依靠callback实现的功能的增强.</p>
<p>​	通过这篇文章我相信你对于CGLIB的了解会提升一个档次的 .  本文开始从快速开始上手体验, 理解其核心模块,到源码分析其启动流程, 然后分析一些存在的问题.</p>
<p>​	官网地址:  https://github.com/cglib/cglib</p>
</blockquote>
<h2 id="快速使用">快速使用</h2>
<p>需要被增强的类.</p>
<pre><code class="language-java">public class UserService {
    public String findUserNameById(int id) {
        return &quot;name-&quot; + id;
    }
}
</code></pre>
<p>启动类:</p>
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        // 设置字节码保存的地方.
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:/test&quot;);
        // 1.创建一个增强器
        Enhancer enhancer = new Enhancer();
        // 2.设置父类
        enhancer.setSuperclass(UserService.class);
        // 3.设置回调接口
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
                // invokeSuper是必须使用的.
                return &quot;proxy&quot; + proxy.invokeSuper(obj, args);
            }
        });
        // 4.启动
        UserService userService = (UserService) enhancer.create();
        String userNameById = userService.findUserNameById(1);
        System.out.println(userNameById);
    }
}
</code></pre>
<p>基本流程就是上面那么写的 , 那么 <code>CallBack</code>是什么呢 , 下文讲解</p>
<h2 id="cglib功能核心-callback">CGLIB功能核心 - <code>CallBack</code></h2>
<blockquote>
<p>​	这个玩意的功能的核心, 也就是CallBack , 依靠它来实现业务逻辑.</p>
</blockquote>
<h3 id="methodinterceptor"><code>MethodInterceptor</code></h3>
<blockquote>
<p>顾名思义 拦截器. 所以就是一个环绕型的.</p>
</blockquote>
<pre><code class="language-java">public interface MethodInterceptor
extends Callback
{
    public Object intercept(Object obj, java.lang.reflect.Method method, Object[] args,
                               MethodProxy proxy) throws Throwable;
}
</code></pre>
<p>大多数都是使用的这个.</p>
<p>注意一般是调用的话, 使用的是 <code>proxy.invokeSuper(obj, args)</code> , 不然会出现递归, 出不去的问题 .</p>
<h3 id="noop"><code>NoOp</code></h3>
<blockquote>
<p>​	这个就是什么都不做. 就是代表这个方法不会做代理, 也就是不会重写父类的方法, 因此就直接走父类的实现.</p>
</blockquote>
<pre><code class="language-java">public interface NoOp extends Callback
{
    public static final NoOp INSTANCE = new NoOp() { };
}
</code></pre>
<p>我们使用的使用只需要传入这个 <code>INSTANCE</code> 就行了.  实现逻辑很简单, 就是我不重写父类的方法不就行了,  哈哈哈哈. 就是这么走的.</p>
<h3 id="lazyloader"><code>LazyLoader</code></h3>
<blockquote>
<p>​	就是一个懒加载的机制. 说是懒加载, 其实也不是, 他指的是, 我们每次调用的时候吧, 我们不用我们<code>enhancer.create()</code>生成的这个对象, 这个确实是生成了, 而是使用的是<code>LazyLoader.loadObject()</code> 生成的对象去执行方法.  业务逻辑如下.</p>
</blockquote>
<pre><code class="language-java">public interface LazyLoader extends Callback {
    Object loadObject() throws Exception;
}
</code></pre>
<p>实现原理的话 ,如下 . 很简单的其实是 .</p>
<pre><code class="language-java">public class App2 {
    public static void main(String[] args) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:/test&quot;);
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback((LazyLoader) UserService::new);
        UserService userService = (UserService) enhancer.create();
        String userNameById = userService.findUserNameById(1);
        System.out.println(userNameById);
    }
}
</code></pre>
<p>我们看看生成的字节码 , 就会发现其中的问题 , 原来就是这玩意哇. 哈哈哈哈.</p>
<pre><code class="language-java">public final String findUserNameById(int var1) {
    // 先去拿对象,但是每次都加锁.感觉效率好低.不如双重锁.
    return ((UserService)this.CGLIB$LOAD_PRIVATE_0()).findUserNameById(var1);
}
// 这里就是加了同步机制, 所以效率不高. 因为每次都要调用.
private final synchronized Object CGLIB$LOAD_PRIVATE_0() {
    // 这里判断一下对象是否是空. 空就创建一个.
    Object var10000 = this.CGLIB$LAZY_LOADER_0;
    if (var10000 == null) {
        LazyLoader var10001 = this.CGLIB$CALLBACK_0;
        if (var10001 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10001 = this.CGLIB$CALLBACK_0;
        }
        var10000 = this.CGLIB$LAZY_LOADER_0 = var10001.loadObject();
    }
    // 返回就行了.
    return var10000;
}
</code></pre>
<h3 id="dispatcher"><code>Dispatcher</code></h3>
<blockquote>
<p>​	和LazyLoad 一样, 但是它是每次方法调用的时候都会去调用<code>loadObject</code>.</p>
</blockquote>
<pre><code class="language-java">public interface Dispatcher extends Callback {
    Object loadObject() throws Exception;
}
</code></pre>
<p>字节码我们看看</p>
<pre><code class="language-java">public final String findUserNameById(int var1) {
    Dispatcher var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    // 每次都会调用Dispatcher.loadObject() , 所以就是每次方法调用都回去执行调用.
    return ((UserService)var10000.loadObject()).findUserNameById(var1);
}
</code></pre>
<h3 id="invocationhandler"><code>InvocationHandler</code></h3>
<p>和Java的代理一样的.  基本逻辑是一样的.</p>
<pre><code class="language-java">public interface InvocationHandler
extends Callback
{
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
}
</code></pre>
<p>生成的代码如下</p>
<pre><code class="language-java">public final String findUserNameById(int var1) {
    try {
        InvocationHandler var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }
        return (String)var10000.invoke(this, CGLIB$findUserNameById$0, new Object[]{new Integer(var1)});
    } catch (var2) {
        // 异常处理
    } 
}

// CGLIB$findUserNameById$0 = Class.forName(&quot;com.example.aop.UserService&quot;).getDeclaredMethod(&quot;findUserNameById&quot;, Integer.TYPE); 就是我们父类的方法.
</code></pre>
<h3 id="fixedvalue"><code>FixedValue</code></h3>
<blockquote>
<p>​	他呢就是每次方法调用都会调用这个玩意作为 <code>FixedValue.loadObject()</code> 作为方法的返回值.</p>
</blockquote>
<pre><code class="language-java">public interface FixedValue extends Callback {
    Object loadObject() throws Exception;
}
</code></pre>
<p>生成的代码如下</p>
<pre><code class="language-java">public final String findUserNameById(int var1) {
    FixedValue var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
	// 他呢就是调用`loadObject()` 作为调用findUserNameById方法的返回值. 跟equals\toString都是这个逻辑.所以就是这逻辑.
    return (String)var10000.loadObject();
}
</code></pre>
<h2 id="啥时候用-callbackfilter">啥时候用 <code>CallbackFilter</code></h2>
<p>这个很简单,  意思就是一个过滤器. 可以生成不同的策略.  比如有些时候我们有多个 <code>MethodInterceptor</code> , 那怎么办呢. 显然是不行的了.  所以此时需要一个. Filter进行对号入座. 懂了吧.</p>
<blockquote>
<p>​	注意当多个<code>CallBack</code>的同时使用的时候必须使用 <code>CallbackFilter</code> 进入对号入座 .</p>
</blockquote>
<pre><code class="language-java">public interface CallbackFilter {

    // int值, 返回值是 CallBack数组的索引下标, 也就是不能超过CallBack数组的下标.
    int accept(Method method);
}
</code></pre>
<p>我们来个简单的例子.</p>
<pre><code class="language-jaa">public class UserService {
    public String findUserNameById1(int id) {
        return &quot;name1-&quot; + id;
    }
    public String findUserNameById2(int id) {
        return &quot;name2-&quot; + id;
    }
}
</code></pre>
<p>比如说 , 我们改造一下原来的<code>UserService</code>实现.  多加一个方法, 让我们的拦截器一拦截方法一, 然后拦截器二拦截方法二.  其他方法我们使用父类的方法, 不去重写.</p>
<pre><code class="language-java">public class App {

    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);

        Callback[] callback = new Callback[3];
        callback[0] = (MethodInterceptor) (obj, method, args1, proxy) -&gt; &quot;MethodInterceptor1 : &quot;+proxy.invokeSuper(obj, args1);
        callback[1] = (MethodInterceptor) (obj, method, args1, proxy) -&gt; &quot;MethodInterceptor2 : &quot;+proxy.invokeSuper(obj, args1);
        callback[2] = NoOp.INSTANCE;

        enhancer.setCallbacks(callback);
        enhancer.setCallbackFilter(method -&gt; {
            if (method.getName().equals(&quot;findUserNameById1&quot;)) {
                return 0;
            }
            if (method.getName().equals(&quot;findUserNameById2&quot;)) {
                return 1;
            }
            return 2;
        });
        UserService userService = (UserService) enhancer.create();
        System.out.println(userService.findUserNameById1(1));
        System.out.println(userService.findUserNameById2(1));
    }
}
</code></pre>
<p>输出 :</p>
<pre><code class="language-java">MethodInterceptor1 : name1-1
MethodInterceptor2 : name2-1
</code></pre>
<h2 id="encher代理的原理源码分析">Encher代理的原理(源码分析)</h2>
<pre><code class="language-java">public class App {

    public static void main(String[] args) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:/test&quot;);
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback(new Dispatcher() {
            @Override
            public Object loadObject() throws Exception {
                return new UserService();
            }
        });
        // 核心流程在这里.因为创建最麻烦. 
        UserService userService = (UserService) enhancer.create();
        String userNameById = userService.findUserNameById(1);
        System.out.println(userNameById);
    }
}
</code></pre>
<p>其实有很大一部分是在 <code>Enhancer</code>这个类初始化的时候, 进行的.  所以我们不研究初始化做了什么, 无非就是初始化类加载器和缓存呗.</p>
<p>第一步进去 , 我们直接进入<code>Enhancer#createHelper</code> 中 .</p>
<pre><code class="language-java">private Object createHelper() {
    preValidate();
    Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
            ReflectUtils.getNames(interfaces),
            filter == ALL_ZERO ? null : new WeakCacheKey&lt;CallbackFilter&gt;(filter),
            callbackTypes,
            useFactory,
            interceptDuringConstruction,
            serialVersionUID);
    this.currentKey = key;
    Object result = super.create(key);
    return result;
}
</code></pre>
<p>再往下面走 <code>AbstractClassGenerator#create</code></p>
<pre><code class="language-java">protected Object create(Object key) {
    try {
        //这里会去调用生成类, 其实我们的类,在这个方法返回的时候就创建好了,有兴趣可以看看源码.
        Object obj = data.get(this, getUseCache());
        // 这里呢累死与一个递归的过程. 第一次初始化,会调用这里
        if (obj instanceof Class) {
            return firstInstance((Class) obj);
        }
        // 一般初始化完成就是直接走这里. 
        return nextInstance(obj);
    } catch (e) {
       // 异常.处理.
    }
}
</code></pre>
<p>具体逻辑就是这个 . 就是靠字节码生成器生成就好了. 逻辑很麻烦的.  . 不做解释.</p>
<pre><code class="language-java">Function&lt;AbstractClassGenerator, Object&gt; load =
        new Function&lt;AbstractClassGenerator, Object&gt;() {
            public Object apply(AbstractClassGenerator gen) {
                // AbstractClassGenerator 生成一个 class.
                Class klass = gen.generate(ClassLoaderData.this);
                // 返回.
                return gen.wrapCachedClass(klass);
            }
        };
</code></pre>
<p>再往下面走 <code>Encher#nextInstance</code> 方法了</p>
<pre><code class="language-java">protected Object nextInstance(Object instance) {
    //这里还要涉及到`EnhancerFactoryData`
    EnhancerFactoryData data = (EnhancerFactoryData) instance;
    Class[] argumentTypes = this.argumentTypes;
    Object[] arguments = this.arguments;
    if (argumentTypes == null) {
        argumentTypes = Constants.EMPTY_CLASS_ARRAY;
        arguments = null;
    }
    // 这里初始化
    return data.newInstance(argumentTypes, arguments, callbacks);
}

</code></pre>
<p><code>EnhancerFactoryData</code> 这就是类信息吧, 也就是存着<code>Class</code>  , <code>Method</code>  , <code>Constructor</code>   , <code>primaryConstructorArgTypes</code> 构造器. 就是一个元信息吧.</p>
<pre><code class="language-java">static class EnhancerFactoryData {
    public final Class generatedClass;
    private final Method setThreadCallbacks;
    private final Class[] primaryConstructorArgTypes;
    private final Constructor primaryConstructor;
}    
</code></pre>
<p>最后逻辑在</p>
<pre><code class="language-java">public Object newInstance(Class[] argumentTypes, Object[] arguments, Callback[] callbacks) {
    // 设置threadLocalBack,通过反射.
    setThreadCallbacks(callbacks);
    try {
        if (primaryConstructorArgTypes == argumentTypes ||
                Arrays.equals(primaryConstructorArgTypes, argumentTypes)) {
            // 反射生成一个代理对象. 
            return ReflectUtils.newInstance(primaryConstructor, arguments);
        }
        return ReflectUtils.newInstance(generatedClass, argumentTypes, arguments);
    } finally {
        // 清空对象.也就是释放内存了.
        setThreadCallbacks(null);
    }
}
</code></pre>
<p><code>setThreadCallbacks</code>   方法, 是依靠反射调用的.</p>
<pre><code class="language-java">private void setThreadCallbacks(Callback[] callbacks) {
    try {
        setThreadCallbacks.invoke(generatedClass, (Object) callbacks);
    } catch (IllegalAccessException e) {
        throw new CodeGenerationException(e);
    } catch (InvocationTargetException e) {
        throw new CodeGenerationException(e.getTargetException());
    }
}
</code></pre>
<p>他调用的是这个 , 就将<code>Callback</code> 放入到 ThreadLocal中.</p>
<pre><code class="language-java">// 这里就是... 一个静态方法.往 CGLIB$THREAD_CALLBACKS 这个ThreadLocal里放入CallBack.
public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
    CGLIB$THREAD_CALLBACKS.set(var0);
}
</code></pre>
<p>然后就是</p>
<pre><code class="language-java">ReflectUtils.newInstance(primaryConstructor, arguments)
</code></pre>
<p>这里也很简单</p>
<pre><code class="language-java">public static Object newInstance(final Constructor cstruct, final Object[] args) {
    boolean flag = cstruct.isAccessible();
    try {
        if (!flag) {
            cstruct.setAccessible(true);
        }
        // 这里调用了 newInstance . 
        Object result = cstruct.newInstance(args);
        return result;
    } catch ( e) {
        // 异常....
    } finally {
        if (!flag) {
            // 重置,属性.
            cstruct.setAccessible(flag);
        }
    }
}
</code></pre>
<p>然后就是调用了 构造方法</p>
<pre><code class="language-java">public UserService$$EnhancerByCGLIB$$896a9058() {
    CGLIB$BIND_CALLBACKS(this);
}
</code></pre>
<pre><code class="language-java">private static final void CGLIB$BIND_CALLBACKS(Object var0) {
    UserService$$EnhancerByCGLIB$$896a9058 var1 = (UserService$$EnhancerByCGLIB$$896a9058)var0;
    // 一开始绝对是var1.CGLIB$BOUND为false.
    if (!var1.CGLIB$BOUND) {
        // 然后设置成true.
        var1.CGLIB$BOUND = true;
        // 从ThreadLocal中拿出我们的callback.
        Object var10000 = CGLIB$THREAD_CALLBACKS.get();
        if (var10000 == null) {
            // 设置.
            var10000 = CGLIB$STATIC_CALLBACKS;
            if (var10000 == null) {
                return;
            }
        }
        // 创建一个新的.防止空指针.异常.
        var1.CGLIB$CALLBACK_0 = (Dispatcher)((Callback[])var10000)[0];
    }
}
</code></pre>
<p>APP的代码如下</p>
<pre><code class="language-java">public class App {
    public static void main(String[] args) {
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:/test&quot;);
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(UserService.class);
        enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; &quot;proxy&quot; + proxy.invokeSuper(obj, args1));
        UserService userService = (UserService) enhancer.create();
        String userNameById = userService.findUserNameById(1);
        System.out.println(userNameById);
    }
}
</code></pre>
<p>生成的代码如下 :</p>
<p>所以同时也实现了<code>Factory</code> 接口, 我们可以根绝结构的参数进行实例化对象 . 也是很方便的.</p>
<pre><code class="language-java">public class UserService$$EnhancerByCGLIB$$74d5b933 extends UserService implements Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0;
    private static Object CGLIB$CALLBACK_FILTER;
    private static final Method CGLIB$findUserNameById$0$Method;
    private static final MethodProxy CGLIB$findUserNameById$0$Proxy;
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$equals$1$Method;
    private static final MethodProxy CGLIB$equals$1$Proxy;
    private static final Method CGLIB$toString$2$Method;
    private static final MethodProxy CGLIB$toString$2$Proxy;
    private static final Method CGLIB$hashCode$3$Method;
    private static final MethodProxy CGLIB$hashCode$3$Proxy;
    private static final Method CGLIB$clone$4$Method;
    private static final MethodProxy CGLIB$clone$4$Proxy;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        Class var0 = Class.forName(&quot;com.example.aop.UserService$$EnhancerByCGLIB$$74d5b933&quot;);
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{&quot;equals&quot;, &quot;(Ljava/lang/Object;)Z&quot;, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;, &quot;hashCode&quot;, &quot;()I&quot;, &quot;clone&quot;, &quot;()Ljava/lang/Object;&quot;}, (var1 = Class.forName(&quot;java.lang.Object&quot;)).getDeclaredMethods());
        CGLIB$equals$1$Method = var10000[0];
        CGLIB$equals$1$Proxy = MethodProxy.create(var1, var0, &quot;(Ljava/lang/Object;)Z&quot;, &quot;equals&quot;, &quot;CGLIB$equals$1&quot;);
        CGLIB$toString$2$Method = var10000[1];
        CGLIB$toString$2$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/String;&quot;, &quot;toString&quot;, &quot;CGLIB$toString$2&quot;);
        CGLIB$hashCode$3$Method = var10000[2];
        CGLIB$hashCode$3$Proxy = MethodProxy.create(var1, var0, &quot;()I&quot;, &quot;hashCode&quot;, &quot;CGLIB$hashCode$3&quot;);
        CGLIB$clone$4$Method = var10000[3];
        CGLIB$clone$4$Proxy = MethodProxy.create(var1, var0, &quot;()Ljava/lang/Object;&quot;, &quot;clone&quot;, &quot;CGLIB$clone$4&quot;);
        CGLIB$findUserNameById$0$Method = ReflectUtils.findMethods(new String[]{&quot;findUserNameById&quot;, &quot;(I)Ljava/lang/String;&quot;}, (var1 = Class.forName(&quot;com.example.aop.UserService&quot;)).getDeclaredMethods())[0];
        CGLIB$findUserNameById$0$Proxy = MethodProxy.create(var1, var0, &quot;(I)Ljava/lang/String;&quot;, &quot;findUserNameById&quot;, &quot;CGLIB$findUserNameById$0&quot;);
    }

    final String CGLIB$findUserNameById$0(int var1) {
        return super.findUserNameById(var1);
    }

    // 主要看这里
    public final String findUserNameById(int var1) {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        // 调用了. 当前对象 , CGLIB$findUserNameById$0$Method方法 , 参数, CGLIB$findUserNameById$0$Proxy这个代理对象. 
        // 这里也就是为什么不能使用调用当前对象(this)的findUserNameById,因为他是个递归过程. 所以这就是原因.
        return var10000 != null ? (String)var10000.intercept(this, CGLIB$findUserNameById$0$Method, new Object[]{new Integer(var1)}, CGLIB$findUserNameById$0$Proxy) : super.findUserNameById(var1);
    }

    final boolean CGLIB$equals$1(Object var1) {
        return super.equals(var1);
    }

    public final boolean equals(Object var1) {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var2 = var10000.intercept(this, CGLIB$equals$1$Method, new Object[]{var1}, CGLIB$equals$1$Proxy);
            return var2 == null ? false : (Boolean)var2;
        } else {
            return super.equals(var1);
        }
    }

    final String CGLIB$toString$2() {
        return super.toString();
    }

    public final String toString() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$2$Method, CGLIB$emptyArgs, CGLIB$toString$2$Proxy) : super.toString();
    }

    final int CGLIB$hashCode$3() {
        return super.hashCode();
    }

    public final int hashCode() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var1 = var10000.intercept(this, CGLIB$hashCode$3$Method, CGLIB$emptyArgs, CGLIB$hashCode$3$Proxy);
            return var1 == null ? 0 : ((Number)var1).intValue();
        } else {
            return super.hashCode();
        }
    }

    final Object CGLIB$clone$4() throws CloneNotSupportedException {
        return super.clone();
    }

    protected final Object clone() throws CloneNotSupportedException {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (var10000 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? var10000.intercept(this, CGLIB$clone$4$Method, CGLIB$emptyArgs, CGLIB$clone$4$Proxy) : super.clone();
    }

    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {
        String var10000 = var0.toString();
        switch(var10000.hashCode()) {
        case -508378822:
            if (var10000.equals(&quot;clone()Ljava/lang/Object;&quot;)) {
                return CGLIB$clone$4$Proxy;
            }
            break;
        case 1012028561:
            if (var10000.equals(&quot;findUserNameById(I)Ljava/lang/String;&quot;)) {
                return CGLIB$findUserNameById$0$Proxy;
            }
            break;
        case 1826985398:
            if (var10000.equals(&quot;equals(Ljava/lang/Object;)Z&quot;)) {
                return CGLIB$equals$1$Proxy;
            }
            break;
        case 1913648695:
            if (var10000.equals(&quot;toString()Ljava/lang/String;&quot;)) {
                return CGLIB$toString$2$Proxy;
            }
            break;
        case 1984935277:
            if (var10000.equals(&quot;hashCode()I&quot;)) {
                return CGLIB$hashCode$3$Proxy;
            }
        }

        return null;
    }

    public UserService$$EnhancerByCGLIB$$74d5b933() {
        CGLIB$BIND_CALLBACKS(this);
    }

    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        UserService$$EnhancerByCGLIB$$74d5b933 var1 = (UserService$$EnhancerByCGLIB$$74d5b933)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (var10000 == null) {
                    return;
                }
            }

            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];
        }

    }

    public Object newInstance(Callback[] var1) {
        CGLIB$SET_THREAD_CALLBACKS(var1);
        UserService$$EnhancerByCGLIB$$74d5b933 var10000 = new UserService$$EnhancerByCGLIB$$74d5b933();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Callback var1) {
        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});
        UserService$$EnhancerByCGLIB$$74d5b933 var10000 = new UserService$$EnhancerByCGLIB$$74d5b933();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        CGLIB$SET_THREAD_CALLBACKS(var3);
        UserService$$EnhancerByCGLIB$$74d5b933 var10000 = new UserService$$EnhancerByCGLIB$$74d5b933;
        switch(var1.length) {
        case 0:
            var10000.&lt;init&gt;();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
            return var10000;
        default:
            throw new IllegalArgumentException(&quot;Constructor not found&quot;);
        }
    }

    public Callback getCallback(int var1) {
        CGLIB$BIND_CALLBACKS(this);
        MethodInterceptor var10000;
        switch(var1) {
        case 0:
            var10000 = this.CGLIB$CALLBACK_0;
            break;
        default:
            var10000 = null;
        }

        return var10000;
    }

    public void setCallback(int var1, Callback var2) {
        switch(var1) {
        case 0:
            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;
        default:
        }
    }

    public Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(this);
        return new Callback[]{this.CGLIB$CALLBACK_0};
    }

    public void setCallbacks(Callback[] var1) {
        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];
    }

    static {
        CGLIB$STATICHOOK1();
    }
}
</code></pre>
<h2 id="分析invoke-和-invokesuper-做了些啥">分析<code>invoke</code> 和 <code>invokeSuper</code> 做了些啥 ?</h2>
<p>我们再看看这个代码 <code>MethodProxy</code>是如何生成的. ?</p>
<pre><code class="language-java">CGLIB$findUserNameById$0$Proxy = MethodProxy.create(var1, var0, &quot;(I)Ljava/lang/String;&quot;, &quot;findUserNameById&quot;, &quot;CGLIB$findUserNameById$0&quot;);
</code></pre>
<p><code>findUserNameById</code> 就是一个重写父类的的方法.</p>
<p><code>CGLIB$findUserNameById$0</code> 的过程是直接调用父类方法.</p>
<pre><code class="language-java">final String CGLIB$findUserNameById$0(int var1) {
    return super.findUserNameById(var1);
}
</code></pre>
<p><code>var0</code> 是指的是未增强的类, 也就是默认是父类. (Object/父类/父类.... 看继承关系)</p>
<p><code>var1</code> 指的是增强的类 ,就时我们重写的子类.</p>
<pre><code class="language-java">public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
    MethodProxy proxy = new MethodProxy();
    proxy.sig1 = new Signature(name1, desc);
    proxy.sig2 = new Signature(name2, desc);
    proxy.createInfo = new CreateInfo(c1, c2);
    return proxy;
}
</code></pre>
<pre><code class="language-java">private static class CreateInfo
{
    // c1指的是父类/超类.
    Class c1;
    // C2指的是代理类.
    Class c2;
    NamingPolicy namingPolicy;
    GeneratorStrategy strategy;
    boolean attemptLoad;

    public CreateInfo(Class c1, Class c2)
    {
        this.c1 = c1;
        this.c2 = c2;
        AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();
        if (fromEnhancer != null) {
            namingPolicy = fromEnhancer.getNamingPolicy();
            strategy = fromEnhancer.getStrategy();
            attemptLoad = fromEnhancer.getAttemptLoad();
        }
    }
}
</code></pre>
<p>以上就是一个初始化过程  .  会在生成类信息的时候生成这些  <code>MethodProxy</code></p>
<p>第二步就是执行我们的调用的方法了.</p>
<p><code>invokeSuper</code> 操作如下. 会调用<code>init</code>方法.</p>
<pre><code class="language-java">public Object invokeSuper(Object obj, Object[] args) throws Throwable {
    try {
        init();
        FastClassInfo fci = fastClassInfo;
        // F2的话就指的是代理的类方法. 
        // F1是指的是父类.
        return fci.f2.invoke(fci.i2, obj, args);
    } catch (InvocationTargetException e) {
        throw e.getTargetException();
    }
}
</code></pre>
<p><code>init</code> 方法是一个双重监测锁的实现. 进行初始化过程.</p>
<pre><code class="language-java">private void init()
{
    // 就是一个双重监测锁. 初始化fastClassInfo.
    if (fastClassInfo == null)
    {
        synchronized (initLock)
        {
            if (fastClassInfo == null)
            {
                CreateInfo ci = createInfo;
                FastClassInfo fci = new FastClassInfo();
                // 初始化一些元信息.
                fci.f1 = helper(ci, ci.c1);
                fci.f2 = helper(ci, ci.c2);
                fci.i1 = fci.f1.getIndex(sig1);
                fci.i2 = fci.f2.getIndex(sig2);
                fastClassInfo = fci;
                createInfo = null;
            }
        }
    }
}
</code></pre>
<p>所以这里<code>invokeSuper</code>调用的是  :</p>
<pre><code class="language-java">fci.f2.invoke(fci.i2, obj, args);
// 代理的类对象. 调用的CGLIB$findUserNameById$0()方法. 
</code></pre>
<p>也就是</p>
<pre><code class="language-java">final String CGLIB$findUserNameById$0(int var1) {
    return super.findUserNameById(var1);
}
</code></pre>
<p><strong>当我们调用 <code>invoke</code> 的时候. 我们作为子类, 子类重写了父类的方法. 所以我们调用父类的方法的时候,会走我们重写的方法 , 会出现一个递归的问题.  就是这段代码.</strong></p>
<pre><code class="language-java">// 主要看这里
public final String findUserNameById(int var1) {
    MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    // 调用了. 当前对象 , CGLIB$findUserNameById$0$Method方法 , 参数, CGLIB$findUserNameById$0$Proxy这个代理对象. 
    // 这也是为啥不能使用invoke方法了.
    return var10000 != null ? (String)var10000.intercept(this, CGLIB$findUserNameById$0$Method, new Object[]{new Integer(var1)}, CGLIB$findUserNameById$0$Proxy) : super.findUserNameById(var1);
}
</code></pre>
<p>说到这里其实没玩呢. 为啥呢, 因为<code>FastClass</code> 是一个抽象类, 那么我们还要重写一些方法. 我们去点击. <code>abstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException;</code>  这个方法是一个抽象方法, 显然不成立</p>
<p>怎么办呢.  显然是生成了一个. 哈哈哈哈.  正常情况下啊 , 会生成三个类. 核心的类上面写的就是 <code>UserService$$EnhancerByCGLIB$$74d5b933</code></p>
<figure data-type="image" tabindex="1"><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020-30-33/eac8b038-1910-4000-8cba-721b4efe8cfe.png?x-oss-process=style/template01" alt="" loading="lazy"></figure>
<p>下面真正调用的时候, 使用的是 <code>UserService$$EnhancerByCGLIB$$74d5b933$$FastClassByCGLIB$$406726de</code> 这个.  他呢继承了<code>FastClass</code> , 所以就直接走的它.</p>
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//

package com.example.aop;

import com.example.aop.UserService..EnhancerByCGLIB..74d5b933;
import java.lang.reflect.InvocationTargetException;
import net.sf.cglib.core.Signature;
import net.sf.cglib.proxy.Callback;
import net.sf.cglib.reflect.FastClass;

public class UserService$$EnhancerByCGLIB$$74d5b933$$FastClassByCGLIB$$406726de extends FastClass {

        // 这个就是invoke的重载方法. 
   public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        74d5b933 var10000 = (74d5b933)var2;
        int var10001 = var1;
       // 反正吧, 就是找到对应的方法直接调用,根据坐标, 这个坐标是生成这个类的时候生成的, 不是固定不变的.
        try {
            switch(var10001) {
            case 0:
                return new Boolean(var10000.equals(var3[0]));
            case 1:
                return var10000.toString();
            case 2:
                return new Integer(var10000.hashCode());
            case 3:
                return var10000.clone();
            case 4:
                return var10000.newInstance((Callback[])var3[0]);
            case 5:
                return var10000.newInstance((Callback)var3[0]);
            case 6:
                return var10000.newInstance((Class[])var3[0], (Object[])var3[1], (Callback[])var3[2]);
            case 7:
                74d5b933.CGLIB$SET_THREAD_CALLBACKS((Callback[])var3[0]);
                return null;
            case 8:
                74d5b933.CGLIB$SET_STATIC_CALLBACKS((Callback[])var3[0]);
                return null;
            case 9:
                var10000.setCallback(((Number)var3[0]).intValue(), (Callback)var3[1]);
                return null;
            case 10:
                var10000.setCallbacks((Callback[])var3[0]);
                return null;
            case 11:
                return var10000.getCallback(((Number)var3[0]).intValue());
            case 12:
                return var10000.getCallbacks();
            case 13:
                return var10000.CGLIB$clone$4();
            case 14:
                return new Integer(var10000.CGLIB$hashCode$3());
            case 15:
                return new Boolean(var10000.CGLIB$equals$1(var3[0]));
            case 16:
                return var10000.CGLIB$toString$2();
            case 17:
                return 74d5b933.CGLIB$findMethodProxy((Signature)var3[0]);
            case 18:
                return var10000.findUserNameById(((Number)var3[0]).intValue());
            case 19:
                74d5b933.CGLIB$STATICHOOK1();
                return null;
			// 下面是一个var1 , 指的是索引坐标(index). 找到后直接用对象去调用,所以没有使用反射机制.而是硬编码的方式.
            case 20:
                return var10000.CGLIB$findUserNameById$0(((Number)var3[0]).intValue());
            }
        } catch (Throwable var4) {
            throw new InvocationTargetException(var4);
        }

        throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);
    }    
}
</code></pre>
<p>那么还有一个类, 是干啥的呢, 显然当然有用, 那就是 当我们调用, <code>proxy.invoke(obj, args1)</code>  就走的另外一个. <code>UserService$$FastClassByCGLIB$$417646d</code>  这个没有写增强, 顾名思义, 也就是父类的FastClass.  是吧. 所以他会调用 <code>var10000.findUserNameById(((Number)var3[0]).intValue());</code>  , 然后呢, 就递归卡死了. 懂了吧.</p>
<p>所以这里就是这个意思  , 他的流程和上面死一样的.</p>
<pre><code class="language-java">public class UserService$$FastClassByCGLIB$$417646d extends FastClass {
    // 省略一堆代码. 
    
    // 下面就是一个调用流程. 跟上诉一样. 
    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        UserService var10000 = (UserService)var2;
        int var10001 = var1;
        try {
            switch(var10001) {
            case 0:
                return var10000.findUserNameById(((Number)var3[0]).intValue());
            case 1:
                return new Boolean(var10000.equals(var3[0]));
            case 2:
                return var10000.toString();
            case 3:
                return new Integer(var10000.hashCode());
            }
        } catch (Throwable var4) {
            throw new InvocationTargetException(var4);
        }

        throw new IllegalArgumentException(&quot;Cannot find matching method/constructor&quot;);
    }
}
</code></pre>
<h2 id="cglib的核心">CGLIB的核心</h2>
<h3 id="enhancer"><code>Enhancer</code></h3>
<p>这个就是增强器. 我们的一个生成代码的工具类 ,</p>
<h3 id="classgenerator"><code>ClassGenerator</code></h3>
<p>这个是生成代码的类, 也就是生成字节码</p>
<h3 id="methodproxy"><code>MethodProxy</code></h3>
<p>拦截器的实现方式, 就时通过这个, 他会生成两个代理类,  继承了 <code>FastClass</code> , 所以就是快的字节码.  因为直接调用未使用反射, 但是多生成两个类  , 会占用内存的.</p>
<h3 id="callback"><code>Callback</code></h3>
<blockquote>
<p>​	这个讲过了, 也就是定义一些我们的业务逻辑.</p>
</blockquote>
<h3 id="callbackfilter"><code>CallbackFilter</code></h3>
<p>这个就是一个 过滤器.  对应着 <code>Callback</code></p>
<p>缺点就是, 我们上面说的, 占用内存, 没了. 因为Java的代理 , 也就生成一个类, 而这个代理会生成一个代理类和两个辅助类.</p>

								<span id="footnote"></span>
								<div id="warn"></div>
							</div>
							<div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8">快速使用</a></li>
<li><a href="#cglib%E5%8A%9F%E8%83%BD%E6%A0%B8%E5%BF%83-callback">CGLIB功能核心 - <code>CallBack</code></a>
<ul>
<li><a href="#methodinterceptor"><code>MethodInterceptor</code></a></li>
<li><a href="#noop"><code>NoOp</code></a></li>
<li><a href="#lazyloader"><code>LazyLoader</code></a></li>
<li><a href="#dispatcher"><code>Dispatcher</code></a></li>
<li><a href="#invocationhandler"><code>InvocationHandler</code></a></li>
<li><a href="#fixedvalue"><code>FixedValue</code></a></li>
</ul>
</li>
<li><a href="#%E5%95%A5%E6%97%B6%E5%80%99%E7%94%A8-callbackfilter">啥时候用 <code>CallbackFilter</code></a></li>
<li><a href="#encher%E4%BB%A3%E7%90%86%E7%9A%84%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">Encher代理的原理(源码分析)</a></li>
<li><a href="#%E5%88%86%E6%9E%90invoke-%E5%92%8C-invokesuper-%E5%81%9A%E4%BA%86%E4%BA%9B%E5%95%A5">分析<code>invoke</code> 和 <code>invokeSuper</code> 做了些啥 ?</a></li>
<li><a href="#cglib%E7%9A%84%E6%A0%B8%E5%BF%83">CGLIB的核心</a>
<ul>
<li><a href="#enhancer"><code>Enhancer</code></a></li>
<li><a href="#classgenerator"><code>ClassGenerator</code></a></li>
<li><a href="#methodproxy"><code>MethodProxy</code></a></li>
<li><a href="#callback"><code>Callback</code></a></li>
<li><a href="#callbackfilter"><code>CallbackFilter</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
						</div>
						<div id="fullPage"><canvas id="canvas"></canvas></div>
				</article>
				<div id="eof"><span>EOF</span></div>
				<div class="round-shape-one"></div>
				<section>
					<div class="doc_comments">
							<div id="valine-container"></div>
					</div>
				</section>
			</div>
		</div>
	</div>
	<script>
		"use strict";
		! function () {
			for (var n = document.getElementsByTagName("pre"), e = n.length, s = 0; s < e; s++) {
				n[s].innerHTML = '<span class="line-number"></span>' + n[s].innerHTML + '<span class="cl"></span>';
				for (var a = n[s].innerHTML.split(/\n/).length, r = 0; r < a - 1; r++) {
					n[s].getElementsByTagName("span")[0].innerHTML += "<span>" + (r + 1) + "</span>"
				}
			}
		}();
		let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");
		window.addEventListener("scroll", event => {
			let fromTop = window.scrollY;
			mainNavLinks.forEach((link, index) => {
				let section = document.getElementById(decodeURI(link.hash).substring(1));
				let nextSection = null
				if (mainNavLinks[index + 1]) {
					nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(
						1));
				}
				if (section.offsetTop <= fromTop) {
					if (nextSection) {
						if (nextSection.offsetTop > fromTop) {
							link.classList.add("currentToc");
						} else {
							link.classList.remove("currentToc");
						}
					} else {
						link.classList.add("currentToc");
					}
				} else {
					link.classList.remove("currentToc");
				}
			});
		});
		var list = document.querySelectorAll(".katex");
		for (var i = 0; i < list.length; i++) {
			list[i].style.display = "unset"
		};
		var h = document.documentElement,
			b = document.body,
			st = "scrollTop",
			sh = "scrollHeight",
			progress = document.querySelector(".progress"),
			scroll;
		document.addEventListener("scroll", function () {
			scroll = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
			progress.style.setProperty("--scroll", scroll + "%")
		});
		var wxScale = new WxScale({
			fullPage: document.querySelector("#fullPage"),
			canvas: document.querySelector("#canvas")
		});
		var imgBox = document.querySelectorAll("#md_block img");
		for (var i = 0; i < imgBox.length; i++) {
			imgBox[i].onclick = function (e) {
				wxScale.start(this)
			}
		};
	</script>
	<style>
		#magnifyImg {
			position: fixed;
			left: 0;
			top: 0;
			text-align: center;
			width: 100%;
			display: none;
			z-index: 9999
		}

		#magnifyImg img {
			object-fit: contain;
			background: #eaecef;
			padding: 15px;
			border-radius: 10px;
			height: auto;
			width: auto;
			vertical-align: middle
		}
	</style>
	<a id="scrollUp"href="#top"style="position: fixed; z-index: 2147483647; display: block;"></a><div class="footer animated fadeInDown"><div class="site_footer"><div class="mysocials"><div class="my_socials"><a href="https://github.com/Anthony-Dong"title="github"><i class="iconfont icon-github"></i></a><a href="fanhaodong516@gmail.com"title="envelope"><i class="iconfont icon-envelope"></i></a></div></div><div class="copyright"id="copyright">You Are My Everything. <a href="mailto:574986060@qq.com" target="blank">Send Email</a>Copyright©2018-2020<a href="https://anthony-dong.github.io"style="margin:0;">Serence</a>.</div><span style="display: inline;margin-right:15px;">👁<strong><span id="count-page">168271</span></strong></span><span id="busuanzi_container_page_pv"style="display: inline;"><span>📚<strong>186</strong>posts</span></div></div><script>console.log("\n %c \u26a1Anthony-Dong's Blog:https://anthony-dong.gitee.io ,Github:https://github.com/Anthony-Dong ,Email:574986060@qq.com ,有事情欢迎联系. \n\n","color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;",);</script>
	<script type="text/javascript" async src="https://anthony-dong.github.io/media/js/prism.js"></script>
</body>
</html>
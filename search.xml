<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker</title>
    <url>/2021/02/28/docker/</url>
    <content><![CDATA[<blockquote>
<p>Docker 基础学习</p>
</blockquote>
<span id="more"></span>

<p>官方文章：<a href="https://docs.docker.com/">https://docs.docker.com/</a></p>
<p>docker 官方镜像地址： <a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>推荐阅读丛书 ： <a href="https://item.jd.com/12013041.html"><strong>Docker实战(博文视点出品)</strong></a> ， <a href="https://item.jd.com/11909234.html"><strong>第一本Docker书 修订版</strong></a></p>
<p>docker 快速安装： <code>curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun</code> , 记得用户设置在docker用户组！，推荐在非mac os/windows上玩。</p>
<h2 id="1、docker-的组成"><a href="#1、docker-的组成" class="headerlink" title="1、docker 的组成"></a>1、docker 的组成</h2><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/f26bd07bcd6341d88055e81cf95db8a5.jpg" alt="docker引擎docker引擎"></p>
<h3 id="1、runc"><a href="#1、runc" class="headerlink" title="1、runc"></a>1、runc</h3><p>runc实质上是一个轻量级的、针对Libcontainer进行了包装的<a href="https://www.linuxcool.com/">命令</a>行交互工具( Libcontainer取代了早期Docker架构中的LXC )。</p>
<p>使用很简单，它是运行一个容器最基本的工具，所以我们需要创建容器。</p>
<p>docker中创建容器是，<code>docker create docker-image-name </code>，但是需要导出到文件系统中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> create the top most bundle directory</span></span><br><span class="line">mkdir /mycontainer</span><br><span class="line">cd /mycontainer</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> create the rootfs directory</span></span><br><span class="line">mkdir rootfs</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">export</span> busybox via Docker into the rootfs directory</span></span><br><span class="line">docker export $(docker create busybox) | tar -C rootfs -xvf -</span><br><span class="line"></span><br><span class="line">runc spec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> run as root</span></span><br><span class="line">cd /mycontainer</span><br><span class="line">runc run mycontainerid</span><br></pre></td></tr></table></figure>

<h3 id="2、containerd"><a href="#2、containerd" class="headerlink" title="2、containerd"></a>2、containerd</h3><p>对于docker进行拆分后，容器执行逻辑被重构到一个新的名为containerd (发音为container-dee) 的工具中。它的主要任务是容器的生命周期管理———— start | stop | pause | rm….</p>
<p>Docker引擎技术栈中，containerd位于daemon和runc所在的OCI层之间。随着时间的推移，它被赋予了更多的功能，如镜像管理。虽然名叫containerd, 但是它并不负责创建容器，而是指挥runc去做。containerd将Docker镜像转换为OCI bundle,并让runc基于此创建一个新的容器。然后，runc与操作系统内核接口进行通信，基于所有必要的工具( Namespace、CGroup 等)来创建容器。容器进程作为runc的子进程启动，启动完毕后，runc 将会退出。</p>
<p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/6150a3fe711347fe892e355e36b6f364.jpg" alt="docker引擎docker引擎"></p>
<p>​      将所有的用于启动、管理容器的逻辑和代码从daemon中移除，意味着容器运行时与Docker daemon是解耦的，有时称之为“无守护进程的容器(daemonless container)”,如此，对Docker daemon的维护和升级工作不会影响到运行中的容器。</p>
<h3 id="3、shim"><a href="#3、shim" class="headerlink" title="3、shim"></a>3、shim</h3><p>shim是实现无daemon的容器(用于将运行中的容器与daemon解耦，以便进行daemon升级等操作)不可或缺的工具。containerd 指挥runc来创建新容器。事实上,每次创建容器时它都会fork一个新的runc实例。不过，一旦容器创建完毕，对应的runc进程就会退出。因此，即使运行上百个容器，也无须保持上百个运行中的runc实例。一旦容器进程的父进程runc退出，相关联的containerd-shim 进程就会成为容器的父进程。</p>
<p>作为容器的父进程，shim 的部分职责如下。</p>
<ul>
<li>保持所有STDIN和STDOUT流是开启状态，从而当daemon重启的时候,容器不会因为管道( pipe)的关闭而终止。</li>
<li>将容器的退出状态反馈给daemon。</li>
</ul>
<h3 id="4、daemon"><a href="#4、daemon" class="headerlink" title="4、daemon"></a>4、daemon</h3><p>daemon的主要功能包括镜像管理、镜像构建、REST API、身份验证、安全、核心网络以及编排。</p>
<h2 id="2、Dockerfile-学习"><a href="#2、Dockerfile-学习" class="headerlink" title="2、Dockerfile 学习"></a>2、Dockerfile 学习</h2><blockquote>
<p>​    官方文档： <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
</blockquote>
<h3 id="1、dockerfile-文件，基本玩法"><a href="#1、dockerfile-文件，基本玩法" class="headerlink" title="1、dockerfile 文件，基本玩法"></a>1、dockerfile 文件，基本玩法</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest <span class="comment"># 引用的镜像，一般去docker hub 搜索 ，一个dockerfile文件必须以一个FROM开始</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> anthony-dong <span class="string">&quot;fanhaodong516@gamil.com&quot;</span> <span class="comment"># 作者的name，作者的 addr，一般不用申明！！</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /opt/<span class="built_in">test</span>/ <span class="comment"># run 就是执行构建的时候执行的命令，这个可以执行多个一次，切记 RUN 执行后相当于新建了一个镜像，所以不推荐多次run，推荐&amp;&amp;连接。</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> a.txt /data/<span class="built_in">test</span>/ <span class="comment"># 将文件copy到镜像内且解压(如果是tar包)</span></span></span><br><span class="line"><span class="keyword">ENV</span> TEST_HOME /opt/test/ <span class="comment"># 暴漏环境变量 ENV key value 这种格式！！</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$TEST_HOME <span class="comment"># 设置到path环境变量</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;echo&quot;</span>,<span class="string">&quot;a.txt&quot;</span>] <span class="comment"># 执行docker run 默认执行的命令</span></span></span><br></pre></td></tr></table></figure>

<p>比如run可以这么写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get install -y curl \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>



<h3 id="2、CMD-和-ENTRYPOINT-的区别"><a href="#2、CMD-和-ENTRYPOINT-的区别" class="headerlink" title="2、CMD 和 ENTRYPOINT 的区别"></a>2、<code>CMD</code> 和 <code>ENTRYPOINT</code> 的区别</h3><ul>
<li><code>CMD</code> 和 <code>ENTRYPOINT</code> 的区别，这里其实区别很简单， 可以理解为 在没有启动命令是 <code>ENTRYPOINT</code>+ <code>CMD</code> （启动<code>docker run</code>时运行的默认命令）</li>
<li>当我们 <code>docker run image_name [cmd1] [cmd2]</code> 时，其实已经把 Dokerfile中配置的<code>CMD</code>命令替换掉了，其实真正执行的是  <code>ENTRYPOINT</code>+<code> [cmd1]</code>+<code> [cmd2]</code>  ， 但是这俩<code>CMD</code> 和 <code>ENTRYPOINT</code>  都可以为空</li>
<li>根据上面可以发现 <code>CMD</code>可以通过 <code>docker run</code>可以替换，那么 <code>ENTRYPOINT</code> 也是可以替换的，可以通过 <code>-entrypoint</code> 指定</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">ENTRYPOINT [ <span class="string">&quot;ls&quot;</span>]</span><br><span class="line">CMD [<span class="string">&quot;-al&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>比如上面找个，我们如果默认执行的话，会是：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes docker run --rm demo                 </span><br><span class="line">total 64</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Jan 26 12:50 .</span><br><span class="line">// ...</span><br><span class="line">drwxr-xr-x    2 root     root          4096 Jan 14 11:49 opt</span><br><span class="line">dr-xr-xr-x  226 root     root             0 Jan 26 12:50 proc</span><br></pre></td></tr></table></figure>

<p>但是如果我们添加了参数：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  kubernetes docker run --rm demo -a</span><br><span class="line">..</span><br><span class="line">.dockerenv</span><br><span class="line">bin</span><br><span class="line">//.... </span><br><span class="line">home</span><br></pre></td></tr></table></figure>

<p>修改 <code>ENTRYPOINT</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">➜  kubernetes docker run --rm --entrypoint env demo</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=<span class="number">4791</span>b485ab53</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure>

<h3 id="3、AND-和-COPY的区别"><a href="#3、AND-和-COPY的区别" class="headerlink" title="3、AND 和 COPY的区别"></a>3、<code>AND</code> 和 <code>COPY</code>的区别</h3><p>首先我们创建一个tar包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test mkdir test</span><br><span class="line">➜  test cd test</span><br><span class="line">➜  test touch a.txt</span><br><span class="line">➜  test touch b.txt</span><br><span class="line">➜  test cd ..</span><br><span class="line">➜  test ls</span><br><span class="line">Dockerfile test</span><br><span class="line">➜  test tar -cf test.tar test</span><br><span class="line">➜  test ls</span><br><span class="line">Dockerfile test       test.tar</span><br></pre></td></tr></table></figure>

<p>其次 dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.tar /opt</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;ls -al /opt/test&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用的<code>ADD</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test docker build --tag demo1 --file ./Dockerfile .</span><br><span class="line"></span><br><span class="line">➜  test docker run --rm demo1</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x    2 501      dialout       4096 Sep 19 05:13 .</span><br><span class="line">drwxr-xr-x    1 root     root          4096 Sep 19 05:16 ..</span><br><span class="line">-rw-r--r--    1 501      dialout          0 Sep 19 05:13 a.txt</span><br><span class="line">-rw-r--r--    1 501      dialout          0 Sep 19 05:13 b.txt</span><br></pre></td></tr></table></figure>

<p>所以可以看到成功解压了！！</p>
<p>那我们换<code>COPY</code> 命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">COPY test.tar /opt</span><br><span class="line">CMD [ &quot;sh&quot;,&quot;-c&quot;,&quot;ls -al /opt/test&quot;]</span><br></pre></td></tr></table></figure>

<p>继续执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test docker rmi demo1</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">➜  test docker build --tag demo1 --file ./Dockerfile .</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line">➜  test docker run --rm demo1</span><br><span class="line">ls: /opt/test: No such file or directory</span><br></pre></td></tr></table></figure>

<p>所以发现，并不会解压，导致没有发现文件和文件夹</p>
<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">WORKDIR /opt</span><br><span class="line">CMD [ &quot;/bin/sh&quot; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker run --rm -it  test-1</span><br><span class="line">/opt #</span><br></pre></td></tr></table></figure>

<h3 id="4、build-失败如何继续，如何调试！！"><a href="#4、build-失败如何继续，如何调试！！" class="headerlink" title="4、build 失败如何继续，如何调试！！"></a>4、build 失败如何继续，如何调试！！</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:centos7</span><br><span class="line"><span class="keyword">USER</span> admin:admin</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;/bin/bash&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>这个build是可以通过的！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker build -t test-1 .</span><br><span class="line">Sending build context to Docker daemon  25.09kB</span><br><span class="line">Step 1/3 : FROM centos:centos7</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7e6257c9f8d8</span></span><br><span class="line">Step 2/3 : USER admin:admin</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> f8ed46bdda32</span></span><br><span class="line">Removing intermediate container f8ed46bdda32</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 9611a153742e</span></span><br><span class="line">Step 3/3 : CMD [ &quot;/bin/bash&quot; ]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> abc32bd8e245</span></span><br><span class="line">Removing intermediate container abc32bd8e245</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 0f0f0aeeec29</span></span><br><span class="line">Successfully built 0f0f0aeeec29</span><br><span class="line">Successfully tagged test-1:latest</span><br></pre></td></tr></table></figure>

<p>然后运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker run --rm -it test-1</span><br><span class="line">docker: Error response from daemon: linux spec user: unable to find user admin: no matching entries in passwd file.</span><br></pre></td></tr></table></figure>

<p>发现这个，我们需要从<code>Step 1/3</code>开始！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker run --rm -it  7e6257c9f8d8</span><br><span class="line">[root@532c8a693273 /]# useradd admin -p admin -d /home/admin --create-home -s /bin/bash</span><br><span class="line">[root@532c8a693273 /]# su admin</span><br><span class="line">[admin@532c8a693273 /]$ exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>然后我们需要继续改dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM centos:centos7</span><br><span class="line">RUN useradd admin -p admin -d /home/admin --create-home -s /bin/bash</span><br><span class="line">USER admin:admin</span><br><span class="line">CMD [ &quot;/bin/bash&quot; ]</span><br></pre></td></tr></table></figure>

<p>继续运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker build -t test-1 .</span><br><span class="line">Sending build context to Docker daemon  25.09kB</span><br><span class="line">Step 1/4 : FROM centos:centos7</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 7e6257c9f8d8</span></span><br><span class="line">Step 2/4 : RUN useradd admin -p admin -d /home/admin --create-home -s /bin/bash</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> f36f10b603bd</span></span><br><span class="line">Removing intermediate container f36f10b603bd</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 843554e160f7</span></span><br><span class="line">Step 3/4 : USER admin:admin</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 796341a1be27</span></span><br><span class="line">Removing intermediate container 796341a1be27</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> ab964ed78d8f</span></span><br><span class="line">Step 4/4 : CMD [ &quot;/bin/bash&quot; ]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 2c67de0242ea</span></span><br><span class="line">Removing intermediate container 2c67de0242ea</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 17a4bc8d7206</span></span><br><span class="line">Successfully built 17a4bc8d7206</span><br><span class="line">Successfully tagged test-1:latest</span><br><span class="line">➜  docker-file-test docker run --rm -it 17a4bc8d7206</span><br><span class="line">[admin@55f84f22acf6 /]$</span><br></pre></td></tr></table></figure>

<p>这个就是一个简单的过程！！！！！！，这个好处是类似于<code>调试的过程</code></p>
<p>其实还可以通过 <code>docker run -u</code> 来制定用户，切记一点，别记忆命令！！，要记忆如何学习！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker run -it --rm --user root test-1</span><br><span class="line">[root@6dbeb01f5329 /]#</span><br></pre></td></tr></table></figure>

<h3 id="5、安装一个Go的环境"><a href="#5、安装一个Go的环境" class="headerlink" title="5、安装一个Go的环境"></a>5、安装一个Go的环境</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:centos7</span><br><span class="line"><span class="keyword">MAINTAINER</span> anthony-dong <span class="string">&quot;fanhaodong516@gamil.com&quot;</span></span><br><span class="line"><span class="comment"># 添加文件地址</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> go1.13.15.linux-amd64.tar.gz /opt</span></span><br><span class="line"><span class="comment"># 项目地址文件,安装工具</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /opt/project \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install -y vim \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install  -y curl \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install  -y git \</span></span><br><span class="line"><span class="bash">    &amp;&amp; yum install  -y wget</span></span><br><span class="line"><span class="comment"># 环境变量    </span></span><br><span class="line"><span class="keyword">ENV</span> GO_HOME <span class="string">&quot;/opt/go&quot;</span></span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$GO_HOME/bin</span><br><span class="line"><span class="comment"># export端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span> </span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">10010</span> </span><br><span class="line"><span class="comment"># 直接启动bash</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;/bin/bash&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>然后执行， <code>--tag</code> 可以写成<code>-t</code> ，比如<code>--tag go:1.13</code> 意思就是镜像名称是<code>go</code>，版本是<code>1.13</code>，大致就是这个样子！ </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build --file ./Dockerfile -p  --tag goenv1.13 .</span><br></pre></td></tr></table></figure>

<p>最后启动需要指定<code>-t</code> ，意思就是 <code>--rm</code>是容器被停止则被删除，<code>-d</code>是deamon启动， <code>-it</code>就是hold住类似于开启一个终端（i是输出，t是终端，然后程序就被hold住了）， <code>-P</code>暴漏端口随机到宿主机上， 最后指定使用的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --rm -d -it -P goenv1.13</span><br></pre></td></tr></table></figure>

<p>然后查看一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  test docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                                               NAMES</span><br><span class="line">f67a0f2bcb0e        goenv1.13           &quot;/bin/bash&quot;         21 seconds ago      Up 19 seconds       0.0.0.0:32769-&gt;8080/tcp, 0.0.0.0:32768-&gt;10010/tcp   heuristic_lumiere</span><br></pre></td></tr></table></figure>



<h3 id="6、多阶段构建"><a href="#6、多阶段构建" class="headerlink" title="6、多阶段构建"></a>6、多阶段构建</h3><blockquote>
<p>​    Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)， 参考：<a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">https://yeasy.gitbook.io/docker_practice/image/multistage-builds</a>  , 主要命令就是 <code>COPY --from=builder /data/apps/project/bin/app bin/</code></p>
</blockquote>
<p>还是一个Go项目，假如以一个Http-Server 为例子</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  pck tree -L 2</span><br><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── cmd</span><br><span class="line">│   └── main.go</span><br><span class="line">├── go.mod</span><br><span class="line">└── go.sum</span><br></pre></td></tr></table></figure>

<p>项目文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	router := gin.Default()</span><br><span class="line">	router.GET(&quot;/echo&quot;, func(context *gin.Context) &#123;</span><br><span class="line">		context.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			&quot;code&quot;:    0,</span><br><span class="line">			&quot;data&quot;:    &quot;hello world&quot;,</span><br><span class="line">			&quot;message&quot;: &quot;success&quot;,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">	log.Fatal(router.Run(&quot;:8080&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dockerfile</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.11+ 默认自动支持Go mod,切记builder的编译和运行的编译内核一致</span></span><br><span class="line">FROM  golang:1.13.15-alpine3.12 as builder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 全局变量，项目名称</span></span><br><span class="line">ARG GOPROXY=https://goproxy.cn,direct</span><br><span class="line">ENV GOPROXY=$&#123;GOPROXY&#125;</span><br><span class="line">WORKDIR /data</span><br><span class="line">COPY . .</span><br><span class="line">RUN go build -v -ldflags &quot;-s -w&quot; -o bin/app cmd/main.go</span><br><span class="line"></span><br><span class="line">FROM alpine:3.12 as runing</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切记环境变量不能共享</span></span><br><span class="line">ARG PROJECT_NAME=project</span><br><span class="line">ARG PROJECT_PORT=8080</span><br><span class="line"></span><br><span class="line">WORKDIR /data/$&#123;PROJECT_NAME&#125;</span><br><span class="line">COPY . .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 含义是 copy上一个镜像的 /data/<span class="variable">$&#123;PROJECT_NAME&#125;</span>/bin/app 文件到当前目录的bin</span></span><br><span class="line">COPY --from=builder /data/bin/app bin/</span><br><span class="line"><span class="meta">#</span><span class="bash"> COPY --from=0 /opt/bin/app .</span></span><br><span class="line">EXPOSE $&#123;PROJECT_PORT&#125;</span><br><span class="line">CMD [ &quot;bin/app&quot; ]</span><br></pre></td></tr></table></figure>

<p>编译 ：(注意 alpine是不支持 race 的，会编译报错）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build -t test .</span><br></pre></td></tr></table></figure>

<p>启动:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  my-docker docker run --rm -p 8080:8080 test  </span><br><span class="line">[GIN-debug] [WARNING] Creating an Engine instance with the Logger and Recovery middleware already attached.</span><br><span class="line"></span><br><span class="line">[GIN-debug] [WARNING] Running in &quot;debug&quot; mode. Switch to &quot;release&quot; mode in production.</span><br><span class="line"> - using env:   export GIN_MODE=release</span><br><span class="line"> - using code:  gin.SetMode(gin.ReleaseMode)</span><br><span class="line"></span><br><span class="line">[GIN-debug] GET    /echo                     --&gt; main.main.func1 (3 handlers)</span><br><span class="line">[GIN-debug] Listening and serving HTTP on :8080</span><br></pre></td></tr></table></figure>

<p>查看大小：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  my-docker docker images</span><br><span class="line">REPOSITORY              TAG                  IMAGE ID            CREATED             SIZE</span><br><span class="line">test                    latest               fdbca700806f        8 minutes ago       17.8MB</span><br><span class="line">alpine                  latest               7731472c3f2a        6 days ago          5.61MB</span><br></pre></td></tr></table></figure>

<p>其实真实的Go的构建不是这种，一般都有打包机器，无须我们去找机器编译和运行</p>
<h3 id="7、构建多种系统架构支持的-Docker-镜像"><a href="#7、构建多种系统架构支持的-Docker-镜像" class="headerlink" title="7、构建多种系统架构支持的 Docker 镜像"></a>7、构建多种系统架构支持的 Docker 镜像</h3><p><a href="https://yeasy.gitbook.io/docker_practice/image/manifest">https://yeasy.gitbook.io/docker_practice/image/manifest</a></p>
<h2 id="3、Docker-限制资源"><a href="#3、Docker-限制资源" class="headerlink" title="3、Docker 限制资源"></a>3、Docker 限制资源</h2><p>压测程序,不准确，因为数组扩容，是十分消耗内存的，如果内存满了，无法申请内存，那么就不会打印消息！可以使用stress工具来测试CPU和内存。这里我也懒得下载！！</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ref []<span class="keyword">byte</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(os.Getpid())</span><br><span class="line">	mem, _ := strconv.ParseInt(os.Args[<span class="number">1</span>], <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> mem == <span class="number">0</span> &#123;</span><br><span class="line">			mem = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		size := <span class="number">1024</span> * <span class="number">1024</span> * mem</span><br><span class="line">		newSlice(size)</span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newSlice</span><span class="params">(size <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">	add := <span class="built_in">make</span>([]<span class="keyword">byte</span>, size)</span><br><span class="line">	ref = <span class="built_in">append</span>(ref, add...)                                                        <span class="comment">// 分配size</span></span><br><span class="line">	fmt.Println(fmt.Sprintf(<span class="string">&quot;%s  %v\n&quot;</span>, time.Now().Format(<span class="string">&quot;15:04:05&quot;</span>), os.Getpid())) <span class="comment">// 打印消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面表示：表示在现在的内存是<code>200M</code>，cpu限制是<code>1</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  go-demo docker run -it --rm --memory  200M  --cpuset-cpus=&quot;1&quot;  --oom-kill-disable -v /Users/dong/go/version/go-1.13.5:/opt/project ce2534430fc2 /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@17d356297d5f project]# go build -o bin/main study/slice/main2.go</span><br><span class="line"></span><br><span class="line"> // .. 可以发现在45s的卡壳了，也就是内存被限制了</span><br><span class="line">08:52:44  103</span><br><span class="line"></span><br><span class="line">08:52:45  103</span><br><span class="line"></span><br><span class="line">top - 08:52:45 up  5:24,  0 users,  load average: 0.96, 1.45, 1.12</span><br><span class="line">Tasks:   4 total,   1 running,   3 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.3 us,  3.0 sy,  0.0 ni, 93.3 id,  1.0 wa,  0.0 hi,  2.4 si,  0.0 st</span></span><br><span class="line">KiB Mem :  2046748 total,  1592784 free,   324656 used,   129308 buff/cache// 这些信息是假的，不能看</span><br><span class="line">KiB Swap:  1048572 total,   703508 free,   345064 used.  1582140 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">  103 root      20   0  645568 200120     68 S  18.9  9.8   0:01.31 main // 200 m</span><br><span class="line">    1 root      20   0   11836   2400   2400 S   0.0  0.1   0:00.15 bash</span><br><span class="line">   51 root      20   0   11836   2332   2332 S   0.0  0.1   0:00.05 bash</span><br><span class="line">   71 root      20   0   56188   2016   1924 R   0.0  0.1   0:00.03 top</span><br></pre></td></tr></table></figure>

<p>查看docker容器真实的内存，可以</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker stats 17d356297d5f</span><br><span class="line">CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">17d356297d5f        cocky_shaw          0.00%               199.4MiB / 200MiB   99.69%              1.18kB / 0B         357MB / 927MB       7</span><br></pre></td></tr></table></figure>

<h3 id="1、关于内存设置这几个参数的关系"><a href="#1、关于内存设置这几个参数的关系" class="headerlink" title="1、关于内存设置这几个参数的关系"></a>1、关于内存设置这几个参数的关系</h3><table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>-m</code>,<code>--memory</code></td>
<td>内存限制，格式是数字加单位，单位可以为 b,k,m,g。最小为 4M</td>
</tr>
<tr>
<td><code>--memory-swap</code></td>
<td>内存+交换分区大小总限制。格式同上。必须必<code>-m</code>设置的大</td>
</tr>
<tr>
<td><code>--memory-reservation</code></td>
<td>内存的软性限制。格式同上</td>
</tr>
<tr>
<td><code>--oom-kill-disable</code></td>
<td>是否阻止 OOM killer 杀死容器，默认没设置</td>
</tr>
<tr>
<td><code>--oom-score-adj</code></td>
<td>容器被 OOM killer 杀死的优先级，范围是[-1000, 1000]，默认为 0</td>
</tr>
<tr>
<td><code>--memory-swappiness</code></td>
<td>用于设置容器的虚拟内存控制行为。值为 0~100 之间的整数</td>
</tr>
<tr>
<td><code>--kernel-memory</code></td>
<td>核心内存限制。格式同上，最小为 4M</td>
</tr>
</tbody></table>
<p> –memory-swap 值必须比**–memory** 值大，因为：–memory-swap不是交换分区，而是内存加交换分区的总大小</p>
<h4 id="1-不设置"><a href="#1-不设置" class="headerlink" title="1. 不设置"></a>1. 不设置</h4><p>如果不设置-m,–memory和–memory-swap，容器默认可以用完宿舍机的所有内存和 swap 分区。不过注意，如果容器占用宿主机的所有内存和 swap 分区超过一段时间后，会被宿主机系统杀死（如果没有设置–00m-kill-disable=true的话）。</p>
<h4 id="2-设置-m-–memory，不设置–memory-swap"><a href="#2-设置-m-–memory，不设置–memory-swap" class="headerlink" title="2. 设置-m,–memory，不设置–memory-swap"></a>2. 设置-m,–memory，不设置–memory-swap</h4><p>给-m或–memory设置一个不小于 4M 的值，假设为 a，不设置–memory-swap，或将–memory-swap设置为 0。这种情况下，容器能使用的内存大小为 a，能使用的交换分区大小也为 a。因为 Docker 默认容器交换分区的大小和内存相同。</p>
<p>如果在容器中运行一个一直不停申请内存的程序，你会观察到该程序最终能占用的内存大小为 2a。</p>
<p>比如$ docker run -m 1G ubuntu:16.04，该容器能使用的内存大小为 1G，能使用的 swap 分区大小也为 1G。容器内的进程能申请到的总内存大小为 2G。</p>
<h4 id="3-设置-m-–memory-a，–memory-swap-b，且b-gt-a"><a href="#3-设置-m-–memory-a，–memory-swap-b，且b-gt-a" class="headerlink" title="3. 设置-m,–memory=a，–memory-swap=b，且b &gt; a"></a>3. 设置-m,–memory=a，–memory-swap=b，且b &gt; a</h4><p>给-m设置一个参数 a，给–memory-swap设置一个参数 b。a 时容器能使用的内存大小，b是容器能使用的 内存大小 + swap 分区大小。所以 b 必须大于 a。b -a 即为容器能使用的 swap 分区大小。</p>
<p>比如$ docker run -m 1G –memory-swap 3G ubuntu:16.04，该容器能使用的内存大小为 1G，能使用的 swap 分区大小为 2G。容器内的进程能申请到的总内存大小为 3G。</p>
<h4 id="4-设置-m-–memory-a，–memory-swap-1"><a href="#4-设置-m-–memory-a，–memory-swap-1" class="headerlink" title="4. 设置-m,–memory=a，–memory-swap=-1"></a>4. 设置-m,–memory=a，–memory-swap=-1</h4><p>给-m参数设置一个正常值，而给–memory-swap设置成 -1。这种情况表示限制容器能使用的内存大小为 a，而不限制容器能使用的 swap 分区大小。</p>
<p>这时候，容器内进程能申请到的内存大小为 a + 宿主机的 swap 大小。</p>
<h3 id="2、cpu限制"><a href="#2、cpu限制" class="headerlink" title="2、cpu限制"></a>2、cpu限制</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker run --help</span><br><span class="line"></span><br><span class="line">Usage:	docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a command in a new container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list                  Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">  -c, --cpu-shares int                 CPU shares (relative weight)</span><br><span class="line">      --cpus decimal                   Number of CPUs</span><br><span class="line">      --cpuset-cpus string             CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string             MEMs in which to allow execution (0-3, 0,1)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>--cpuset-cpus=&quot;&quot;</code></td>
<td>允许使用的 CPU 集，值可以为 0-3,0,1</td>
</tr>
<tr>
<td><code>-c</code>,<code>--cpu-shares=0</code></td>
<td>CPU 共享权值（相对权重）</td>
</tr>
<tr>
<td><code>cpu-period=0</code></td>
<td>限制 CPU CFS 的周期，范围从 100ms~1s，即[1000, 1000000]</td>
</tr>
<tr>
<td><code>--cpu-quota=0</code></td>
<td>限制 CPU CFS 配额，必须不小于1ms，即 &gt;= 1000</td>
</tr>
<tr>
<td><code>--cpuset-mems=&quot;&quot;</code></td>
<td>允许在上执行的内存节点（MEMs），只对 NUMA 系统有效</td>
</tr>
</tbody></table>
<p>关于CFS的概念： <a href="https://www.jianshu.com/p/1da5cfd5cee4">https://www.jianshu.com/p/1da5cfd5cee4</a> </p>
<p>后端基本不需要关注cpu，因为本身不是cpu密集型业务，基本都是io密集型/内存密集型。</p>
<h2 id="4、docker-push-命令"><a href="#4、docker-push-命令" class="headerlink" title="4、docker push 命令"></a>4、docker push 命令</h2><ul>
<li>1、docker hub，类似于git一样，比如很多私人仓库，默认是 <a href="http://hub.docker.com/">hub.docker.com</a>， 比如覆盖则 docker login <a href="http://aliyun.docker.com/">aliyun.docker.com</a> 等等</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker login</span><br></pre></td></tr></table></figure>

<p>输入姓名，输入密码</p>
<ul>
<li>2、 查看推送的镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images </span><br><span class="line"></span><br><span class="line">go1.13.15        latest       ce2534430fc2    26 minutes ago   769MB</span><br></pre></td></tr></table></figure>

<ul>
<li>3、第一步需要打tag</li>
</ul>
<p>一般是 : docker tag &lt;镜像名称&gt; &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;镜像版本号&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker tag go1.13.15 fanhaodong/go1.13.15:v1.0</span><br></pre></td></tr></table></figure>

<ul>
<li>4、push</li>
</ul>
<p>命令： docker push &lt;用户名&gt;/&lt;镜像名称&gt;:&lt;镜像版本号&gt;</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker push fanhaodong/go1.13.15:v1.0</span><br></pre></td></tr></table></figure>

<h2 id="5、docker-其他命令"><a href="#5、docker-其他命令" class="headerlink" title="5、docker 其他命令"></a>5、docker 其他命令</h2><h3 id="1、docker-build"><a href="#1、docker-build" class="headerlink" title="1、docker build"></a>1、docker build</h3><p><code>docker build  --build-arg arg=value --file Dockerfile_path --tag name:version  build_path</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:latest</span><br><span class="line"><span class="comment"># 变量 = 默认值</span></span><br><span class="line"><span class="keyword">ARG</span> IMG_V=<span class="number">1.0</span> </span><br><span class="line"><span class="keyword">ENV</span> IMG_V=$&#123;IMG_V&#125;</span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [ <span class="string">&quot;sh&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;env&quot;</span> ]</span></span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  docker-file-test docker build --tag test:v1 --file ./Dockerfile --build-arg IMG_V=2.0 .</span><br><span class="line">Sending build context to Docker daemon  20.99kB</span><br><span class="line">Step 1/4 : FROM alpine:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> a24bb4013296</span></span><br><span class="line">Step 2/4 : ARG IMG_V=1.0</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> bd247961f4c5</span></span><br><span class="line">Removing intermediate container bd247961f4c5</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 48608560ae13</span></span><br><span class="line">Step 3/4 : ENV IMG_V=$&#123;IMG_V&#125;</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 0ccb1c5aef84</span></span><br><span class="line">Removing intermediate container 0ccb1c5aef84</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 45d309fc4a52</span></span><br><span class="line">Step 4/4 : CMD [ &quot;sh&quot;,&quot;-c&quot;,&quot;env&quot; ]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 6d266d8d8301</span></span><br><span class="line">Removing intermediate container 6d266d8d8301</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> d4ccf528c0ed</span></span><br><span class="line">Successfully built d4ccf528c0ed</span><br><span class="line">Successfully tagged test:v1</span><br><span class="line"></span><br><span class="line">➜  docker-file-test docker run --rm test:v1</span><br><span class="line">HOSTNAME=59991997b9be</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">IMG_V=2.0</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">PWD=/</span><br></pre></td></tr></table></figure>

<p>可以看到成功 执行了环境变量！</p>
<h3 id="2、docker-run"><a href="#2、docker-run" class="headerlink" title="2、docker run"></a>2、docker run</h3><h4 id="传递env"><a href="#传递env" class="headerlink" title="传递env"></a>传递env</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM alpine:latesta</span><br><span class="line">CMD [ &quot;sh&quot;,&quot;-c&quot;,&quot;env&quot; ]</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[admin@centos-linux docker-file-test]$ docker build -t test-1 .</span><br><span class="line">Sending build context to Docker daemon  23.04kB</span><br><span class="line">Step 1/2 : FROM alpine:latest</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> a24bb4013296</span></span><br><span class="line">Step 2/2 : CMD [ &quot;sh&quot;,&quot;-c&quot;,&quot;env&quot; ]</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 65c81ab9dc1f</span></span><br><span class="line">Removing intermediate container 65c81ab9dc1f</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 027268ad86ee</span></span><br><span class="line">Successfully built 027268ad86ee</span><br><span class="line">Successfully tagged test-1:latest</span><br><span class="line">[admin@centos-linux docker-file-test]$ docker run --env demo=1 test-1</span><br><span class="line">HOSTNAME=d4504e8ef3be</span><br><span class="line">SHLVL=1</span><br><span class="line">HOME=/root</span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">demo=1</span><br><span class="line">PWD=/</span><br></pre></td></tr></table></figure>

<p>传递环境变量，是可以到运行时！</p>
<h3 id="3、docker-start"><a href="#3、docker-start" class="headerlink" title="3、docker  start"></a>3、docker  start</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="shell脚本启动"><a href="#shell脚本启动" class="headerlink" title="shell脚本启动"></a>shell脚本启动</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取cid</span></span><br><span class="line">CID=$(docker create --rm test-1)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据cid启动</span></span><br><span class="line">docker start $CID</span><br><span class="line"><span class="meta">#</span><span class="bash"> flag</span></span><br><span class="line">echo &quot;start success!!!!&quot;</span><br></pre></td></tr></table></figure>

<p>运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[admin@centos-linux docker-file-test]$ bash new.sh</span><br><span class="line">dd9159e2d3da614f6dc7f816300d75ad58c6acf673eb9bea1e8a3f3af60a4137</span><br><span class="line">start success!!!!</span><br></pre></td></tr></table></figure>

<p>good 启动了 ！！！</p>
<h3 id="5、挂载"><a href="#5、挂载" class="headerlink" title="5、挂载"></a>5、挂载</h3><p><code>docker run --rm -v /opt test-3</code></p>
<p>如果容器销毁，宿主机文件也会被销毁！！！！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">  &#123;</span><br><span class="line">      &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">      &quot;Name&quot;: &quot;79c49a14a84ce8f6ba852e11d91a109ac1c02a6649e83f68b316990404035148&quot;,</span><br><span class="line">      &quot;Source&quot;: &quot;/var/lib/docker/volumes/79c49a14a84ce8f6ba852e11d91a109ac1c02a6649e83f68b316990404035148/_data&quot;,// 宿主机目录</span><br><span class="line">      &quot;Destination&quot;: &quot;/opt&quot;, // 容器目录</span><br><span class="line">      &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">      &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">      &quot;RW&quot;: true,</span><br><span class="line">      &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">      &quot;/home/admin/dong/docker/docker-file-test&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><code>docker run --rm -v /home/admin/dong/docker/docker-file-te/:/opt test-3</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;bind&quot;,</span><br><span class="line">        &quot;Source&quot;: &quot;/home/admin/dong/docker/docker-file-test&quot;,</span><br><span class="line">        &quot;Destination&quot;: &quot;/opt&quot;,</span><br><span class="line">        &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">        &quot;RW&quot;: true,</span><br><span class="line">        &quot;Propagation&quot;: &quot;rprivate&quot;</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h3 id="6、docker-commit"><a href="#6、docker-commit" class="headerlink" title="6、docker commit"></a>6、docker commit</h3><blockquote>
<p>​    这个比较适合不会写docker file的人，这里我举个例子，假如现在我们有一个centos:7</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull centos:7</span><br></pre></td></tr></table></figure>

<p>其次，我们要安装一个curl命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  /data docker run --rm -it 7e6257c9f8d8  /bin/bash</span><br><span class="line">[root@bcdaea8354a6 /]# yum install -y curl</span><br><span class="line">[root@bcdaea8354a6 /]# curl www.baidu.com</span><br><span class="line">&lt;!DOCTYPE html&gt; // good</span><br></pre></td></tr></table></figure>

<p>此时我们只需要进行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ~ docker ps -a -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">bcdaea8354a6        7e6257c9f8d8        &quot;/bin/bash&quot;         2 minutes ago       Up 2 minutes                            happy_liskov</span><br><span class="line">➜  ~ docker commit bcdaea8354a6  demo-2</span><br><span class="line">sha256:350fbf288cb1a47a29e3d8e441e2814726de6faf54d044a585fb80b7a1f38f83</span><br></pre></td></tr></table></figure>

<p>这个镜像就OK了，就可以使用 <code>demo-2</code>的镜像了</p>
]]></content>
  </entry>
  <entry>
    <title>关于容器化的思考</title>
    <url>/2021/02/28/hello-world/</url>
    <content><![CDATA[<p>​    我最近半个月内一直在看docker，但是看完后发现，它只是个cli的工具，cli提供了build，push，pull，run等功能，包含了构建镜像，打包发布，拉取，运行。其实不考虑这些，对于公司级别的cicd工具来说，也是这几个流程，比如说我一个git仓库地址，再通过Jenkins等ci工具构建，构建完成后发布到发布机器上，等我们去发布的时候，就是拉取这个zip包/或者镜像，解压/运行，程序去启动后不在考虑范围内，这个过程是最简单最常见的。</p>
<span id="more"></span>
<p>所以docker只是提供了一个工具进行这个流程。换了一种承载方式。换句话说它确定了<strong>软件究竟应该通过什么样的方式进行交付</strong>。docker的创新就是将交付转变为容器/镜像，解决了开发人员的痛点。</p>
<p>本篇不讨论，定义和管理容器技术的OpenStack &amp; kubernetes &amp; Docker Swarm等！</p>
<p>ps：学习这些只是看看自己适不适合学习容器化方向的技术，每一个技术背后的技术都很多，如果只是使用，那么了解即可，正如<a href="https://mobyproject.org/">moby</a>官网上说的一样。为啥要学习容器化技术呢，虽然作为一个后端开发，不需要掌握容器化技术，但是了解只是为了思考和成长！云原生开发工程师需要掌握的太多了，所以切记不能随大流。</p>
<h2 id="1、什么是容器化"><a href="#1、什么是容器化" class="headerlink" title="1、什么是容器化"></a>1、什么是容器化</h2><p>容器化是应用程序级别的<a href="https://www.alibabacloud.com/zh/knowledge/what-is-virtualization">虚拟化</a>，允许单个内核上有多个独立的用户空间实例（它是一个进程，但是进程内部确实一个完整的运行环境）。这些实例称为容器。</p>
<p>那么虚拟化是什么？虚拟化是指硬件虚拟化，也就是在操作系统（OS）中创建虚拟机。</p>
<p>虚拟化：<strong>虚拟机监视器（Hypervisor）</strong>是安装在物理硬件上的软件层，可以将物理机通过<a href="https://www.alibabacloud.com/zh/knowledge/what-is-virtualization">虚拟化</a>分成许多虚拟机。这样多个操作系统可以在一个物理硬件上同时运行。安装在虚拟机上的操作系统称为虚拟操作系统，也称为实例。有虚拟机监视器运行的硬件称为主机。虚拟机管理控制台（也称为虚拟机管理员（VMM））是一种计算机软件，可以轻松管理虚拟机。关于虚拟机的分类：<a href="https://www.alibabacloud.com/zh/knowledge/what-is-hypervisor">https://www.alibabacloud.com/zh/knowledge/what-is-hypervisor</a></p>
<p>关于虚拟机的实现，相关讨论：<a href="https://www.zhihu.com/question/20848931">https://www.zhihu.com/question/20848931</a> </p>
<p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/72b1b7a471434772b16648798ce625f8.png" alt="image-20201006111014758"></p>
<p>上图是虚拟机与容器的区别！，详细可以看：<a href="https://www.alibabacloud.com/zh/knowledge/difference-between-container-and-virtual-machine">https://www.alibabacloud.com/zh/knowledge/difference-between-container-and-virtual-machine</a> ， 可以发现每个虚拟机都有单独的操作系统，而容器是不需要的。但是容器真的不需要单独的操作系统吗，你还记得dockerfile中每一个镜像都需要制定一个运行环境。那么上面这个图是错误的吗？？？</p>
<p>其实很多人应该注意到，这个链接有解释：<a href="https://stackoverflow.com/questions/32841982/how-can-docker-run-distros-with-different-kernels">https://stackoverflow.com/questions/32841982/how-can-docker-run-distros-with-different-kernels</a></p>
<blockquote>
<p>There’s no kernel inside a container. Even if you install a kernel, it won’t be loaded when the container starts. The very purpose of a container is to isolate processes without the need to run a new kernel.</p>
</blockquote>
<p>容器内没有内核。即使您安装了内核，在容器启动时也不会加载该内核。容器的真正目的是在不运行新内核的情况下隔离进程。</p>
<p>那么容器实现的技术，这里也不详细展开了，主要是依赖于linux系统本身自带的隔离功能！</p>
<img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/1e9e938081f44249b55427da8a9c5626.png" alt="image-20201006121328495" style="zoom:50%;" />

<p>主要核心就是资源隔离(做到容器互不影响很关键)，使用技术就是 cgroup 对于cpu、memory的限制，以及namespace等，其实这些技术都是操作系统提供的，对于docker的作者也是基于这些进行实现的，所以docker的成功是可能就是机遇吧，而不是docker的技术！！docker公司前身就是个云服务提供商！</p>
<p>有兴趣可以看看这篇文章：<a href="http://dockone.io/article/8832">容器发展简史</a> 以及 <a href="https://zhuanlan.zhihu.com/p/85528062">容器的隔离与限制</a>， <a href="https://tech.meituan.com/2015/03/31/cgroups.html">Cgroup介绍</a></p>
<p>做云原生开发工程师，需要掌握Kubernetes，Docker，Service Mesh等领域相关的知识，并且有实践，交付经验，道阻且长，本人也是兴趣。</p>
<h2 id="2、容器化发展历史"><a href="#2、容器化发展历史" class="headerlink" title="2、容器化发展历史"></a>2、容器化发展历史</h2><blockquote>
<p>​    这一篇主要是介绍，容器化走过这么多年，难道真的是因为docker出生才火的吗，还是时代的趋势！虽然 docker 把容器技术推向了巅峰，但容器技术却不是从 docker 诞生的。</p>
</blockquote>
<h3 id="1、容器化发展历史"><a href="#1、容器化发展历史" class="headerlink" title="1、容器化发展历史"></a>1、容器化发展历史</h3><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/62aecfeb27d44087ad54c7565808b883.png" alt="image-20201006115550572"></p>
<p><strong>1、Chroot Jail</strong><br>就是我们常见的 chroot 命令的用法。它在 1979 年的时候就出现了，被认为是最早的容器化技术之一。它可以把一个进程的文件系统隔离起来。</p>
<p><strong>2、The FreeBSD Jail</strong><br>Freebsd Jail 实现了操作系统级别的虚拟化，它是操作系统级别虚拟化技术的先驱之一。</p>
<p><strong>3、Linux VServer</strong><br>使用添加到 Linux 内核的系统级别的虚拟化功能实现的专用虚拟服务器。</p>
<p><strong>4、Solaris Containers</strong><br>它也是操作系统级别的虚拟化技术，专为 X86 和 SPARC 系统设计。Solaris 容器是系统资源控制和通过 “区域” 提供边界隔离的组合。</p>
<p><strong>5、OpenVZ</strong><br>OpenVZ 是一种 Linux 中操作系统级别的虚拟化技术。 它允许创建多个安全隔离的 Linux 容器，即 VPS。</p>
<p><strong>6、Process Containers</strong><br>Process 容器由 Google 的工程师开发，一般被称为 cgroups。</p>
<p><strong>7、LXC</strong><br>2008年，通过将 Cgroups 的资源管理能力和 Linux Namespace 的视图隔离能力组合在一起，LXC（Linux Container）这样的完整的容器技术出现在了 Linux 内核当中。（0.9一下的低版本的docker就是利用的这个技术！！）</p>
<p><strong>8、Warden</strong><br>在最初阶段，Warden 使用 LXC 作为容器运行时。 如今已被 CloudFoundy （ VMware 公司于 2011 年宣布了这个项目的开源，第一次对 PaaS 的概念完成了清晰而完整的定义，PaaS 项目通过对应用的直接管理、编排和调度让开发者专注于业务逻辑而非基础设施）取代。</p>
<p><strong>9、LMCTFY</strong><br>LMCTY 是 Let me contain that for you 的缩写。它是 Google 的容器技术栈的开源版本。<br>Google 的工程师一直在与 docker 的 libertainer 团队合作，并将 libertainer 的核心概念进行抽象并移植到此项目中。该项目的进展不明，估计会被 libcontainer 取代。（0.9以上的高版本的docker就是利用的libcontainer，其实就是对于lxc的封装，用go写的，开发起来比较方便）</p>
<p><strong>10、Docker</strong></p>
<p>Docker 是一个可以将应用程序及其依赖打包到几乎可以在任何服务器上运行的容器的工具。（<strong>dotCloud</strong>公司开源的自己的容器化技术，最后公司直接改名字叫为docker了）</p>
<p><strong>11、Docker-Swarm</strong></p>
<p>Docker公司在2014年12月的DockerCon上发布Swarm的举动，你可以很轻松的一个命令，就可以将容器调度在任意一台Swarm集群的机器上。docker的衰败也是因为在容器编排技术之争中跌落神坛的。</p>
<p><strong>12、Fig</strong></p>
<p>docker的大紫大红，后来收购了Fig项目，他可以解决容器之间依赖的问题，也就是当前的docker-compose项目，前身就是Fig。</p>
<p>docker成功后，收购了很多好的项目，专门负责处理容器网络的SocketPlane项目，专门负责处理容器存储的Flocker项目，专门给Docker集群做图形化管理界面和对外提供云服务的Tutum项目。</p>
<p><strong>13、RKT</strong><br>RKT 是 Rocket 的缩写，它是一个专注于安全和开放标准的应用程序容器引擎。（原来docker的合作伙伴CoreOS公司，CoreOS公司自己研发的容器化工具）</p>
<p><strong>13、终结者Kubernetes</strong></p>
<p>​    2017年,  基础设施领域的翘楚Google公司突然发力，正式宣告了一个名叫Kubernetes项目的诞生。这个项目，不仅挽救了当时的CoreOS和RedHat，还如同当年Docker项目的横空出世一样，再一次改变了整个容器市场的格局。并将 CNCF 这个以“云原生”为关键词的组织和生态推向了巅峰。</p>
<h3 id="2、容器化的一些名词"><a href="#2、容器化的一些名词" class="headerlink" title="2、容器化的一些名词"></a>2、容器化的一些名词</h3><p>其实看到这里，我们发现容器化技术发展了这么多年，技术变更这么快的年代，最可怕的是，我学了一门技术，立马被淘汰了，所以docker也是，为了保障docker的标准化，做出了一系列的努力。</p>
<p><strong>1、Docker &amp; LXC</strong><br>Docker 的第一个执行环境是 LXC，但从版本 0.9 开始 LXC 被 libcontainer 取代。</p>
<p><strong>2、Docker &amp; libcontainer</strong><br>Libcontainer 为 docker 封装了 Linux 提供的基础功能，如 cgroups，namespaces，netlink 和 netfilter 等</p>
<p><strong>3、2015 - Docker ＆ runC</strong></p>
<p>2015 年，docker 发布了 runC，一个轻量级的跨平台的容器运行时。 这基本上就是一个命令行小工具，可以直接利用 libcontainer 运行容器，而无需通过 docker engine。runC 的目标是使标准容器在任何地方都可用。</p>
<p><strong>4、Docker &amp; The Open Containers Initiative(OCI)</strong><br>OCI 是一个轻量级的开放式管理架构，由 docker，CoreOS 和容器行业的其他领导厂商于 2015 年建立。它维护一些项目，如 runC ，还有容器运行时规范和镜像规范。OCI 的目的是围绕容器行业制定标准，比如使用 docker 创建的容器可以在任何其他容器引擎上运行。</p>
<p><strong>5、2016 - Docker &amp; containerd</strong></p>
<p>2016年，Docker 分拆了 containerd，并将其捐赠给了社区。将这个组件分解为一个单独的项目，使得 docker 将容器的管理功能移出 docker 的核心引擎并移入一个单独的守护进程(即 containerd)。</p>
<p><strong>6、Docker Components</strong><br>分拆完 containerd 后，docker 各组件的关系如下图所示：</p>
<p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/de0fb51068364f6181c014235defe9bd.png" alt="img"></p>
<p><strong>7、Docker 如何运行一个容器？</strong></p>
<ol>
<li>Docker 引擎创建容器镜像(oci规范)</li>
<li>将容器映像传递给 containerd</li>
<li>containerd 调用 containerd-shim</li>
<li>containerd-shim 使用 runC 来运行容器</li>
<li>containerd-shim 允许运行时(本例中为 runC)在启动容器后退出</li>
</ol>
<p>该模型带来的最大好处是在升级 docker 引擎时不会中断容器的运行。</p>
<p><strong>8、2017 - 容器成为主流</strong></p>
<p>2017 年是容器成为主流技术的一年，这就是为什么 docker 在 Linux 之外支持众多平台的原因（Docker for Mac，Docker for Windows，Docker for AWS，GCP 等）。</p>
<p>当容器技术被大众接受后，Docker 公司意识到需要新的生产模型，这就是为什么它开始 Moby 项目。最为go语言开源项目的top3的项目，一开始我也不知道moby项目是做啥了。。。</p>
<p>其实可以发现，在这个百花齐放的操作系统平台上，如何不进行case by case，重复造轮子，就是拆分，通用组件，现成的直接使用就行了。moby就是这个</p>
<h3 id="3、容器化做的一些转变"><a href="#3、容器化做的一些转变" class="headerlink" title="3、容器化做的一些转变"></a>3、容器化做的一些转变</h3><p>主要还是开源出moby项目，<a href="https://github.com/moby/moby">https://github.com/moby/moby</a></p>
<p><strong>（1）Containerd</strong><br>Containerd 是 docker 基于行业标准创建的核心容器运行时。它可以用作 Linux 和 Windows 的守护进程，并管理整个容器生命周期。</p>
<p><strong>（2）Linuxkit</strong><br>Linuxkit 是 Moby 项目中的另一个组件，它是为容器构建安全、跨平台、精简系统的工具。目前已经支持的本地 hypervisor 有 hyper-v 和 vmware。支持的云平台有 AWS、Azure 等。</p>
<p><strong>（3）Infrakit</strong><br>Infrakit 也是 Moby 项目的一部分。它是创建和管理声明式、不可变和自我修复基础架构的工具包。<br>Infrakit 旨在自动化基础架构的设置和管理，以支持分布式系统和更高级别的容器编排系统。Infrakit 对于像 Docker Swarm 和 Kubernetes 这样的编排工具或跨越 AWS 等公共云创建自动缩放群集的用例很有用。</p>
<p><strong>（4）Libnetwork</strong><br>Libnetwork 是用 Go 语言实现的容器网络管理项目。它的目标是定义一个容器网络模型(CNM)，<br>并为应用程序提供一致的编程接口以及网络抽象。这样就可以满足容器网络的 “可组合” 需求。</p>
<p><strong>（5）Docker &amp; Docker Swarm</strong><br>Docker Swarm 是一个在 docker 引擎中构建的编排工具。从 docker 1.12 开始它就作为一个独立的工具被原生包含在 docker engine 中。我们可以使用 docker cli 通过 docker swarm 创建群集，并部署和管理应用程序和服务。下图描述了 docker swarm 在 docker 体系中的作用(此图来自互联网)：</p>
<p><strong>（6）Docker＆Kubernetes</strong><br>在 docker swarm 与 kubernetes 的竞争中，显然是 kubernetes 占据了优势。所以 docker 紧急掉头，开始原生的支持与 kubernetes 的集成。这可是 2017 年容器界的一大新闻啊！至此，docker 用户和开发人员可以自由地选择使用 kubernetes 或是 swarm 执行容器的编排工作。我们可以认为 docker 与 kubernetes 联姻了。</p>
<p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2020/10-6/5e856640bcb343b6aa8e6dc1326988d2.png" alt="img"></p>
<p>文章参考： <a href="https://www.cnblogs.com/along21/p/9183609.html">https://www.cnblogs.com/along21/p/9183609.html</a></p>
<p>茫茫的容器化技术，不是一篇文章能说清楚的，理解其本质也不知是说，我了解namespcae和cgropus就能说了解的。</p>
<h2 id="3、容器化技术解决了什么"><a href="#3、容器化技术解决了什么" class="headerlink" title="3、容器化技术解决了什么"></a>3、容器化技术解决了什么</h2><p>我想很多公司都在使用云服务商提供的虚拟机，其中资源浪费简直是不能看，基本资源利用率在80-90%之间，所以急需一个轻量级的运行时。<strong>容器</strong>提供了将应用程序的代码、运行时、系统工具、系统库和配置打包到一个<strong>实例</strong>中的标准方法。容器共享一个<strong>内核</strong>（操作系统），它安装在硬件上。</p>
<h3 id="好处：（我觉得很多人都知道）"><a href="#好处：（我觉得很多人都知道）" class="headerlink" title="好处：（我觉得很多人都知道）"></a>好处：（我觉得很多人都知道）</h3><ul>
<li><p><strong>轻便</strong><br>容器占用的服务器空间比虚拟机少，通常只需几秒钟即可启动。</p>
</li>
<li><p><strong>弹性</strong><br>容器具有高弹性，不需要分配给定数量的资源。这意味着容器能够更有效地动态使用服务器中的资源。当一个容器上的需求减少时，释放额外的资源供其他容器使用。</p>
</li>
<li><p><strong>密度</strong><br>密度是指一次可以运行单个物理服务器的对象数。容器化允许创建密集的环境，其中主机服务器的资源被充分利用但不被过度利用。与传统虚拟化相比，容器化允许更密集的环境容器不需要托管自己的操作系统。</p>
</li>
<li><p><strong>性能</strong><br>当资源压力很大时，应用程序的性能远远高于使用虚拟机管理程序的容器。因为使用传统的虚拟化，客户操作系统还必须满足其自身的内存需求，从主机上获取宝贵的RAM。</p>
</li>
<li><p><strong>维护效率</strong><br>只有一个操作系统内核，操作系统级别的更新或补丁只需要执行一次，以使更改在所有容器中生效。这使得服务器的操作和维护更加高效。</p>
</li>
<li><p><strong>方便应用程序管理</strong></p>
<p>容器受益者，主要还是环境隔离，比如一个应用程序，1、需要supervise启动应用程序(守护程序)，2、需要logstash/Filebeat收集日志，3、需要nginx/其他Sadicar进行一些服务治理的功能，服务发现/限流/熔断等。4、还需要很多运行环境。所以对于快速发展的公司来说，sre如果还是手动的创建虚拟机，那么和容器带来的时间不是一个量级的。5、解决了开发人员不需要登陆到机子上查看物理机信息了。</p>
</li>
<li><p><strong>省钱，省机器</strong></p>
<p>虚拟机资源利用率太低了，但是配合k8s编排工具，很好的解决了资源的浪费。但是k8s技术对于公司也是一个挑战，玩不好服务不稳定，带来的损失还是不如走物理机/虚拟机。</p>
</li>
</ul>
<h2 id="4、容器化-云原生的技术"><a href="#4、容器化-云原生的技术" class="headerlink" title="4、容器化/云原生的技术"></a>4、容器化/云原生的技术</h2><p>1、OCI（Open Container Initiative） 标准，隔离了容器镜像与runtine的关系，提供的规范标准，</p>
<p>2、CNCF全称Cloud Native Computing Foundation（云原生计算基金会），成立于 2015 年7月21日，组织内技术栈：<a href="https://www.cncf.io/projects/">https://www.cncf.io/projects/</a>，致力于：</p>
<ul>
<li>容器化包装。</li>
<li>通过中心编排系统的动态资源管理。</li>
<li>面向微服务。(核心还是切入到真实业务开发中)</li>
</ul>
<p>3、Linux资源隔离技术了解</p>
<p>4、Kubernetes熟悉，有Operator扩展或相关产品研发经验优先</p>
<p>5、 Docker的相关的网络和存储技术，有生产环境的实践</p>
<p>6、云原生技术栈，Prometheus，Envoy等，更多的还是CNCF的毕业的项目的。</p>
<p>7、更多的还是 Iass，Pass系统开发者经验，空谈技术不务实，就是最扯淡的。</p>
<p>发现有些无缘！！</p>
<h2 id="5、容器化技术面临的挑战"><a href="#5、容器化技术面临的挑战" class="headerlink" title="5、容器化技术面临的挑战"></a>5、容器化技术面临的挑战</h2><p>作为一种轻量级的虚拟化技术，容器使用方便、操作便捷，大大提高开发人员的工作效率，并得到业内的广泛使用。但与此同时，容器安全事故频发，包括不安全的镜像源、容器入侵事件、运行环境的安全问题等等。</p>
<h3 id="1-不安全的镜像源"><a href="#1-不安全的镜像源" class="headerlink" title="1. 不安全的镜像源"></a>1. 不安全的镜像源</h3><p>开发者通常会在 Docker 官方的 Docker Hub 仓库下载镜像，这些镜像一部分来源于开发镜像内相应软件的官方组织，还有大量镜像来自第三方组织甚至个人。从这些镜像仓库中获取镜像的同时，也带来潜在的安全风险。例如，下载镜像内软件本身是否就包含漏洞，下载的镜像是否被恶意植入后门，镜像在传输过程中是否被篡改。</p>
<h3 id="2-容器入侵事件"><a href="#2-容器入侵事件" class="headerlink" title="2. 容器入侵事件"></a>2. 容器入侵事件</h3><p>由 docker 本身的架构与机制可能产生的问题，这一攻击场景主要产生在黑客已经控制了宿主机上的一些容器（或者通过在公有云上建立容器的方式获得这个条件），然后对宿主机或其他容器发起攻击来产生影响。</p>
<h3 id="3-运行环境的安全"><a href="#3-运行环境的安全" class="headerlink" title="3. 运行环境的安全"></a>3. 运行环境的安全</h3><p>除 docker 本身存在的问题外，docker 运行环境存在的问题同样给 docker 的使用带来风险。</p>
<p>由于容器是介于基础设施和平台之间的虚拟化技术，因此面向基础设施虚拟化的传统云安全解决方案无法完全解决前述安全问题。如以容器为支撑技术构建 DevOps 环境，就需要设计涵盖从容器镜像的创建到投产上线的整个生命周期的容器安全方案。</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>最后记住，这些所有的一切，只是为了提高研发效率！！！没有价值的代码都是无用代码，没有给企业带来价值，只有淘汰。所有的一切都是为了驱动企业快速发展，主要还是💰 or 价值。</p>
<p>可以看看这个PPT：<a href="https://docs.qq.com/pdf/DU290V1dSU2NMTHlw">https://docs.qq.com/pdf/DU290V1dSU2NMTHlw</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cloud-atlas.readthedocs.io/zh_CN/latest/index.html">云计算图志</a></p>
<p><a href="https://www.infoq.cn/article/SS6SItkLGoLExQP4uMr5">https://www.infoq.cn/article/SS6SItkLGoLExQP4uMr5</a></p>
<p><a href="https://www.infoq.cn/article/R1p3H3_29f4TYImExsyw">https://www.infoq.cn/article/R1p3H3_29f4TYImExsyw</a></p>
<p><a href="https://jimmysong.io/kubernetes-handbook/cloud-native/cncf.html">CNCF chinal</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1080886">命令式和声明式区别</a></p>
]]></content>
  </entry>
</search>

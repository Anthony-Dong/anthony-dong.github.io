<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anthony-dong.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="​     如今互联网已经与我们密不可分了，购物、金融、社交、娱乐等都依赖于互联网，其中主要依赖的几项技术就包含HTTP（HyperText Transfer Protocol， 超文本传输协议）。本文核心就是介绍HTTP发展历史以及HTTP&#x2F;2协议！"><meta property="og:type" content="article"><meta property="og:title" content="聊一聊HTTP协议"><meta property="og:url" content="https://anthony-dong.github.io/2022/05/19/14ae618744ce995daa153156bee2d2e6/index.html"><meta property="og:site_name" content="Anthony-Dong"><meta property="og:description" content="​     如今互联网已经与我们密不可分了，购物、金融、社交、娱乐等都依赖于互联网，其中主要依赖的几项技术就包含HTTP（HyperText Transfer Protocol， 超文本传输协议）。本文核心就是介绍HTTP发展历史以及HTTP&#x2F;2协议！"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/4431001123e84b22bd45693c9762f72b.jpg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/a5bd728da53241fbbd192a8810141408.svg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/0f831b3e675b450690ed6cd39ad28356.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-11/624a4c01125645a7844a6797a25f6c54.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/e5e1dcd5f58449c3908c54cf9e536bd1.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/3dd8cdf0995043a0af946a2e0bc8f6a8.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-11/2b7c075406d241939a0b00cfd872bb2a.jpeg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/4767f9839bf347218b63d0d8b7a6ba3c.awebp"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/3941fac3371f4a97be5a98efff98a38a.jpeg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/19bc2a57f8964c51af397a92871ab7a6.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/9bcfc85ff30343d595c7297d01b14551.jpg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/ab103cb9dffd42e0a226b95f1aa8bdc3.gif"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-22/3480e65e624e475bba7f66ca4ea8bca2.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-22/f7cf22543e7549569cd23329ecc50952.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/5212c3fe29db4d688dde9076d1b69d15.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/e520970d98f8466d8bb5070f3ecd9a3b.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/3fe1b5f6448749439b938b9666795ecc.jpg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/7d52fb82945b4505a5842d77c4afbdbb.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/41904c06c44c4e35b5c4e35b2ab751ac.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a8a6be83ac5b46adae39367c9aee772b.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a3a70bc84a634f6f949737c3cee43a16.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a3a70bc84a634f6f949737c3cee43a16.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-19/3719f7ba9e904e65bbb7b96c4cf08e30.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-19/8a90221c23494861ab5148e832b56da0.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/5e69f9923eda45e4a863cd94d8f78986.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/1cdb974839814c26913cde2ed1fef562.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/2409f7effc584774a1248cc1016d27a1.jpeg"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/0391ffba9ef5470792dfdf87f2e6b220.png"><meta property="article:published_time" content="2022-05-19T08:14:28.000Z"><meta property="article:modified_time" content="2022-11-07T08:26:31.300Z"><meta property="article:author" content="Anthony-Dong"><meta property="article:tag" content="HTTP"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/4431001123e84b22bd45693c9762f72b.jpg"><link rel="canonical" href="https://anthony-dong.github.io/2022/05/19/14ae618744ce995daa153156bee2d2e6/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>聊一聊HTTP协议 | Anthony-Dong</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?899b2a5c34078209c5f30853eaaa7846";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anthony-Dong</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Anthony-Dong技术博客</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Anthony-Dong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anthony-dong.github.io/2022/05/19/14ae618744ce995daa153156bee2d2e6/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Anthony-Dong"><meta itemprop="description" content="追寻技术的本质！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anthony-Dong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">聊一聊HTTP协议</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2022-05-19 16:14:28" itemprop="dateCreated datePublished" datetime="2022-05-19T16:14:28+08:00">2022-05-19</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2022-11-07 16:26:31" itemprop="dateModified" datetime="2022-11-07T16:26:31+08:00">2022-11-07</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/HTTP/" itemprop="url" rel="index"><span itemprop="name">HTTP</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>31k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>28 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>​ 如今互联网已经与我们密不可分了，购物、金融、社交、娱乐等都依赖于互联网，其中主要依赖的几项技术就包含HTTP（HyperText Transfer Protocol， 超文本传输协议）。本文核心就是介绍HTTP发展历史以及HTTP/2协议！</p><span id="more"></span><h1 id="HTTP发展历史"><a href="#HTTP发展历史" class="headerlink" title="HTTP发展历史"></a>HTTP发展历史</h1><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/4431001123e84b22bd45693c9762f72b.jpg" alt="preview"></p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>HTTP协议的第一个规范是1991年发布的0.9版本，此规范文档不足700个单词，其中规范中指出了通过TCP/IP （或类似的面向连接的服务）与服务器和端口建立连接！规范申明<strong>错误类型</strong>以<strong>可读文本</strong>显示HTML语法，以及请求是幂等的！</p><blockquote><p>目前已经没有网站和浏览器支持 http/0.9 协议了！</p></blockquote><p>请求格式：只有GET方法，报文如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /doc/index.heml</span><br></pre></td></tr></table></figure><p>响应内容：只有HTML文本，所以无法传输其他类型文件！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;HTML&gt;</span><br><span class="line">这是一个非常简单的HTML页面</span><br><span class="line">&lt;/HTML&gt;</span><br></pre></td></tr></table></figure><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a><a href="HTTP/1.0">HTTP/1.0</a></h2><p>在1991-1995年，人们由于不满足HTTP/0.9，于是搞了一些新扩展，但是这些新拓展并没有被引入到标准中。直到1996年11月，为了解决这些问题，一份新文档（<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc1945">RFC 1945</a>）被发表出来，用以描述如何操作实践这些新扩展功能。</p><p>主要新增内容如下：</p><ol><li>引入了 POST、HEAD方法</li><li>请求与响应都引入了 HTTP 头/首部（Header），为此也支持了其他传输类型（图片等）</li><li>引入响应状态码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl --http1.0 www.baidu.com -v</span><br><span class="line">*   Trying 220.181.38.149:80...</span><br><span class="line">* Connected to www.baidu.com (220.181.38.149) port 80 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET / HTTP/1.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: www.baidu.com</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.77.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="bash">* Mark bundle as not supporting multiuse</span></span><br><span class="line">* HTTP 1.0, assume close after body</span><br><span class="line">&lt; HTTP/1.0 200 OK</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">&lt; Content-Length: 2381</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line"><span class="meta">#</span><span class="bash"> .... 省略</span></span><br></pre></td></tr></table></figure><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2068">HTTP/1.1</a></h2><p>HTTP/1.0 多种不同的实现方式在实际运用中显得有些混乱，自1995年开始，即HTTP/1.0文档发布的下一年，就开始修订HTTP的第一个标准化版本。于是在1997年初，HTTP1.1 标准发布。</p><p>主要新增内容如下：（下列内容部分也在HTTP/1.0中有支持，所以和HTTP/1.1统称为HTTP/1.X）</p><ol><li>连接复用 (引入 Keep-Alive Header)</li><li>增加管线化（管道化）技术，允许在第一个应答被完全发送之前就发送第二个请求，以降低通信延迟。</li><li>支持响应分块(chunked编码)</li><li>引入额外的缓存控制机制</li><li>引入内容协商机制，包括<strong>语言</strong>，<strong>编码</strong>，<strong>类型</strong>等，并允许客户端和服务器之间约定以最合适的内容进行交换</li><li>凭借<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Host"><code>Host</code></a>头，能够使不同域名配置在同一个IP地址的服务器上，并且<strong>强制要求客户端请求必须携带Host</strong>。例如Nginx这种反向代理工具，可能根据Host进行反向代理，也就是一台服务器承载多个域名！</li><li>支持包含GET、POST、PUT、PATCH、DELETE、HEAD、CONNECT、OPTIONS、TRACE 请求方法</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl --http1.1 www.baidu.com -v</span><br><span class="line">*   Trying 220.181.38.149:80...</span><br><span class="line">* Connected to www.baidu.com (220.181.38.149) port 80 (#0)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> GET / HTTP/1.1</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Host: www.baidu.com</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> User-Agent: curl/7.77.0</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Accept: */*</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br><span class="line"><span class="bash">* Mark bundle as not supporting multiuse</span></span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Content-Length: 2381</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Date: Mon, 23 May 2022 09:57:28 GMT</span><br><span class="line">&lt; Etag: &quot;588604c8-94d&quot;</span><br><span class="line">&lt; Last-Modified: Mon, 23 Jan 2017 13:27:36 GMT</span><br><span class="line">&lt; Pragma: no-cache</span><br><span class="line">&lt; Server: bfe/1.0.8.18</span><br><span class="line">&lt; Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br></pre></td></tr></table></figure><p>由于HTTP协议的可扩展性 – 创建新的头部和方法是很容易的 – 即使 HTTP/1.1 协议进行过两次修订，<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2616">RFC 2616</a> 发布于 1999 年 6 月，而另外两个文档 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7230">RFC 7230</a>-<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7235">RFC 7235</a> 发布于 2014 年 6 月（在 HTTP/2 发布之前）。HTTP/1.1 协议已经稳定使用超过 15 年了。</p><h3 id="1-HTTP-1-1-修订记录"><a href="#1-HTTP-1-1-修订记录" class="headerlink" title="1. HTTP/1.1 修订记录"></a>1. HTTP/1.1 修订记录</h3><p>HTTP/1.1 协议发布于1997年的1月份，后面经过三次修订！最后一次修订时间是2014年6月份！具体修订内容可以点击下面链接进行查看！<del>HTTP1.1的岁数和我差不多！</del></p><ol><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2068">首发 1997年 rfc2068</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc2616">第一次修订 1999年 rfc2616</a></li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7230">第二次修订 2014年 rfc7230</a> (想要详细了解HTTP协议编码可以看这个)</li><li><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7235">第三次修订 2014年 rfc7235</a></li></ol><h3 id="2-服务端优化手段"><a href="#2-服务端优化手段" class="headerlink" title="2. 服务端优化手段"></a>2. 服务端优化手段</h3><h4 id="1-keep-alive"><a href="#1-keep-alive" class="headerlink" title="1. keep-alive"></a>1. keep-alive</h4><p>引入keep-alive 可以有效的降低了TCP建立连接的开销（包含TCP握手和TCP慢启动，其实TCP一开始窗口挺大的，默认14KB），其次就是有效的降低了系统开销，如TCP连接数等！</p><p>在HTTP/1.0中默认是关闭开启 <code>keep-alive</code> 的，必须在请求头部添加<code>Connection: keep-alive</code>才可以；但是在HTTP/1.1中默认是开启<code>keep-alive</code>，需要在响应头加入<code>Connection: close</code>才可以关闭！下图是两者的差异：</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/a5bd728da53241fbbd192a8810141408.svg" alt="连接复用"></p><p>但是也会存在很多问题，原来是请求-&gt;响应直接关闭连接很容易拆包，但是出现了连接复用，那么如何拆包呢？HTTP/1.x中如果我们开启了<code>keep-alive</code>必须在请求头和响应头中加入<code>content-length</code>来标识请求体/响应体的大小！（chunked传输编码除外）</p><ol><li>测试</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> HTTP/1.1，下图为HTTP/1.1的抓包图</span></span><br><span class="line">curl  --url http://localhost:8888/api/test/req1     --url http://localhost:8888/api/test/req2   --data-raw &#x27;hello world&#x27; -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> HTTP/1.0</span></span><br><span class="line">curl  --url http://localhost:8888/api/test/req1     --url http://localhost:8888/api/test/req2   --data-raw &#x27;hello world&#x27;  -H &#x27;Connection: keep-alive&#x27; --http1.0 -v</span><br></pre></td></tr></table></figure><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/0f831b3e675b450690ed6cd39ad28356.png" alt="连接复用"></p><ol start="3"><li>关于如何实现HTTP的 keep-alive，一般server端设置读超时即可，client端维护就比较麻烦，可以阅读一些源码看一下即可，其次就是用的连接池！</li><li>目前字节内部的TLB做代理的时候维护单个请求连接的时间过长，导致连接不会被销毁，也就是经常会出现后端服务（up stream）出现大量的 TCP <code>ESTABLISHED</code> ，其主要原因也是因为client侧不断开连接，server侧一般也不会直接断开，这也就是为什么后面HTTP/2做了自己的keep-alive机制了！</li><li>keep-alive 另外还是额外的两个配置，一个是 timeout 一个是max，例如<code>Keep-Alive: timeout=5, max=1000</code> ， 具体可以看： <a target="_blank" rel="noopener" href="https://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html#rfc.section.2">https://tools.ietf.org/id/draft-thomson-hybi-http-timeout-01.html </a>！可以参考<a target="_blank" rel="noopener" href="https://skyao.io/learning-nginx/docs/configure/keepalive/action.html">Nginx的实现</a>!</li><li>如果响应头里申明 <code>Connection=close</code> ，则会关闭连接！</li></ol><h4 id="2-请求体压缩"><a href="#2-请求体压缩" class="headerlink" title="2. 请求体压缩"></a>2. 请求体压缩</h4><p>一般压缩是根据 <code>Content-Encoding</code> 进行区分Body体使用哪种压缩方式，请求的时候会携带<code>Accept-Encoding</code>来标识支持的压缩方式！ 常见就是 <code>gzip</code>、<code>tr</code>、<code>deflate</code> 压缩，字节内部也有一些压缩率比较高的压缩算法，比如 <code>ttzip</code> 基于zstd优化后的！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /api/test HTTP/1.1</span><br><span class="line">Host: localhost:8888</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Date: Wed, 11 May 2022 14:39:27 GMT</span><br><span class="line">Content-Length: 343</span><br><span class="line"></span><br><span class="line">...............!...Y..@.....[Z...........b......zP.1&#125;.JjFKw.......g....oO.Z......./.	OXwJ..S..%.......7...F3.pF.|B.*....E.-o..ObpT2..6J..5.S....0.u.R.&#x27;Ce....,.......&gt;C..(|.8D=.:_...X..$.=....l..1..m.P..s.%.....s....)T.wiyN9_^p.|la@.D/.t.@.&gt;...._/$..=Sz&#125;k.O.......Al..m...j......M..,. ..:g...:.6Q.......T..c..z..jU...u...jWn.J</span><br><span class="line">..N.?............</span><br></pre></td></tr></table></figure><h4 id="3-Chunked-编码（分块传输）"><a href="#3-Chunked-编码（分块传输）" class="headerlink" title="3. Chunked 编码（分块传输）"></a>3. <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7230#section-4.1">Chunked 编码</a>（分块传输）</h4><p>分块编码是HTTP/1.1新增的传输报文格式，响应会携带<code>Transfer-Encoding: chunked</code>，其次响应体是不会有<code>content-length</code>的，因为chunked编码长度部分记录在一个 16进制编码单独的文本行上，然后再写响应内容，如果仍然有内容继续重复操作即可！终止符是 <code>0\r\n\r\n</code>！下图是chunked编码的抓包图，其中<code>12</code>其实表示<code>0x12</code>也就是为十进制的<code>18</code>!</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-11/624a4c01125645a7844a6797a25f6c54.png" alt="image-20220511232658487"></p><p>使用场景: 其中分块编码可以节约用户首屏加载时间，先加载一部分渲染！实际业务中可以做一些 实时进度条展示、日志展示、流式拉取、大文件传输等！比如抖音的首屏预测方案就是基于chunked编码实现的，具体可以看文章尾部的参考文章！</p><p><strong>注意1:</strong> 假如你使用Go语言默认HTTP Server，当响应体大于2KB的时候就会默认升级为 chunked 编码！你也可以手动添加响应header <code>Transfer-Encoding: chunked</code>!</p><p><strong>注意2：</strong>对于L7 Proxy来说，chunked编码处理不得当很可能造成业务的OOM，所以可以参考一些chunked包转发和抓取的优化手段，尽可能的降低内存拷贝次数和维护的buffer大小！</p><p>上面第二、第三节讲完了，可以发现会存在两个Header， <code>Content-Encoding</code> 和 <code>Transfer-Encoding</code>， 这里可以根据句面意思，可以知道 <code>Content-Encoding</code> 是表示内容编码格式，<code>Transfer-Encoding</code> 表示传输格式！ 两者是可以同时使用的！</p><h3 id="3-前端（浏览器）优化手段"><a href="#3-前端（浏览器）优化手段" class="headerlink" title="3. 前端（浏览器）优化手段"></a>3. 前端（浏览器）优化手段</h3><h4 id="1-合并资源"><a href="#1-合并资源" class="headerlink" title="1. 合并资源"></a>1. 合并资源</h4><p>合并资源这个我理解大部分都或多多少的了解过，因为请求3个资源的耗时一般都会大于合并成一个资源的请求耗时！例如前端也有很多静态资源（js/css）的打包工具，比如webpack、gulp 等资源合并工具！其次一些小的Image可以使用精灵图！</p><p>这个东西有利也有弊端，比如我原来20个文件，合并成了一个，我改动一个，那么全部资源都是需要重新reload，浏览器缓存的效果就丢失了，不过这个目前也有解决方案！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/e5e1dcd5f58449c3908c54cf9e536bd1.png" alt="img"></p><h4 id="2-域名分片"><a href="#2-域名分片" class="headerlink" title="2. 域名分片"></a>2. 域名分片</h4><p>浏览器其实有同域名请求的最大并发数限制，例如主流的浏览器Chrome 其实会对于同域名下最大并发数限制在6个！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/3dd8cdf0995043a0af946a2e0bc8f6a8.png" alt="img"></p><p>域名分片就是讲一个域名划分为多个，比如 <a target="_blank" rel="noopener" href="http://www.google.com/">www.google.com</a>, <a target="_blank" rel="noopener" href="http://www.gstatic.com/">www.gstatic.com</a>, 这样就可以很好的解决浏览器的限制！</p><h4 id="3-管道化"><a href="#3-管道化" class="headerlink" title="3. 管道化"></a>3. 管道化</h4><p>下图是使用管道化和未使用的差别，可以发现他可以解决http/1.x 请求阻塞，但是并不能解决响应阻塞的问题！这个主要还是由于服务端HTTP请求处理是串行的！注意只有<strong>支持幂等的请求</strong>且开启keep-alive才会支持管道化！其次这个技术主要在浏览器侧实现！但是由于keep-alive持久连接实现上并不可靠，所以管道化也需要支持重试等，所以这也就是为什么只允许幂等请求了！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-11/2b7c075406d241939a0b00cfd872bb2a.jpeg" alt="管道化连接"></p><h4 id="4-长连接"><a href="#4-长连接" class="headerlink" title="4. 长连接"></a>4. 长连接</h4><p>​ 这个放在这里，感觉也不合理，主要是目前也存在这种场景，比如在线编辑、在线聊天等一些在线软件对于实时性要求比较高，轮训的话也不太好，因为HTTP建连开销比较大，其次对于服务器压力也比较大（比如无效的请求，类似于空转），所以在这条路上诞生了很多的技术，这里我们这里就简单介绍下WebSocket！</p><p>​ WebSocket是HTML5开始提供的一种在单个TCP连接上进行全双工通讯的协议，位于OSI模型的应用层。WebSocket协议在2008年诞生，于2011年由IETF标准化为 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6455">RFC 6455</a> ，后由 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7936">RFC 7936</a> 补充规范。</p><p>注意：WebSocket 和 HTTP同为应用层协议！WebSocket是利用HTTP协议进握手的！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/4767f9839bf347218b63d0d8b7a6ba3c.awebp" alt="img"></p><h3 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4. 注意点"></a>4. 注意点</h3><h4 id="1-网关方向"><a href="#1-网关方向" class="headerlink" title="1. 网关方向"></a>1. 网关方向</h4><p>上诉我们讲的可能是偏向于业务方面一些技巧，对于网关/LB来说，往往在HTTP链路中担任着一个代理角色，那么代理就会涉及到一个问题，我要代理哪些东西，哪些东西不可代理！</p><ol><li>Hop-by-hop headers (点到点)</li></ol><p>具体可以见 <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7230.txt%EF%BC%8C">https://www.rfc-editor.org/rfc/rfc7230.txt，</a> 大概描述了逐级跳的时候一个 header 是不能传递的！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Connection</span><br><span class="line">Proxy-Connection</span><br><span class="line">Keep-Alive</span><br><span class="line">Proxy-Authenticate</span><br><span class="line">Proxy-Authorization</span><br><span class="line">Te</span><br><span class="line">Trailer</span><br><span class="line">Transfer-Encoding</span><br><span class="line">Upgrade</span><br></pre></td></tr></table></figure><p>上诉这些header 主要是和协议有关，其中不少网关直接不支持上诉功能代理，</p><ul><li>比如 Transfer-Encoding=chunked，很多业务使用chunked编码进行分段传输，来实现单向长链接，但是可能经过网关后会remove掉这个传输协议，因此使用 chunked很可能在网络传输某个节点丢失了<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc7230.html#section-4.1.1">frc-4.1.1</a> . 所以很多业务会自定义 chunked编码，向字节内部就开发了一个Next-Chunked编码解决传输过程中 chunked 分段编码丢失问题.（本质上就是在payload中进行分段）</li><li>Connection、Keep-Alive 等都是一些连接复用优化策略，本质上上下游并不可信，对于连接.</li><li>其次还有一些Header，比如Upgrade用作协议切换，也是不可以进行透传的。</li></ul><ol start="2"><li>End-to-End （端到端）</li></ol><p>就是很常见的业务header</p><ol start="3"><li>正向代理</li></ol><p>主要是代理客户端（Client）请求，例如VPN、抓包工具、匿名访问、提高访问速度 等</p><blockquote><p>是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互，目标服务器是不知道真正的客户端是谁的</p></blockquote><ol start="4"><li>反向代理</li></ol><p>主要是代理服务端（Server）端请求，例如LB</p><blockquote><p>是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互，客户端是不知道真正的目标服务器是谁的</p></blockquote><p>参考: <a target="_blank" rel="noopener" href="https://oxylabs.cn/blog/reverse-proxy-vs-forward-proxy">https://oxylabs.cn/blog/reverse-proxy-vs-forward-proxy</a></p><h4 id="2-form-data-编码-body篡改"><a href="#2-form-data-编码-body篡改" class="headerlink" title="2. form-data 编码 (body篡改)"></a>2. form-data 编码 (body篡改)</h4><p>这里我申明一个名词(透明代理)，在实际业务中往往会存在一个问题，就是客户端+服务端传输的时候会进行一个 body/header加密+checksum来防止被篡改(checksum往往会使用加密防止中途被篡改)，这种case非常场景.</p><p>那么这里就有一个问题了，form-data 在很多应用中会很容易出现丢失header信息和乱序.具体关于 form-data编码可以看 <a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc2046#section-5.1">rfc2056</a></p><p>所以透明代理往往是不会修改整体的http请求报文，例如正向代理中的抓包，就充当了一个透明代理，它并不会修改你的流量，其实就是不会修改应用层流量（这里主要指的是代理抓包，仅作为4层代理，其实也不是病不能称为4层）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/test/codec?ce=gzip&amp;te=chunked HTTP/1.1</span><br><span class="line">Host: xxx-xx.xxx.net</span><br><span class="line">User-Agent: curl/7.77.0</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 413</span><br><span class="line">Content-Type: multipart/form-data; boundary=------------------------8ca4ceae80dc1105</span><br><span class="line"></span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test2.log&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">hello world1</span><br><span class="line">hello world2</span><br><span class="line"></span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;k1&quot;</span><br><span class="line"></span><br><span class="line">v1</span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;k2&quot;</span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line">--------------------------8ca4ceae80dc1105--</span><br></pre></td></tr></table></figure><p>乱序后 可能会出现:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">POST /api/v1/test/codec?ce=gzip&amp;te=chunked HTTP/1.1</span><br><span class="line">User-Agent: curl/7.77.0</span><br><span class="line">Host: xxx-xx.xxx.net</span><br><span class="line">Content-Type: multipart/form-data; boundary=------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Length: 413</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;k1&quot;</span><br><span class="line"></span><br><span class="line">v1</span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;k2&quot;</span><br><span class="line"></span><br><span class="line">v2</span><br><span class="line">--------------------------8ca4ceae80dc1105</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;test2.log&quot;</span><br><span class="line">Content-Type: application/octet-stream</span><br><span class="line"></span><br><span class="line">hello world1</span><br><span class="line">hello world2</span><br><span class="line"></span><br><span class="line">--------------------------8ca4ceae80dc1105--</span><br></pre></td></tr></table></figure><h4 id="3-流式传输"><a href="#3-流式传输" class="headerlink" title="3. 流式传输"></a>3. 流式传输</h4><ol><li>有些应用使用 长轮训 ，代理层会读超时</li><li>有些应用使用 分段传输，代理层会读取全部数据后再传输 （为了安全限制读取的最大size，除非支持转发chunked编码）</li></ol><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>根据上诉描述，所以我们发现做一款优秀的HTTP代理工具，并不是简简单单的一件事情，需要很深入的了解HTTP协议的细节，以及尽可能的满足业务需求，所以优秀的HTTP代理工具，比如apache，nginx等都是不断的迭代和满足业务现状！所以现在一般都是 通用型代理工具 + 偏向于特定业务场景的代理工具！</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>这个并不是HTTP协议，只是在HTTP发展路上遇到的问题，随着互联网发展，越来越多的人注意到数据安全，比如用户敏感信息需要加密，一些恶意软件的攻击，以及恶意拦截等！所以HTTPS就诞生了！这里我们只是引入而已，不会深入讲解！HTTPS（Hypertext Transfer Protocol Secure） 是 HTTP 协议外面包裹了一层 TLS/SSL！</p><p>SSL（Secure Sockets Layer，安全套接字层），它是由网景公司(Netscape)设计的主要用于Web的安全传输协议，目的是为网络通信提供机密性、认证性及数据完整性保障。如今，SSL已经成为互联网保密通信的工业标准。SSL最初的几个版本(SSL 1.0、SSL2.0、SSL 3.0)由网景公司设计和维护，从3.1版本开始，SSL协议由因特网工程任务小组(IETF)正式接管，并更名为<strong>TLS</strong>(Transport Layer Security)，发展至今已有TLS 1.0、TLS1.1、TLS1.2、TLS1.3 这几个版本。</p><p>如TLS名字所说，SSL/TLS协议仅保障传输层安全。同时，由于协议自身特性(数字证书机制)，SSL/TLS不能被用于保护多跳(multi-hop)端到端通信，而只能保护点到点通信。</p><p>SSL/TLS发展历程如下图：</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/3941fac3371f4a97be5a98efff98a38a.jpeg" alt="img"></p><table><thead><tr><th align="left">协议</th><th align="left">使用情况</th></tr></thead><tbody><tr><td align="left">SSLv3.0以下</td><td align="left">有安全问题，且已被废弃，不建议使用</td></tr><tr><td align="left">TLSv1.0/v1.1</td><td align="left">过渡版本，不建议使用</td></tr><tr><td align="left">TLSv1.2</td><td align="left">目前绝大多数都在使用</td></tr><tr><td align="left">TLSv1.3</td><td align="left">最新的更快更安全的协议（变更最大的一次协议，可以实现1RTT）</td></tr></tbody></table><p>其次TLS加解密会非常的消耗CPU，其次加密也会额外消耗带宽，不过主要开销都在TLS握手这块，因为现在主流CPU都会对常见加密算法做硬件加速，所以传输过程中数据包这块开销不大！目前一般内网都会卸载掉TLS！其次TLS握手过程也会很长，主要包含证书认证和确认加密算法！其中TLS发展过程中也经历了不断的迭代，发展方向主要是为了更加安全、效率更高！下图是现在主流TLSv1.2的握手流程，相比于裸TCP，会多两倍的时间开销！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/19bc2a57f8964c51af397a92871ab7a6.png" alt="TLS 握手"></p><p>注: TLS握手中很多流程是可选的，上图并不完全正确，其次就是还会分为全完握手和简化握手！</p><p>对于TLS来说也是一个协议规范，具体我们在使用的过程中需要在应用程序中设置或者需要程序来支持！常见开源实现主要有 <a target="_blank" rel="noopener" href="https://github.com/openssl/openssl">OpenSSL</a>（主流）、JSSE（Java版实现）、NSS（浏览器中广泛使用），下图是些常见软件以及它们所使用的SSL/TLS开源实现的情况！对于安全（TLS/SSL）来说也是不断在进步中，同时也有漏洞不断挖出！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/9bcfc85ff30343d595c7297d01b14551.jpg" alt="enter image description here"></p><h2 id="HTTP-2-amp-HTTP-3"><a href="#HTTP-2-amp-HTTP-3" class="headerlink" title="HTTP/2  &amp; HTTP/3"></a>HTTP/2 &amp; HTTP/3</h2><p>随着近20年来互联网的高速发展，页面愈加复杂，有些甚至演变成了独立的应用，一个页面会加载大量的资源，增进交互的脚本大小也增加了许多，更多的数据通过HTTP请求被传输。HTTP/1.1链接需要请求以正确的顺序发送，理论上可以用一些并行的链接，带来的成本和复杂性堪忧。比如，HTTP管线化（pipelining）就成为了Web开发的负担。</p><p>在2009年到2015年，谷歌通过实践了一个实验性的SPDY协议（2011年Google的全部服务就添加了SPDY），证明了一个在客户端和服务器端交换数据的另类方式。其收集了浏览器和服务器端的开发者的焦点问题。明确了响应数量的增加和解决复杂的数据传输，SPDY成为了HTTP/2协议的基础。在2015年5月HTTP/2正式标准化后，取得了极大的成功！目前来看SPDY已经完全被HTTP/2所取代！然后Google其实早起已经对于TCP做了优化，叫做QUIC，所以就考虑把HTTP运行在QUIC上，于是诞生了后面的HTTP/3！</p><p>HTTP/2 相比HTTP/1.1 比较最大的特点就是多路复用，有点类似于我们web server由HTTP服务升级为RPC服务，带来的提升！从浏览器视角看的话，下图是169张图渲染一张图浏览器加载的耗时，结果是HTTP/2 为1.53s， HTTP1.1为 2.47s！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-12/ab103cb9dffd42e0a226b95f1aa8bdc3.gif" alt="img"></p><h1 id="HTTP-2-介绍"><a href="#HTTP-2-介绍" class="headerlink" title="HTTP/2 介绍"></a>HTTP/2 介绍</h1><h2 id="主要特性"><a href="#主要特性" class="headerlink" title="主要特性"></a>主要特性</h2><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-22/3480e65e624e475bba7f66ca4ea8bca2.png" alt="img"></p><ul><li>二进制协议 (frame帧)</li><li>多路复用 (stream 流)</li><li>流量控制</li><li>数据流优先级</li><li>首部压缩（HPACK）</li><li>服务端推送 （Push）</li></ul><p>虽然有这么多特性，对于HTTP的语义来说，其实并没有太大的变更！</p><h2 id="理解流"><a href="#理解流" class="headerlink" title="理解流"></a>理解流</h2><p>对于HTTP/1.x协议来说一个连接上的请求、响应是串行的处理，但是HTTP/2引入流的概念，<strong>把请求、响应的过程抽象成流，一个连接上可以有多个流，把数据包抽象成帧，帧在建立的连接上传输</strong>！</p><p>一个流的生命周期只是一次请求、响应，<strong>不存在复用（即另外一个请求不能复用之前的流，关闭即销毁）</strong>，具体可以看流的生成周期！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-22/f7cf22543e7549569cd23329ecc50952.png"></p><h3 id="流的生命周期"><a href="#流的生命周期" class="headerlink" title="流的生命周期"></a>流的生命周期</h3><ol><li>下图是一个状态机，对于<strong>一个普通的请求、响应</strong>来说，一般经历有四个阶段</li></ol><ul><li>空闲(idle): 这里可以理解为初始化一个stream后的状态，这个状态可以理解为很短！</li><li>开启(open) : 当客户端开始写header的时候（包含服务端读header），会流转到这个状态！ 这里也就是</li><li>半关闭状态(half closed): 客户端写完数据，发送<code>END_STREAM</code> flags时（写完请求时）就会变成这个状态，<strong>此时客户端的流不能再写数据</strong>！对于服务端而言就是收到客户端发送的<code>END_STREAM</code> flags，就处于此状态！</li><li>关闭(closed): 对于客户端而言，收到服务端响应发来的<code>END_STREAM</code> 会变为此状态；对于服务器而言发送<code>END_STREAM</code> 也会变为此状态！</li></ul><ol start="2"><li>只要客户端、服务端发送或者接收到 <code>RST_STREAM 帧</code>时就会直接变为 <code>closed</code> 状态！</li><li>对于服务端推送来说我们后文会讲到！</li><li><a target="_blank" rel="noopener" href="https://grpc.io/docs/what-is-grpc/core-concepts/#bidirectional-streaming-rpc">GRPC双向流（stream msg）</a>实现原理其实也就是一个普通的请求、响应模型，根据上面四个阶段也能大概了解它是如何实现的！即客户端发完请求并没有直接发送 <code>END_STREAM</code>，而是一直处于open状态，且服务端也是！只有客户端/服务端主动关闭才可以关闭stream，或者双方通过自定义协议约定才可以！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">                         +--------+</span><br><span class="line">                 send PP |        | recv PP</span><br><span class="line">                ,--------|  idle  |--------.</span><br><span class="line">               /         |        |         \</span><br><span class="line">              v          +--------+          v</span><br><span class="line">       +----------+          |           +----------+</span><br><span class="line">       |          |          | send H /  |          |</span><br><span class="line">,------| reserved |          | recv H    | reserved |------.</span><br><span class="line">|      | (local)  |          |           | (remote) |      |</span><br><span class="line">|      +----------+          v           +----------+      |</span><br><span class="line">|          |             +--------+             |          |</span><br><span class="line">|          |     recv ES |        | send ES     |          |</span><br><span class="line">|   send H |     ,-------|  open  |-------.     | recv H   |</span><br><span class="line">|          |    /        |        |        \    |          |</span><br><span class="line">|          v   v         +--------+         v   v          |</span><br><span class="line">|      +----------+          |           +----------+      |</span><br><span class="line">|      |   half   |          |           |   half   |      |</span><br><span class="line">|      |  closed  |          | send R /  |  closed  |      |</span><br><span class="line">|      | (remote) |          | recv R    | (local)  |      |</span><br><span class="line">|      +----------+          |           +----------+      |</span><br><span class="line">|           |                |                 |           |</span><br><span class="line">|           | send ES /      |       recv ES / |           |</span><br><span class="line">|           | send R /       v        send R / |           |</span><br><span class="line">|           | recv R     +--------+   recv R   |           |</span><br><span class="line">| send R /  `-----------&gt;|        |&lt;-----------&#x27;  send R / |</span><br><span class="line">| recv R                 | closed |               recv R   |</span><br><span class="line">`-----------------------&gt;|        |&lt;----------------------&#x27;</span><br><span class="line">                         +--------+</span><br><span class="line"></span><br><span class="line">   send:   endpoint sends this frame</span><br><span class="line">   recv:   endpoint receives this frame</span><br><span class="line"></span><br><span class="line">   H:  HEADERS frame (with implied CONTINUATIONs)</span><br><span class="line">   PP: PUSH_PROMISE frame (with implied CONTINUATIONs)</span><br><span class="line">   ES: END_STREAM flag</span><br><span class="line">   R:  RST_STREAM frame</span><br></pre></td></tr></table></figure><h2 id="如何建立HTTP-2连接"><a href="#如何建立HTTP-2连接" class="headerlink" title="如何建立HTTP/2连接"></a>如何建立HTTP/2连接</h2><p>首先建立连接需要客户端和服务端都支持HTTP/2协议，才可以使用HTTP/2！</p><h3 id="使用HTTPS协商-h2"><a href="#使用HTTPS协商-h2" class="headerlink" title="使用HTTPS协商 (h2)"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-3.1">使用HTTPS协商 (h2)</a></h3><p>例如下面这个curl 请求其实是模拟了一个使用HTTPS发送HTTP/2 协议的请求</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl --http2 https://www.toutiao.com/ -v -o s/dev/null</span><br><span class="line">*   Trying 240e:b1:9801:407:3::3f6:443...</span><br><span class="line">* Connected to www.toutiao.com (240e:b1:9801:407:3::3f6) port 443 (<span class="comment">#0)</span></span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line">* successfully <span class="built_in">set</span> certificate verify locations:</span><br><span class="line">*  CAfile: /etc/ssl/cert.pem</span><br><span class="line">*  CApath: none</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client hello (1):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server hello (2):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Certificate (11):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server key exchange (12):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Server finished (14):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Client key exchange (16):</span><br><span class="line">* TLSv1.2 (OUT), TLS change cipher, Change cipher spec (1):</span><br><span class="line">* TLSv1.2 (OUT), TLS handshake, Finished (20):</span><br><span class="line">* TLSv1.2 (IN), TLS change cipher, Change cipher spec (1):</span><br><span class="line">* TLSv1.2 (IN), TLS handshake, Finished (20):</span><br><span class="line">* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256</span><br><span class="line">* ALPN, server accepted to use h2</span><br><span class="line">* Server certificate:</span><br><span class="line">*  subject: CN=*.toutiao.com</span><br><span class="line">*  start date: Jul 23 00:00:00 2021 GMT</span><br><span class="line">*  expire date: Aug 23 23:59:59 2022 GMT</span><br><span class="line">*  subjectAltName: host <span class="string">&quot;www.toutiao.com&quot;</span> matched cert<span class="string">&#x27;s &quot;*.toutiao.com&quot;</span></span><br><span class="line"><span class="string">*  issuer: C=US; O=DigiCert Inc; CN=RapidSSL TLS DV RSA Mixed SHA256 2020 CA-1</span></span><br><span class="line"><span class="string">*  SSL certificate verify ok.</span></span><br><span class="line"><span class="string">* Using HTTP2, server supports multi-use</span></span><br><span class="line"><span class="string">* Connection state changed (HTTP/2 confirmed)</span></span><br><span class="line"><span class="string">* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0</span></span><br><span class="line"><span class="string">* Using Stream ID: 1 (easy handle 0x7f7d21011e00)</span></span><br><span class="line"><span class="string">&gt; GET / HTTP/2</span></span><br><span class="line"><span class="string">&gt; Host: www.toutiao.com</span></span><br><span class="line"><span class="string">&gt; user-agent: curl/7.77.0</span></span><br><span class="line"><span class="string">&gt; accept: */*</span></span><br><span class="line"><span class="string">&gt;</span></span><br><span class="line"><span class="string">* Connection state changed (MAX_CONCURRENT_STREAMS == 128)!</span></span><br><span class="line"><span class="string">&lt; HTTP/2 200</span></span><br><span class="line"><span class="string">&lt; server: Tengine</span></span><br><span class="line"><span class="string">&lt; content-type: text/html</span></span><br><span class="line"><span class="string">&lt; content-length: 72772</span></span><br><span class="line"><span class="string">&lt; date: Sun, 15 May 2022 10:30:06 GMT</span></span><br><span class="line"><span class="string">.... </span></span><br></pre></td></tr></table></figure><p>上面我们只需要核心关注</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">## ALPN客户端支持列表</span><br><span class="line">* ALPN, offering h2</span><br><span class="line">* ALPN, offering http/1.1</span><br><span class="line"></span><br><span class="line">## 服务端选择</span><br><span class="line">* ALPN, server accepted to use h2</span><br></pre></td></tr></table></figure><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/5212c3fe29db4d688dde9076d1b69d15.png" alt="image-20220515190856591"></p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/e520970d98f8466d8bb5070f3ecd9a3b.png" alt="image-20220515190951767"></p><p>这里其实利用了TLS的 ALPN (<strong>Application-Layer Protocol Negotiation</strong> 应用层协议协商) 扩展字段以及识别 HTTP/2 over TLS ！其中HTTP/2 就是 ALPN 最佳实践！</p><p>其中原理就是ALNP给Client hello 和 Server hello 消息加了个拓展功能，客户端可以来申明我支持的应用层协议（嗨，我支持h2和http/1，你用哪个都行），服务端可以用它来确认在HTTPS协商后的应用层协议（好吧，我们用h2吧）！</p><p>更多ALPN可以参考文章: <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7301#section-3">https://datatracker.ietf.org/doc/html/rfc7301#section-3</a> ！</p><p>另外其实在 ALPN 协议之前，有一个NPN（<strong>Next Protocol Negotiation</strong> 下一代协议协商）其实作用和ALPN一样，但是呢过程不一样，其中我这里直接拍照吧，就是它分为三步，选择权利在客户端，其中选择的协议是加密的！所以这么一看其实NPN更加安全可靠！但是想一想增加这几步有必要吗？其实没有必要，所以ALPN成为了规范！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/3fe1b5f6448749439b938b9666795ecc.jpg" alt="741652615070_.pic_hd_副本"></p><p>本图片引用自 <a target="_blank" rel="noopener" href="https://www.manning.com/books/http2-in-action">&lt;HTTP/2 in Action&gt;</a>, 有兴趣可以看一下！</p><p>注意这里有一种情况就是假如服务器不支持HTTP2但是客户端支持，那么根据上面流程选择HTTP/1.1就可以了，例如下面这个图，最后选择的是<code>HTTP/1.1</code>。</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-15/7d52fb82945b4505a5842d77c4afbdbb.png" alt="image-20220515191823499"></p><p>但是还有一种情况就是如果 <code>server hello</code>中不返回ALNP，比如举个例子服务端TLS版本过低不支持ANLP，所以此时目前大部分浏览器做法就是默认降级成HTTP/1.1！具体可以看：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/47758705/http-2-h2-with-no-alpn-support-in-server">https://stackoverflow.com/questions/47758705/http-2-h2-with-no-alpn-support-in-server</a>！</p><p>注意: 上面讲诉的过程是基于TLS/1.2的，其中1.3会有部分差异！其次就是h2建立要求最低TLS/v1.2版本！</p><h3 id="使用-h2c-协商"><a href="#使用-h2c-协商" class="headerlink" title="使用 h2c 协商"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-3.2">使用 h2c 协商</a></h3><p>我们知道HTTP协议是可以做协议协商的，那么h2c的建立流程和这个大同小异！目前h2c的主要使用场景就是后端服务希望HTTP/2来带来性能提升，而且大部分场景也不需要tls加密，所以h2c就诞生了！</p><p>注意h2c 有两种实现，一种是基于HTTP/1.1协议升级，一种就是h2的流程但是移除了tls！</p><h4 id="1-方式一-HTTP-1-1升级"><a href="#1-方式一-HTTP-1-1升级" class="headerlink" title="1. 方式一(HTTP/1.1升级)"></a>1. 方式一(HTTP/1.1升级)</h4><blockquote><p>目前主流浏览器都不支持h2c，所以这个基本上没办法测试，如果想要测试可以看一下我写的测试用例: <a target="_blank" rel="noopener" href="https://github.com/Anthony-Dong/grpc-go/blob/dev/examples/route_guide/h2c_example/h2c_client/main.go">h2c_example</a></p></blockquote><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/41904c06c44c4e35b5c4e35b2ab751ac.png" alt="img"></p><ol><li>浏览器发起请求</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Connection: Upgrade, HTTP2-Settings</span><br><span class="line">Upgrade: h2c</span><br><span class="line">HTTP2-Settings: &lt;base64url encoding of HTTP/2 SETTINGS payload&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>如果服务端支持则会响应如下报文，如果不支持正常返回即可！其中下面可以看到会携带 HTTP/2首帧！这里后面会讲解！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br><span class="line"></span><br><span class="line">[ HTTP/2 connection ...</span><br></pre></td></tr></table></figure><ol start="3"><li>关于 <code>HTTP2-Settings</code> 需要了解HTTP/2涉及到的基本概念，一个核心的就是 <code>SETTTINGS 帧</code>, 必须在建连的时候发送，这个header也就是 <code>SETTTINGS 帧</code> 的内容，理解这个就很简单了，它本质上就是把 <code>SETTTINGS 帧</code> base64编码了一下！用于发送客户端建立的初始化设置！</li><li><code>[ HTTP/2 connection ...</code> 后续流程是客户端会先发送连接前奏、但是不需要发送<code>SETTINGS帧</code>了，其他就和h2流程差不多！</li><li>这里我们不能抓包了，所以直接看我写的测试用例输出吧</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  h2c_client git:(master) ✗ go run main.go</span><br><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: h2c</span><br><span class="line"></span><br><span class="line">[FrameHeader SETTINGS len=24]</span><br><span class="line">[FrameHeader WINDOW_UPDATE len=4]</span><br><span class="line">[FrameHeader HEADERS flags=END_HEADERS stream=1 len=49]</span><br><span class="line">[FrameHeader DATA flags=END_STREAM stream=1 len=12]</span><br><span class="line">[FrameHeader RST_STREAM stream=1 len=4]</span><br></pre></td></tr></table></figure><h4 id="2-方式二-h2c"><a href="#2-方式二-h2c" class="headerlink" title="2. 方式二(h2c)"></a>2. 方式二(h2c)</h4><p>这种是grpc(without tls)采用的方式，就是我们已经知道对面是HTTP/2服务器了，所以不需要使用<code>h2c</code>那种通过 <code>http/1.1</code>升级为<code>http/2</code>这个流程！它的过程和<code>h2</code>的过程一模一样！ 具体可以自行抓包查看！</p><h2 id="帧介绍"><a href="#帧介绍" class="headerlink" title="帧介绍"></a>帧介绍</h2><p>下图是一个HTTP2 over https（h2） 的整个流程，可以看到HTTP2 主要包含有几个特殊标识</p><ul><li>Magic</li><li>Settings</li><li>Windows_Update</li><li>Headers</li><li>Data</li></ul><p>那么我们下面会依次介绍！我们把这些都成为帧，这些帧都有着不同的作用！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a8a6be83ac5b46adae39367c9aee772b.png" alt="image-20220518225330778"></p><p>如果你用 nghttp2, 可以执行以下命令： <code>nghttp -vo https://www.toutiao.com | more</code></p><h3 id="连接前奏"><a href="#连接前奏" class="headerlink" title="连接前奏"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-3.5">连接前奏</a></h3><p>根据上图可以看到在 h2 或者 h2c 升级完成，下面紧接着就跟着一个 <code>连接前奏</code>（客户端向服务端发送的），这个内容是固定的，主要是有24个字节组成，16进制标识法如下，展示成字符串就是 <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code> !</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000   50 52 49 20 2a 20 48 54 54 50 2f 32 2e 30 0d 0a   PRI * HTTP/2.0..</span><br><span class="line">0010   0d 0a 53 4d 0d 0a 0d 0a                           ..SM....</span><br></pre></td></tr></table></figure><p>注意: 具体这么设计的原因也是有的，比如向一个不支持HTTP2的服务器（HTTP/1.x）接收到这个报文，是可以正常解析为HTTP请求报文的，如果不支持就直接返回异常不支持了！</p><h3 id="帧格式介绍"><a href="#帧格式介绍" class="headerlink" title="帧格式介绍"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-4">帧格式介绍</a></h3><p><code>连接前奏</code>紧跟着就是 <code>SETTINGS 帧</code>了, 下图就是一个<code>HTTP SETTINGS 帧</code>的报文。在这里我们先补充体下帧的报文格式，也方便后续的理解！这也就是为什么HTTP/2是二进制协议了，同时也能避免HTTP/1.x协议通过纯文本等进行协议分帧的尴尬了！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a3a70bc84a634f6f949737c3cee43a16.png" alt="image-20220518230410699"></p><p>帧报文如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 帧格式, 头部固定9字节, 所以 9+ bytes:</span></span><br><span class="line">+-----------------------------------------------+</span><br><span class="line">|                 Length (24)                   |</span><br><span class="line">+---------------+---------------+---------------+</span><br><span class="line">|   Type (8)    |   Flags (8)   |</span><br><span class="line">+-+-------------+---------------+-------------------------------+</span><br><span class="line">|R|                 Stream Identifier (31)                      |</span><br><span class="line">+=+=============================================================+</span><br><span class="line">|                   Frame Payload (0...)                      ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Length</code>: 固定为3字节，所以帧最大长度为 <code>1 &lt;&lt; 24 -1</code> ， 注意这个长度=<code>len(frame_content)</code></li><li><code>Type</code>: 即帧的类型，主要分为以下几种，例如 <code>SETTINGS帧</code>就是 <code>0x04</code>，其中这个类型目前仍然在不断拓展中！常见的就是这9种！</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+---------------+------+--------------+</span><br><span class="line">| Frame Type    | Code | Section      |</span><br><span class="line">+---------------+------+--------------+</span><br><span class="line">| DATA          | <span class="number">0x0</span>  | Section <span class="number">6.1</span>  |</span><br><span class="line">| HEADERS       | <span class="number">0x1</span>  | Section <span class="number">6.2</span>  |</span><br><span class="line">| PRIORITY      | <span class="number">0x2</span>  | Section <span class="number">6.3</span>  |</span><br><span class="line">| RST_STREAM    | <span class="number">0x3</span>  | Section <span class="number">6.4</span>  |</span><br><span class="line">| SETTINGS      | <span class="number">0x4</span>  | Section <span class="number">6.5</span>  |</span><br><span class="line">| PUSH_PROMISE  | <span class="number">0x5</span>  | Section <span class="number">6.6</span>  |</span><br><span class="line">| PING          | <span class="number">0x6</span>  | Section <span class="number">6.7</span>  |</span><br><span class="line">| GOAWAY        | <span class="number">0x7</span>  | Section <span class="number">6.8</span>  |</span><br><span class="line">| WINDOW_UPDATE | <span class="number">0x8</span>  | Section <span class="number">6.9</span>  |</span><br><span class="line">| CONTINUATION  | <span class="number">0x9</span>  | Section <span class="number">6.10</span> |</span><br><span class="line">+---------------+------+--------------+</span><br></pre></td></tr></table></figure><ul><li><p><code>Flags</code>: 即标志位，这个不太方便理解，你可以理解为 帧的特殊标记！例如 <code>SETTINGS帧</code> 会有一个<code>ACK</code> Falgs！ 多个falgs通过 bitmap 进行设置！</p></li><li><p><code>R</code>: 这个是保留位（reserved bit），占用1bit，必须是0</p></li><li><p><code>Stream Identifier</code>: 即流ID，占用31bit，为无符号整数！顾名思义和RPC的seq id 很像！这里注意客户端发起的stream_id必须为奇数，服务端发起的为偶数！例如上面那个case，客户端发起的<code>stream_id=13</code>!</p></li><li><p><code>Frame Payload</code> 即 payload，允许为空！</p></li></ul><h3 id="SETTINGS-帧"><a href="#SETTINGS-帧" class="headerlink" title="SETTINGS 帧"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.5">SETTINGS 帧</a></h3><p>在建立请求过程中，<code>Magic帧</code>后面就会立马跟一个<code>SETTINGS 帧</code>！如下图，这个帧主要作用就是为了初始化连接的配置信息！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-18/a3a70bc84a634f6f949737c3cee43a16.png" alt="image-20220518230410699"></p><p>其中<code>SETTINGS 帧</code>就是一对对KV组成，如下图，多个KV的话，顺序写即可！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------------+</span><br><span class="line">|       Identifier (16)         |</span><br><span class="line">+-------------------------------+-------------------------------+</span><br><span class="line">|                        Value (32)                             |</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>Identifier：标识符，主要分为以下几类，可以理解为key</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETTINGS_HEADER_TABLE_SIZE (<span class="number">0x1</span>): 设置HPACK中动态表的大小，默认是<span class="number">4096</span>个字节</span><br><span class="line">SETTINGS_ENABLE_PUSH (<span class="number">0x2</span>): 是否允许服务端推送，默认为<span class="number">0</span>表示关闭，<span class="number">1</span>表示开启</span><br><span class="line">SETTINGS_MAX_CONCURRENT_STREAMS (<span class="number">0x3</span>): 表示一个连接上最大的并发数量，无默认值，例如头条主站就是设置的<span class="number">128</span></span><br><span class="line">SETTINGS_INITIAL_WINDOW_SIZE (<span class="number">0x4</span>): 初始化窗口的大小，用于流量控制，默认值是<span class="number">65535</span>, 最大为 <span class="number">2</span>&lt;&lt;<span class="number">31</span> - <span class="number">1</span></span><br><span class="line">SETTINGS_MAX_FRAME_SIZE (<span class="number">0x5</span>): 最大的帧大小，默认值是 <span class="number">16384</span>，最大为<span class="number">2</span>&lt;&lt;<span class="number">24</span> - <span class="number">1</span></span><br><span class="line">SETTINGS_MAX_HEADER_LIST_SIZE (<span class="number">0x6</span>): 这里表示请求header的最大长度</span><br></pre></td></tr></table></figure><ul><li>Value： 值，四个字节，都是int值</li></ul><p><strong>注意：</strong></p><ol><li>如果一个端需要发起设置，那么它需要标记 <code>falgs Ack=0</code>, 然后携带上配置，另外一端接收后会响应一个<code>falgs Ack=1</code>，且<code>payload</code> 为空！ 例如下面流程：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 收到settings帧</span></span></span><br><span class="line">[  0.083] recv SETTINGS frame &lt;length=18, flags=0x00, stream_id=0&gt;</span><br><span class="line">          (niv=3)</span><br><span class="line">          [SETTINGS_MAX_CONCURRENT_STREAMS(0x03):128]</span><br><span class="line">          [SETTINGS_INITIAL_WINDOW_SIZE(0x04):65536]</span><br><span class="line">          [SETTINGS_MAX_FRAME_SIZE(0x05):16777215]</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 发送ack帧</span></span>          </span><br><span class="line">[  0.083] send SETTINGS frame &lt;length=0, flags=0x01, stream_id=0&gt;</span><br><span class="line">          ; ACK</span><br><span class="line">          (niv=0)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>SETTINGS 帧</code>的 <code>stream_id</code> 固定为0 ！</li></ol><h3 id="WINDOW-UPDATE-帧-（流量控制）"><a href="#WINDOW-UPDATE-帧-（流量控制）" class="headerlink" title="WINDOW_UPDATE 帧 （流量控制）"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.9">WINDOW_UPDATE 帧</a> （流量控制）</h3><p><code>WINDOW_UPDATE 帧</code> 主要是用于流量控制（Flow Control），这个名词在TCP也有！不过 HTTP/1.x 并未包含流控机制，依靠 TCP 的流控也工作得很好，那为什么 HTTP/2 需要添加呢？原因很明显，因为 HTTP/2 引入了 <code>stream</code>（流） 和 <code>multiplexing</code>(多路复用) ，想让众多 <code>stream</code> 协同工作，就需要一种控制机制，防止某个流阻塞其他流！</p><p>具体原理如下：<strong>sender发送数据会降低窗口大小，需要receiver方通知sender来恢复窗口，这就需要<code>WINDOW_UPDATE 帧</code> 了</strong>! 其中流控算法官方并没有提出实现规范！注意 sender 指的数据发送方（可以是server、也可以是client）。 整体总结就是：<strong>接收者来提供控制</strong>！</p><blockquote><p>​ 这里理解比较抽象，比如现在假如一个连接有多个流，流A和流B…xxx，假如此时客户端压力比较大（比如处理不过来消息或者机器负载过高），客户端检测到了，那么可以通过流量控制去实现！</p></blockquote><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-19/3719f7ba9e904e65bbb7b96c4cf08e30.png" alt="img"></p><p>具体HTTP/2如何实现流控的，主要是由于HTTP/2 的流控分为了两类，<strong>stream flow-control window(sfw)</strong> 和 <strong>connection flow-control window (cfw)<strong>， 其中每个stream会维护自己的sfw，所有的stream共用一个cfw ！</strong>发送多少包窗口就减少多少，cfw和sfw都会减少！那么增加呢是单独增加！要么是cfw、要么是sfw！其次cfw、sfw只针对于DATA帧的内容！</strong></p><p><strong>例如</strong>：<a target="_blank" rel="noopener" href="https://grpc.io/">GRPC</a>中在当接收的包的总大小(自己做的receive flow-control)大于cfw/sfw大小的1/4的时候，就会发送<code>window_update</code>帧，然后重置receive size，或者发送PING包的时候也会携带发送<code>window_update</code> 帧！具体逻辑可以看: <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/blob/master/internal/transport/controlbuf.go#L878">sender逻辑</a> 、 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/blob/master/internal/transport/http2_server.go#L733">server 端receiver逻辑</a> 、 <a target="_blank" rel="noopener" href="https://github.com/grpc/grpc-go/blob/master/internal/transport/http2_client.go#L430">client receiver逻辑</a>，有兴趣的可以看一下！目前HTTP/2应用比较广泛的应该是GRPC、Nginx(L7)、浏览器！</p><p><code>WINDOW_UPDATE帧</code> 协议包比较简单，主要就是传输<code>Window Size Increment</code>，这个值是增加<code>cfw</code> or <code>sfw</code>的大小！ 如果调整 <code>sfw</code>则需要传递 <code>stream_id</code> ！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|R|              Window Size Increment (31)                     |</span><br><span class="line">+-+-------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>说到这里，可能还得知道，<strong>初始化窗口</strong>： 当一个连接初始化的时候，sfw和cfw都是65535，如果需要调整sfw 的初始化窗口大小则需要需要发送<code>Setting帧</code> （这个是针对所有stream），如果需要调整cfw大小（所以初始化时候cfw一定是65535）需要发送<code>window_update帧</code>!</p><h3 id="HEADERS-帧"><a href="#HEADERS-帧" class="headerlink" title="HEADERS 帧"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.2">HEADERS 帧</a></h3><p>一个HTTP/2 请求从 <code>HEADERS 帧</code> 开始发送的！例如这个是一个HTTP/2 Headers 帧的抓包图：</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-19/8a90221c23494861ab5148e832b56da0.png" alt="image-20220519164417774"></p><p>其中header的编码比较复杂，后续我们会讲解HPACK，所以这里只要知道有这个header帧主要包含哪些内容即可！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|E|                 Stream Dependency? (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|  Weight? (8)  |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>Pad Length： 表示尾部Padding的长度，为可选字段（注意标记?的为可选字段）</li><li>E：1bit，表示当前流是否排他的 (与 <code>PRIORITY 帧有关</code>)</li><li>Stream Dependency： 表示依赖于哪个流 (与 <code>PRIORITY 帧有关</code>)</li><li>Weight：流的权重 (与 <code>PRIORITY 帧有关</code>)</li><li>Header Block Fragment： 请求的首部，使用HPACK编码</li><li>Padding：补齐内容，用0填充</li></ul><p>例如报文如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0000   00 00 1f 01 05 00 00 00 01 82 84 87 41 8b f1 e3   ............A...</span><br><span class="line">0010   c2 f3 1c f3 50 55 c8 7a 7f 7a 88 25 b6 50 c3 ab   ....PU.z.z.%.P..</span><br><span class="line">0020   ba ea e0 53 03 2a 2f 2a                           ...S.*/*</span><br></pre></td></tr></table></figure><ul><li><code>00 00 1f 01 05 00 00 00 01</code>: 前9个字段为Frame的头部，payload长度为31，为Headers帧，flag为5，stream_id=1</li><li>其中后面31个字节就是头部的header内容了， 这里采用了 HPACK 编码！所以需要了解下HPACK编码，这里也能看出来下文是Header的内容，一共是100个字节，但是使用HPACK编码后只占用了31个字节！ 整整节约了70%的编码！</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">:method: GET</span><br><span class="line">:path: /</span><br><span class="line">:scheme: https</span><br><span class="line">:authority: www.google.com</span><br><span class="line">user-agent: curl/7.77.0</span><br><span class="line">accept: */*</span><br></pre></td></tr></table></figure><p>这里我们要解码者31个字节需要直接跳转到 HPACK那一节吧！</p><p><strong>注意：</strong></p><ol><li>HTTP/2 和 HTTP/1.x 协议有些header是不兼容的，比如<code>Keep-Alive</code> 和 <code>Connection</code> 等在HTTP/2中直接没有！</li><li>HTTP的header是支持 <code>header: v1;v2</code>表示多个 ，同时也支持 <code>header: k1</code>,<code>header:k2</code> ，在HTTP/2中在编码的时候会使用后者！同时header name推荐全部小写（看完HPACK就会理解）！</li></ol><h3 id="DATA-帧"><a href="#DATA-帧" class="headerlink" title="DATA 帧"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.1">DATA 帧</a></h3><p>data帧对应着 HTTP的Body，如果没有响应体的话是不需要传输的！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+---------------+-----------------------------------------------+</span><br><span class="line">|                            Data (*)                         ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>Pad Length</code>： 表示padding长度， 只有存在 <code>PADDED flags</code>才有这个值！</li><li><code>Data</code>： 真正的数据</li><li><code>Padding</code> : 表示padding数据，并没有强制的padding算法，也就是你发出的数据可以不padding！</li></ul><p>这里 <code>DATA 帧</code>会有两个标识，一个是 <code>END_STREAM</code> 、一个是 <code>PADDED</code></p><h3 id="PRIORITY帧-请求优先级"><a href="#PRIORITY帧-请求优先级" class="headerlink" title="PRIORITY帧 (请求优先级)"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.3">PRIORITY帧 (请求优先级)</a></h3><p>这个帧可以定义请求（stream）的优先级，<strong>但是这个优先级只是客户端发来的提议，服务端可以不去支持</strong>！下面就是报文格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-+-------------------------------------------------------------+</span><br><span class="line">|E|                  Stream Dependency (31)                     |</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|   Weight (8)  |</span><br><span class="line">+-+-------------+</span><br></pre></td></tr></table></figure><ul><li>E：是否独占（排他），独占依赖的流（形象点就是我独占它，原来依赖它的人全部得依赖我）</li><li>Stream Dependency：流依赖</li><li>Weight：流权重，这个应该是最好理解的，权重越大，优先级越高！</li></ul><p>这里吐槽一句：使用<code>HTTP/1.x</code>，浏览器可以完全控制资源加载顺序！<code>HTTP/2</code>让这些事情变得更好也更复杂了！但是么还是值得学习一下的！</p><p>具体实现就设计到算法了，因为既要要求性能高，同时也要求准确性！关于算法可以看 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-5.3">RFC7540-5.3</a>，实现的话可以看下NGINX或者熟悉语言、框架的SDK！下面我就就单介绍一下！</p><ol><li>简单的依赖，比图 B和C依赖于A，此时插入个D也依赖于A那么就是下面这个效果！注意D的位置可以任意！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  A                 A</span><br><span class="line"> / \      ==&gt;      /|\</span><br><span class="line">B   C             B D C</span><br></pre></td></tr></table></figure><ol start="2"><li>独占情况，还是上面的关系，假如D独占A，那么就会变为下面这个图</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">                    A</span><br><span class="line">  A                 |</span><br><span class="line"> / \      ==&gt;       D</span><br><span class="line">B   C              / \</span><br><span class="line">                  B   C</span><br></pre></td></tr></table></figure><ol start="3"><li>权重，主要是解决具有相同父流的流应该根据权重比例分配资源！比如这个图假如A加载完成后，那么B应该优先处理，才会处理C！</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">     A  </span><br><span class="line">   /   \</span><br><span class="line">  /     \     </span><br><span class="line">B(12)   C(4) </span><br></pre></td></tr></table></figure><ol start="4"><li>动态调整，例如下图初始化是图一，假如此时A依赖于D，那么D直接替换A的位置(这里看着操作是D放到了和A一样的父亲下面，变成了<code>图intermediate</code>)，然后A的子依赖关系不变，挪动一下，就变成了<code>图non-exclusive</code> ！假如A独占D了，就变成了<code>图exclusive</code> !</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   x                x                x                 x</span><br><span class="line">   |               / \               |                 |</span><br><span class="line">   A              D   A              D                 D</span><br><span class="line">  / \            /   / \            / \                |</span><br><span class="line"> B   C     ==&gt;  F   B   C   ==&gt;    F   A       OR      A</span><br><span class="line">    / \                 |             / \             /|\</span><br><span class="line">   D   E                E            B   C           B C F</span><br><span class="line">   |                                     |             |</span><br><span class="line">   F                                     E             E</span><br><span class="line">(图一)        (intermediate)   (non-exclusive)    (exclusive)</span><br></pre></td></tr></table></figure><h3 id="其他帧"><a href="#其他帧" class="headerlink" title="其他帧"></a>其他帧</h3><ol><li><p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.7">PING帧</a> ，主要是用来维持一个空闲连接的，以及可以计算一次RTT时间！</p></li><li><p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.8">GOAWAY帧</a> ，主要是用来关闭连接的，同时允许携带发送一个错误码！</p></li><li><p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.4">RST_STREAM 帧</a>，主要是用来关闭流的，同时允许携带发送一个错误码！</p></li><li><p><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.10">CONTINUATION 帧</a>，主要是解决当 <code>HEADER帧</code> 超出了限制<code>MAX_FRAME_SIZE</code>的大小来获取完整的HTTP首部的问题，所以需要发送 <code>CONTINUATION 帧</code>，同时<code>CONTINUATION帧</code>也需要在<code>MAX_FRAME_SIZE</code>大小之内，所以可能跟随多个 <code>CONTINUATION 帧</code>！ 它有个<code>END_HEADERS</code> 标记来标记是否结束！所以假如出现这个case那么 <code>Header帧</code>就需要标记<code>END_HEADERS=False</code>了！ 其实<code>PUSH_PROMISE帧</code> 不够大（这个后面会讲到），后面也得用 <code>CONTINUATION 帧</code>!</p></li></ol><h2 id="HPACK-编码"><a href="#HPACK-编码" class="headerlink" title="HPACK 编码"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-compression-09">HPACK 编码</a></h2><p>我们知道HTTP/1.x其实可以对Body部分进行压缩，但是头部部分是无法压缩的！所以HTTP/2中引入了HPACK 主要是用来压缩HTTP的头部的，主要是采用静态表+动态表+压缩算法组成！然后就是HTTP/2中把请求行/响应行部分移到了全部转移到了Header部分！对照关系是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method -&gt; :method</span><br><span class="line">path -&gt; :path</span><br><span class="line">status -&gt; :status</span><br></pre></td></tr></table></figure><h3 id="静态表"><a href="#静态表" class="headerlink" title="静态表"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-compression-09#appendix-B">静态表</a></h3><p>静态表（Static Table），一共61对，应该很好理解，比如 <code>method=GET</code>，那么会把它转换成一个数字，例如<code>:authority=www.google.com</code> 会转换一个数字 + 字符串（不一定）！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+-------+-----------------------------+---------------+</span><br><span class="line">| Index | Header Name                 | Header Value  |</span><br><span class="line">+-------+-----------------------------+---------------+</span><br><span class="line">| 1     | :authority                  |               |</span><br><span class="line">| 2     | :method                     | GET           |</span><br><span class="line">| 3     | :method                     | POST          |</span><br><span class="line">| 4     | :path                       | /             |</span><br><span class="line">| 5     | :path                       | /index.html   |</span><br><span class="line">| 6     | :scheme                     | http          |</span><br><span class="line">| 7     | :scheme                     | https         |</span><br><span class="line">| 8     | :status                     | 200           |</span><br><span class="line">| 9     | :status                     | 204           |</span><br><span class="line">| 10    | :status                     | 206           |</span><br><span class="line">| 11    | :status                     | 304           |</span><br><span class="line">| 12    | :status                     | 400           |</span><br><span class="line">| 13    | :status                     | 404           |</span><br><span class="line">| 14    | :status                     | 500           |</span><br><span class="line">| 15    | accept-charset              |               |</span><br><span class="line">| 16    | accept-encoding             | gzip, deflate |</span><br><span class="line">| 17    | accept-language             |               |</span><br><span class="line">............</span><br><span class="line">| 58    | user-agent                  |               |</span><br><span class="line">| 59    | vary                        |               |</span><br><span class="line">| 60    | via                         |               |</span><br><span class="line">| 61    | www-authenticate            |               |</span><br><span class="line">+-------+-----------------------------+---------------+</span><br></pre></td></tr></table></figure><p>注意：这里虽然没有<code>:method</code> 且 <code>Header Value</code> 为空的这种情况，其实实际处理的时候<code>:method=Delete</code> 这种实际上 <code>:method</code>会编码为3，如果没有则取key相同最大的index！</p><h3 id="动态表"><a href="#动态表" class="headerlink" title="动态表"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-compression-09#section-3.3.2">动态表</a></h3><p>动态表(Header Table)，顾名思义就是动态生成表，然后最终形式上和上面静态表差不多！<strong>它的生命周期是一个连接上</strong>（注意一个连接可以有多个请求/响应）！</p><p>由于动态表时动态生成的，那么对于单机维护的连接数过多，此时动态表会很占内存，假如此时我们不进行内存限制，很容易被攻击导致内存OOM，那么所以动态表会有一个大小限制，可以通过 <code>SETTINGS 帧</code>下发<code>HEADER_TABLE_SIZE=4096</code>, 单位是字节，来实现<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/draft-ietf-httpbis-header-compression-09#section-5">动态表内存限制</a>！那么一个Header的Key和Value的大小是多少了？计算公式是 <code>len(key)+len(value)+32</code> , 为什么加32了，是因为大部分语言，存储string会额外消耗16字节用来存储数组指针和数组长度！</p><p>那么假如动态表在我们写header的时候，发现大小超出了 <code>HEADER_TABLE_SIZE</code> 怎么办了，具体算法就是个FIFO模型，队列大小确定，所以大概流程就是下面这个：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 请求1</span><br><span class="line">// set max_size=32 + 4 + 32 + 4 + 32 + 4 + 32</span><br><span class="line">// 计算index(key,value)公式 = arr_index(key,value) + 61 + 1</span><br><span class="line">addHeader(&quot;k1&quot;, &quot;v1&quot;) // write k1-v1, arr=[k1-v1]</span><br><span class="line">addHeader(&quot;k2&quot;, &quot;v2&quot;) // write k2-v2, arr=[k2-v2, k1-v1]</span><br><span class="line">addHeader(&quot;k3&quot;, &quot;v3&quot;) // write k3-v3, arr=[k3-v3, k2-v2, k1-v1]</span><br><span class="line">addHeader(&quot;k4&quot;, &quot;v4&quot;) // write k4-v4, arr=[k4-v4, k3-v3, k2-v2]</span><br><span class="line"></span><br><span class="line">// 请求2</span><br><span class="line">addHeader(&quot;k3&quot;, &quot;v3&quot;) // write index=63</span><br><span class="line">addHeader(&quot;k1&quot;, &quot;v1&quot;) // write k1-v1, arr=[k1-v1, k4-v4, k3-v3]</span><br><span class="line">addHeader(&quot;k3&quot;, &quot;v3&quot;) // write index=64</span><br><span class="line">addHeader(&quot;k4&quot;, &quot;v4&quot;) // write index=63</span><br><span class="line">addHeader(&quot;k1&quot;, &quot;v1&quot;) // write index=62</span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6">编码</a></h3><p>在HTTP/2中编码采用的算法主要是 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-5.1">varint编码</a> 和 霍夫曼编码 （<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">Huffman Coding</a> 也叫做哈夫曼编码）</p><p>概念：</p><ul><li>varint 编码是数字压缩算法中常见的一种，主要是采用变长来存储数字，比如虽然值定义的是8字节，但是比如数字<code>1</code>可以用1个字节进行编码，主要原理就是利用 <code>msb (the Most Significant Bit 最高有效位)</code>!</li><li>霍夫曼编码是文本压缩算法中常见的一种，是基于字符出现的次数为权重（墒编码）进行的构建字典，进而构建霍夫曼树，然后根据霍夫曼树来确定字符的二进制编码。但是如果字符不重复，且字符还很多，导致霍夫曼树很深，那么霍夫曼编码的意义就不大了！</li></ul><p><strong>注意:</strong></p><ul><li>HTTP/2 中采用的 varint 编码并不是标准的，因为他需要根据低位第一个字节标记falg, 所以解决思路就是减去第一个字节定义的最大值（区间是 1 到 1&lt;&lt;7-1），剩余的值用的varint编码，具体可以参考: <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-5.1%EF%BC%8C">https://datatracker.ietf.org/doc/html/rfc7541#section-5.1，</a> 伪代码如下:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 伪代码</span></span><br><span class="line">if num &lt; max&#123;</span><br><span class="line">	 return num</span><br><span class="line">&#125;</span><br><span class="line">[Max,varint(num-max) ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span>:</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如max=1&lt;&lt;<span class="string">7-1, num=126(0b01111110), 那么输出 [0x7e]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 例如max=1&lt;&lt;7</span>-1, num=127(0b01111111)，那么输出 [0x7f, 0x00]</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如max=1&lt;&lt;<span class="string">7-1, num=127+128(0b10000000), 那么输出 [0x7f, 0x80, 0x01]</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 下文中叫 (7</span>+)varint 表示max=1&lt;&lt;<span class="string">7-1 也就是上面这个case, 例如(6+)varint 表示max=1&lt;&lt;6-1</span></span></span><br></pre></td></tr></table></figure><ul><li>HTTP/2 中采用的 霍夫曼编码也不是按照标准的，它采用的是静态表，也就是它省去了动态生成霍夫曼树的过程（省略计算过程和Map过程），这个树就是个静态的！具体可以参考: <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-5.2">https://datatracker.ietf.org/doc/html/rfc7541#section-5.2</a> !</li></ul><h4 id="1-Indexed-Header-Field-Representation"><a href="#1-Indexed-Header-Field-Representation" class="headerlink" title="1. Indexed Header Field Representation"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.1">1. Indexed Header Field Representation</a></h4><p>采用这边编码情况是： header 的 key和value 都在中，然后可以拿到index（动态表index=静态表index+偏移量），比如<code>method: GET</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 1 |        Index (7+)         |</span><br><span class="line">+---+---------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>1</code>：标识符号，varint编码后第一个字节的高位8bit标识符是1</li><li><code>index (7+)</code>: 表示index值，采用 <code>(7+)varint</code> 算法</li></ul><h4 id="2-1-Literal-Header-Field-with-Incremental-Indexing-indexed-Name"><a href="#2-1-Literal-Header-Field-with-Incremental-Indexing-indexed-Name" class="headerlink" title="2.1 Literal Header Field with Incremental Indexing - indexed Name"></a>2.1 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.2.1">Literal Header Field with Incremental Indexing - indexed Name</a></h4><p>表示: name 在表中，value 不在表中，且需要添加到表中，比如 <code>Host: www.google.com</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  0   1   2   3   4   5   6   7</span><br><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 1 |      Index (6+)       |</span><br><span class="line">+---+---+-----------------------+</span><br><span class="line">| H |     Value Length (7+)     |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| Value String (Length octets)  |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><ul><li><code>01</code>+ <code>Index (6+)</code> ，为index编码，主要是为了区分上面<code>Indexed Header Field Representation</code> 的case</li><li><code>H</code>： 为<code>Value String</code> 是否采用霍夫曼编码编码，<code>H=1</code> 表示采用霍夫曼编码</li><li><code>Value Length(7+)</code>: 表示value string的长度，具体算法就是 <code>(7+)varint</code> 算法</li><li><code>Value String</code>：霍夫曼编码 or 原值</li></ul><h4 id="2-2-Literal-Header-Field-with-Incremental-Indexing-New-Name"><a href="#2-2-Literal-Header-Field-with-Incremental-Indexing-New-Name" class="headerlink" title="2.2  Literal Header Field with Incremental Indexing - New Name"></a>2.2 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.2.1">Literal Header Field with Incremental Indexing - New Name</a></h4><p>表示： name 不在表中，value也不在表中，但是需要添加到表中！例如自定义header <code>X-Host: www.google.com</code>，且我们允许 name 和 value 添加到表中！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  0   1   2   3   4   5   6   7</span><br><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 1 |           0           |</span><br><span class="line">+---+---+-----------------------+</span><br><span class="line">| H |     Name Length (7+)      |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">|  Name String (Length octets)  |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| H |     Value Length (7+)     |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| Value String (Length octets)  |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><p>这里我就不过多讲解了，通过上面的两个讲解，应该大家都有所了解！这个也就是第一个字节一定是 <code>0x40</code></p><h4 id="3-1-Literal-Header-Field-without-（Never）-Indexing-Indexed-Name"><a href="#3-1-Literal-Header-Field-without-（Never）-Indexing-Indexed-Name" class="headerlink" title="3.1 Literal Header Field without （Never） Indexing - Indexed Name"></a>3.1 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.2.2">Literal Header Field without （Never） Indexing - Indexed Name</a></h4><p>和上面的<code>Literal Header Field with Incremental Indexing - indexed Name</code> 的区别在于，这个不需要被添加到表中！</p><p>其次就是 <code>Literal Header Field without Indexing</code> 和 <code>Literal Header Field Never Indexing</code> 主要区别在于首字节，前者是 <code>0000xxxx</code>，后者是<code>0001xxxx</code>！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  0   1   2   3   4   5   6   7</span><br><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 0 | 0 | 0 |  Index (4+)   |</span><br><span class="line">+---+---+-----------------------+</span><br><span class="line">| H |     Value Length (7+)     |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| Value String (Length octets)  |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><h4 id="3-2-Literal-Header-Field-without（Never）-Indexing-New-Name"><a href="#3-2-Literal-Header-Field-without（Never）-Indexing-New-Name" class="headerlink" title="3.2 Literal Header Field without（Never） Indexing - New Name"></a>3.2 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.2.2">Literal Header Field without（Never） Indexing - New Name</a></h4><p>和上面的<code>Literal Header Field with Incremental Indexing - indexed Name</code> 的区别在于，这个不需要被添加到表中！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	0   1   2   3   4   5   6   7</span><br><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 0 | 0 | 0 |       0       |</span><br><span class="line">+---+---+-----------------------+</span><br><span class="line">| H |     Name Length (7+)      |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">|  Name String (Length octets)  |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| H |     Value Length (7+)     |</span><br><span class="line">+---+---------------------------+</span><br><span class="line">| Value String (Length octets)  |</span><br><span class="line">+-------------------------------+</span><br></pre></td></tr></table></figure><h4 id="4-Dynamic-Table-Size-Update"><a href="#4-Dynamic-Table-Size-Update" class="headerlink" title="4. Dynamic Table Size Update"></a>4. <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7541#section-6.3">Dynamic Table Size Update</a></h4><p>我们知道 <code>SETTINGS帧</code>的 <code>SETTINGS_HEADER_TABLE_SIZE</code> 也是设置 tables size大小的，那么这个作用是什么？它的含义就是动态变更 size，但是这个<code>max size</code> 必须小于或者等于 <code>SETTINGS_HEADER_TABLE_SIZE</code>！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0   1   2   3   4   5   6   7</span><br><span class="line">+---+---+---+---+---+---+---+---+</span><br><span class="line">| 0 | 0 | 1 |   Max size (5+)   |</span><br><span class="line">+---+---------------------------+</span><br></pre></td></tr></table></figure><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h4><p>注意关于 <code>Literal Header Field without Indexing</code> 和 <code>Literal Header Field Never Indexing</code> 的区别在于哪里了？官方的解释差别就一句话 <strong>Intermediaries MUST use the same representation for encoding this header field.</strong>, 意思就是假如我们请求中间有个HTTP/2代理（例如 nginx），那么如果是<code>Never Indexed</code> 那么代理也必须原封不动的转发 !</p><p>但是目前看Nginx并不支持后端服务(up stream)是HTTP/2协议，只支持GRPC（注意GRPC处理模块可以处理一些通用的HTTP/2协议的请求，但是支持度并不好）！具体可以参考 <a target="_blank" rel="noopener" href="https://trac.nginx.org/nginx/ticket/923">https://trac.nginx.org/nginx/ticket/923</a> !</p><h3 id="服务器推送-PUSH-PROMISE-帧"><a href="#服务器推送-PUSH-PROMISE-帧" class="headerlink" title="服务器推送 PUSH_PROMISE 帧"></a>服务器推送 <a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc7540#section-6.6">PUSH_PROMISE 帧</a></h3><p>首先要明白，HTTP/2为什么会有服务端推送，比如我们一个普通的加载网页的流程，会返回网页，然后再起请求一些静态资源，所以浏览器的整个流程是下面这个流程如下图左侧！但是如果有服务端推送的话后续加载n次资源就会减少n次RTT的时间，如下图右侧！那么HTTP/2是如何实现服务端推送的呢？</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/5e69f9923eda45e4a863cd94d8f78986.png" alt="img"></p><p>首先在讲下面我们需要先说明一个问题：如果实现上面的功能，我们需要告诉浏览器要推送哪些资源，不然我们先返回html浏览器就渲染html直接发起请求加载静态文件了，那么我们推送就白做了，所以这里需要知道是哪个流发起的加载html的请求，然后通过这个流告诉浏览器我们要下发给你哪些资源在返回HTML之前！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 服务器推送从源服务器的 Link 标头的 rel=preload 参数提取 URI 引用，然后将这些额外 URI 提供给客户端</span></span><br><span class="line">Link: &lt;/images/image.png&gt;;rel=preload;</span><br><span class="line">Link: &lt;/css/main.css&gt;;rel=preload;</span><br></pre></td></tr></table></figure><p><code>PUSH_PROMISE</code> 帧是服务器发起的请求，所以这里的stream_id是偶数！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+</span><br><span class="line">|Pad Length? (8)|</span><br><span class="line">+-+-------------+-----------------------------------------------+</span><br><span class="line">|R|                  Promised Stream ID (31)                    |</span><br><span class="line">+-+-----------------------------+-------------------------------+</span><br><span class="line">|                   Header Block Fragment (*)                 ...</span><br><span class="line">+---------------------------------------------------------------+</span><br><span class="line">|                           Padding (*)                       ...</span><br><span class="line">+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><ul><li>R: 保留位</li><li>Promised Stream ID: 这个就是上面讲到的，其实就是Push stream id（承诺要发送的stream ID）</li><li>Header Block Fragment： 请求header，其实就是把推送的请求体发送过去了！</li></ul><p><strong>注意</strong>：由于推送会涉及到幂等、安全等问题，所以一般就是推送静态资源！</p><p>服务器推送的整体流程还是很简单，就是响应HTML之前发送 <code>PUSH_PROMISE 帧</code>，这个帧会携带push资源的请求内容！然后返回HTML，然后再用<code>Promised Stream ID</code> 写响应关闭流即可！</p><p>服务端推送相比于HTTP/2不推送，前端页面整体的提升率大约在8%左右，具体可以看<a target="_blank" rel="noopener" href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/#measuring-server-push-performance">相关测评</a> ，同时开启后也会存在一定浪费带宽的问题，那就是假如浏览器有缓存不就不用返回了！目前主流的架构都是将静态资源基本放在CDN上，所以如果需要使用服务端推送，需要确定CDN厂商是否支持！</p><p>下图来自于<a target="_blank" rel="noopener" href="https://www.upyun.com/">又拍云</a>关于DNS 服务端推送相关的页面，具体可以点击<a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/lookingcamel/topics/1282481">链接</a>查看：</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/1cdb974839814c26913cde2ed1fef562.png" alt="img"></p><h1 id="HTTP-3-介绍"><a href="#HTTP-3-介绍" class="headerlink" title="HTTP/3 介绍"></a><a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/draft-ietf-quic-http">HTTP/3</a> 介绍</h1><p>​ 通过学习上面我们发现HTTP/2其实做了很多的优化，在整个传输层，不仅降低了数据包的大小，同时流和多路复用降低了连接上的开销，提高了页面的加载速度！但是这种优化也是有弊端的！现在移动互联网比较普及，大部分流量都来自于移动设备，而移动设备最大的特点就是网络问题！而HTTP/2依赖于TCP，在网络不稳定的情况下，TCP的流控会导致HTTP/2变慢，如果发生丢包，就会导致HoL (<a target="_blank" rel="noopener" href="https://github.com/rmarx/holblocking-blogpost">Head of Line Blocking</a> 头部阻塞)， 导致一个连接上所有的流都需要等待！</p><p>​ 因此作为HTTP/2前身SPDY的发明者Google，<del>毕竟走的路比较长</del>，所以也提出了比较好的解决思路，那就是把TCP替换掉，随后就诞生了QUIC！QUIC ( Quick UDP Internet Connection) 是 Google 研发的一种基于 UDP 协议的低时延互联网传输协议。在2018年IETF会议中（<del>主要原因还是TLS v1.3同年正式发布</del>），HTTP-over-QUIC协议被重命名为HTTP/3，并成为 HTTP 协议的第三个正式版本，大概的关系就是： 运行在 QUIC 之上的 HTTP 协议被称为 HTTP/3！</p><p>**QUIC 是传输层协议(4层协议)**，其中有两个版本一个是gQUIC(Google QUIC)和iQUIC(IETF QUIC)，注意两者差别！有兴趣的可以看下<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/1WJvyZflAO2pq77yOLbp9NsGjC1CHetAXV8I0fQe-B_U/edit">QUIC 介绍</a>，QUIC[<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8999">RFC 8999-9002</a>]，以及 TLS1.3[<a target="_blank" rel="noopener" href="https://datatracker.ietf.org/doc/html/rfc8446">RFC 8446</a>]，下图是一个大概的一个模型图：</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/2409f7effc584774a1248cc1016d27a1.jpeg" alt="img"></p><p>由于本文前面篇幅有点长了，而且从HTTP发展历史也可以看得出来会越来越复杂，所以如果有兴趣的想深入了解的可以查阅相关资料，上面已经提供了很多了，下面就列出来了QUIC的几大特点：</p><ul><li>降低了建连时间（注意a为TLS完全握手，b为TLS简化握手，可以实现0RTT 握手）</li></ul><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2022/5-23/0391ffba9ef5470792dfdf87f2e6b220.png" alt="img"></p><blockquote><p>根据第三方数据使用QUIC 0RTT率大约在55%左右，具体可以<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143464334">点击文章查看详情</a>！</p></blockquote><ul><li>优化了流量控制算法</li><li>优化了拥塞控制算法（其实和TCP用的是一样的都是<a target="_blank" rel="noopener" href="https://allen-kevin.github.io/2017/12/21/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E4%B9%8BCUBIC/">Cubic算法</a>）</li><li>用户态协议，不需要升级or修改内核，升级迭代容易，<del>虽然TCP有许多新特性，但是抵挡不住不敢随意升级内核哇</del>！</li></ul><p>目前外部对于QUIC的实现也比较多，比如字节的TTQUIC，快手的<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/afncpsfmb3ufwehueak1">KQUIC</a>, 以及微软的 <a target="_blank" rel="noopener" href="https://github.com/microsoft/msquic">msquic</a> 。但是目前来看QUIC也有很多问题，主要问题还是UDP带来的问题，因为不同运营商会对UDP进行了一定的限制，其次就是多一层用户态协议的开销也是有一定的性能损耗(CPU、Mem的开销)，最后就是目前人们对于TCP优化做的太多了！不过相信这些问题都是可以用时间去解决的，相信未来QUIC发展的更好！</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><a target="_blank" rel="noopener" href="http://www.bewindoweb.com/271.html">SSL/TLS发展历史和SSLv3.0协议详解</a></li><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/21518760">HTTPS的性能消耗</a></li><li><a target="_blank" rel="noopener" href="https://introspelliam.github.io/2018/03/20/crypto/%E6%B7%B1%E5%BA%A6%E8%A7%A3%E8%AF%BBSSL-TLS%E5%AE%9E%E7%8E%B0/">深入解读SSL/TLS的实现</a></li><li><a target="_blank" rel="noopener" href="https://httpwg.org/specs/rfc7540.html">RFC7540</a></li><li><a target="_blank" rel="noopener" href="https://laike9m.com/blog/rfc7540-bi-ji-wu-flow-control,106/">HTTP2流量控制介绍</a></li><li><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/qydn85t4g4dl4vbae3n2">技术干货：HTTP/2 之服务器推送 (Server Push) 最佳实践</a></li><li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1155289?from=10680">揭秘QUIC的五大特性及外网表现</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37379780">TCP流量控制、拥塞控制</a></li><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/143464334">HTTP/3 原理实战</a></li><li><a target="_blank" rel="noopener" href="https://codeantenna.com/a/VFEe0v5kOp">QUIC with TLS1.3 简介</a></li></ol></div><div class="reward-container"><div>本人坚持原创技术分享，如果你觉得文章对您有用，请随意打赏! 如果有需要咨询的请发送到我的邮箱!</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Anthony-Dong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="Anthony-Dong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Anthony-Dong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anthony-dong.github.io/2022/05/19/14ae618744ce995daa153156bee2d2e6/" title="聊一聊HTTP协议">https://anthony-dong.github.io/2022/05/19/14ae618744ce995daa153156bee2d2e6/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/HTTP/" rel="tag"># HTTP</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2022/03/27/583186f06a088dc9967a483e3876b2a2/" rel="prev" title="用markdown画流程图和时序图"><i class="fa fa-chevron-left"></i> 用markdown画流程图和时序图</a></div><div class="post-nav-item"><a href="/2023/01/31/5c4904cd995fb585e97a439065161818/" rel="next" title="Protobuf-SourceCodeInfo 介绍">Protobuf-SourceCodeInfo 介绍 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP%E5%8F%91%E5%B1%95%E5%8E%86%E5%8F%B2"><span class="nav-number">1.</span> <span class="nav-text">HTTP发展历史</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-0-9"><span class="nav-number">1.1.</span> <span class="nav-text">HTTP&#x2F;0.9</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-0"><span class="nav-number">1.2.</span> <span class="nav-text">HTTP&#x2F;1.0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-1-1"><span class="nav-number">1.3.</span> <span class="nav-text">HTTP&#x2F;1.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-HTTP-1-1-%E4%BF%AE%E8%AE%A2%E8%AE%B0%E5%BD%95"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. HTTP&#x2F;1.1 修订记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. 服务端优化手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-keep-alive"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">1. keep-alive</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%B7%E6%B1%82%E4%BD%93%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">2. 请求体压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Chunked-%E7%BC%96%E7%A0%81%EF%BC%88%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%EF%BC%89"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3. Chunked 编码（分块传输）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%89%8D%E7%AB%AF%EF%BC%88%E6%B5%8F%E8%A7%88%E5%99%A8%EF%BC%89%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5"><span class="nav-number">1.3.3.</span> <span class="nav-text">3. 前端（浏览器）优化手段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%90%88%E5%B9%B6%E8%B5%84%E6%BA%90"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">1. 合并资源</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%9F%E5%90%8D%E5%88%86%E7%89%87"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">2. 域名分片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%AE%A1%E9%81%93%E5%8C%96"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3. 管道化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%95%BF%E8%BF%9E%E6%8E%A5"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">4. 长连接</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.3.4.</span> <span class="nav-text">4. 注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BD%91%E5%85%B3%E6%96%B9%E5%90%91"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1. 网关方向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-form-data-%E7%BC%96%E7%A0%81-body%E7%AF%A1%E6%94%B9"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">2. form-data 编码 (body篡改)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B5%81%E5%BC%8F%E4%BC%A0%E8%BE%93"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3. 流式传输</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">4. 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTPS"><span class="nav-number">1.4.</span> <span class="nav-text">HTTPS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP-2-amp-HTTP-3"><span class="nav-number">1.5.</span> <span class="nav-text">HTTP&#x2F;2 &amp; HTTP&#x2F;3</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-2-%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.</span> <span class="nav-text">HTTP&#x2F;2 介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E8%A6%81%E7%89%B9%E6%80%A7"><span class="nav-number">2.1.</span> <span class="nav-text">主要特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%90%86%E8%A7%A3%E6%B5%81"><span class="nav-number">2.2.</span> <span class="nav-text">理解流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">2.2.1.</span> <span class="nav-text">流的生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8BHTTP-2%E8%BF%9E%E6%8E%A5"><span class="nav-number">2.3.</span> <span class="nav-text">如何建立HTTP&#x2F;2连接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8HTTPS%E5%8D%8F%E5%95%86-h2"><span class="nav-number">2.3.1.</span> <span class="nav-text">使用HTTPS协商 (h2)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-h2c-%E5%8D%8F%E5%95%86"><span class="nav-number">2.3.2.</span> <span class="nav-text">使用 h2c 协商</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%96%B9%E5%BC%8F%E4%B8%80-HTTP-1-1%E5%8D%87%E7%BA%A7"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">1. 方式一(HTTP&#x2F;1.1升级)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%96%B9%E5%BC%8F%E4%BA%8C-h2c"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">2. 方式二(h2c)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A7%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.4.</span> <span class="nav-text">帧介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%89%8D%E5%A5%8F"><span class="nav-number">2.4.1.</span> <span class="nav-text">连接前奏</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A7%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.4.2.</span> <span class="nav-text">帧格式介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SETTINGS-%E5%B8%A7"><span class="nav-number">2.4.3.</span> <span class="nav-text">SETTINGS 帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WINDOW-UPDATE-%E5%B8%A7-%EF%BC%88%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">WINDOW_UPDATE 帧 （流量控制）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HEADERS-%E5%B8%A7"><span class="nav-number">2.4.5.</span> <span class="nav-text">HEADERS 帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DATA-%E5%B8%A7"><span class="nav-number">2.4.6.</span> <span class="nav-text">DATA 帧</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PRIORITY%E5%B8%A7-%E8%AF%B7%E6%B1%82%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">2.4.7.</span> <span class="nav-text">PRIORITY帧 (请求优先级)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%B8%A7"><span class="nav-number">2.4.8.</span> <span class="nav-text">其他帧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HPACK-%E7%BC%96%E7%A0%81"><span class="nav-number">2.5.</span> <span class="nav-text">HPACK 编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%A1%A8"><span class="nav-number">2.5.1.</span> <span class="nav-text">静态表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8"><span class="nav-number">2.5.2.</span> <span class="nav-text">动态表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E7%A0%81"><span class="nav-number">2.5.3.</span> <span class="nav-text">编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Indexed-Header-Field-Representation"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">1. Indexed Header Field Representation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-Literal-Header-Field-with-Incremental-Indexing-indexed-Name"><span class="nav-number">2.5.3.2.</span> <span class="nav-text">2.1 Literal Header Field with Incremental Indexing - indexed Name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Literal-Header-Field-with-Incremental-Indexing-New-Name"><span class="nav-number">2.5.3.3.</span> <span class="nav-text">2.2 Literal Header Field with Incremental Indexing - New Name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-Literal-Header-Field-without-%EF%BC%88Never%EF%BC%89-Indexing-Indexed-Name"><span class="nav-number">2.5.3.4.</span> <span class="nav-text">3.1 Literal Header Field without （Never） Indexing - Indexed Name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Literal-Header-Field-without%EF%BC%88Never%EF%BC%89-Indexing-New-Name"><span class="nav-number">2.5.3.5.</span> <span class="nav-text">3.2 Literal Header Field without（Never） Indexing - New Name</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Dynamic-Table-Size-Update"><span class="nav-number">2.5.3.6.</span> <span class="nav-text">4. Dynamic Table Size Update</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%80%BB%E7%BB%93"><span class="nav-number">2.5.3.7.</span> <span class="nav-text">5. 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81-PUSH-PROMISE-%E5%B8%A7"><span class="nav-number">2.5.4.</span> <span class="nav-text">服务器推送 PUSH_PROMISE 帧</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HTTP-3-%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">HTTP&#x2F;3 介绍</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="nav-number">4.</span> <span class="nav-text">参考文章</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Anthony-Dong" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Anthony-Dong</p><div class="site-description" itemprop="description">追寻技术的本质！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anthony-dong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anthony-dong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@gmail.com" title="E-Mail → mailto:fanhaodong516@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/4248168663101320" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4248168663101320" rel="noopener" target="_blank"><i class="fas fa-book fa-fw"></i>掘金</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@163.com" title="国内邮箱 → mailto:fanhaodong516@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>国内邮箱</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Anthony-Dong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">395k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:01</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/medium-zoom.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.js",()=>{new Gitalk({clientID:"b1c466a9c5677a8d374a",clientSecret:"7cf9512c7e4b46b574e901b18983be7ae5b47d74",repo:"anthony-dong.github.io",owner:"Anthony-Dong",admin:["Anthony-Dong"],id:"231ed0a043869635e053b96485cd2e6f",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>
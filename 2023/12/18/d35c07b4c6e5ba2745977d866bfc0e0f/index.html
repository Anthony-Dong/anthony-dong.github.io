<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anthony-dong.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="C++模板是一种强大的工具，主要被用于实现泛型编程。泛型编程允许你编写能够处理任何类型的代码，同时保持类型安全和性能。"><meta property="og:type" content="article"><meta property="og:title" content="C++模版"><meta property="og:url" content="https://anthony-dong.github.io/2023/12/18/d35c07b4c6e5ba2745977d866bfc0e0f/index.html"><meta property="og:site_name" content="Anthony-Dong"><meta property="og:description" content="C++模板是一种强大的工具，主要被用于实现泛型编程。泛型编程允许你编写能够处理任何类型的代码，同时保持类型安全和性能。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/12-17/70dde801f5c143e080e920fe0da2e6b2.png"><meta property="article:published_time" content="2023-12-18T08:31:50.000Z"><meta property="article:modified_time" content="2024-03-03T07:42:21.998Z"><meta property="article:author" content="Anthony-Dong"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/12-17/70dde801f5c143e080e920fe0da2e6b2.png"><link rel="canonical" href="https://anthony-dong.github.io/2023/12/18/d35c07b4c6e5ba2745977d866bfc0e0f/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++模版 | Anthony-Dong</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?899b2a5c34078209c5f30853eaaa7846";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anthony-Dong</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Anthony-Dong技术博客</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Anthony-Dong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anthony-dong.github.io/2023/12/18/d35c07b4c6e5ba2745977d866bfc0e0f/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Anthony-Dong"><meta itemprop="description" content="喜欢写代码"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anthony-Dong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++模版</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-12-18 16:31:50" itemprop="dateCreated datePublished" datetime="2023-12-18T16:31:50+08:00">2023-12-18</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-03-03 15:42:21" itemprop="dateModified" datetime="2024-03-03T15:42:21+08:00">2024-03-03</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>28k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>25 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>C++模板是一种强大的工具，主要被用于实现泛型编程。泛型编程允许你编写能够处理任何类型的代码，同时保持类型安全和性能。</p><span id="more"></span><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>C++模板是一种强大的工具，主要被用于实现泛型编程。泛型编程允许你编写能够处理任何类型的代码，同时保持类型安全和性能。以下是模板在日常开发中的一些常见应用场景：</p><ol><li><strong>容器类</strong>：C++标准库中的许多工具，如<code>std::vector</code>，<code>std::map</code>，<code>std::array</code>等，都使用模板来处理任意类型的数据。</li><li><strong>算法</strong>：标准库中的算法如<code>std::sort</code>，<code>std::find</code>等，都使用模板来处理容器中的任意类型的数据。</li><li><strong>智能指针</strong>：如<code>std::unique_ptr</code>、<code>std::shared_ptr</code>等，都用模板实现，可以用来处理任何类型的数据。</li><li><strong>元编程</strong>：模板元编程（TMP）是种利用模板机制执行在编译期的计算的技术。TMP可以用来生成在编译期确定的数据结构和算法，有助于优化程序性能。</li><li><strong>类型萃取</strong>：通过模板，我们可以编写只在某些满足特定条件的类型上起作用的代码。例如，你可以创建一个模板，它接受一个参数，并有一个静态断言来检查这个类型是否具有某个特定的成员函数。</li><li><strong>策略模式</strong>：在运行时根据策略的改变而改变对象的行为。通过模板，你可以在编译期决定使用哪种策略，这样可以避免在运行期的性能损失。</li></ol><p>这些都是模板在日常 C++ 编程中的一些应用。注意，模板是一个深奔蓝似海的主题，你可以通过学习和实践来掌握它更多的使用方法和技巧。</p><blockquote><p>from chatgpt</p></blockquote><p>注意：不同语言对于泛型的底层实现是不一样的，C++是基于模版去做的，模版就比如vue/react的模版、GO的template、别的一些模版库他们都是模版，只不过C++模版主要是用来处理泛型的，然后编译器在预处理阶段将模版代码实例化（帮你代码生成）！最后 C++模版是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Turing_completeness">图灵完备</a>语言，所以c++模版只有你想不到的，没有它做不到的，它非常的强大！</p><h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>数据结构(容器)这块应该是任何语言都应该提供的！常见的数据结构就是 list/map, 然后他们引出了很多分类，C++提供了一些常见的数据结构，可以看下面的示例代码：<a target="_blank" rel="noopener" href="https://godbolt.org/z/YP7WeEGPs">https://godbolt.org/z/YP7WeEGPs</a>，我个人比较喜欢Go/Python的设计仅支持list/map别的自行实现，好处在于不需要记忆大量的的API！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_c</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    std::for_each(t.<span class="built_in">begin</span>(), t.<span class="built_in">end</span>(), [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; elem) &#123;</span><br><span class="line">        std::cout &lt;&lt; elem &lt;&lt; <span class="string">&quot; ,&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// vector 底层是数组，读写性能会高很多</span></span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; arrary_list = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">print_c</span>(arrary_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// list 底层是链表，适合随机插入删除等操作</span></span><br><span class="line">    std::list&lt;<span class="keyword">int</span>&gt; linked_list = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">print_c</span>(linked_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.cppreference.com/w/cpp/container/queue</span></span><br><span class="line">    <span class="comment">// 底层默认是双端队列(dqueue), queue: 先进先出/后进后出</span></span><br><span class="line">    std::queue&lt;<span class="keyword">int</span>&gt; double_end_queue;</span><br><span class="line">    double_end_queue.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    double_end_queue.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    double_end_queue.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_end_queue [ &quot;</span> &lt;&lt; double_end_queue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; double_end_queue.<span class="built_in">back</span>() &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    double_end_queue.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_end_queue [ &quot;</span> &lt;&lt; double_end_queue.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; double_end_queue.<span class="built_in">back</span>() &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.cppreference.com/w/cpp/container/stack</span></span><br><span class="line">    <span class="comment">// 底层默认是双端队列(dqueue), stack: 先进后出/后进先出</span></span><br><span class="line">    std::stack&lt;<span class="keyword">int</span>&gt; double_end_stack;</span><br><span class="line">    double_end_stack.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    double_end_stack.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">    double_end_stack.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_end_stack-top [ &quot;</span> &lt;&lt; double_end_stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    double_end_stack.<span class="built_in">pop</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;double_end_stack-top [ &quot;</span> &lt;&lt; double_end_stack.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot;]&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.cppreference.com/w/cpp/container/unordered_map</span></span><br><span class="line">    <span class="comment">// unordered_map 就是Java中的HashMap, 底层是红黑树，读写性能会高一些</span></span><br><span class="line">    std::unordered_map&lt;std::string, <span class="keyword">int</span>&gt; hash_map = &#123;&#123;<span class="string">&quot;1&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;2&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;3&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kv : hash_map) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hash_map: [&quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// https://en.cppreference.com/w/cpp/container/map</span></span><br><span class="line">    <span class="comment">// map(ordered_map) 就是Java中的TreeMap, 底层是平衡二叉树，读写性能会低一些</span></span><br><span class="line">    std::map&lt;std::string, <span class="keyword">int</span>&gt; tree_map = &#123;&#123;<span class="string">&quot;1&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;2&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;3&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; kv : tree_map) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;tree_map: [&quot;</span> &lt;&lt; kv.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; kv.second &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// [ 1 ,2 ,3 ,]</span></span><br><span class="line"><span class="comment">// [3 ,4 ,5 ,]</span></span><br><span class="line"><span class="comment">// double_end_queue [ 1, 3]</span></span><br><span class="line"><span class="comment">// double_end_queue [ 2, 3]</span></span><br><span class="line"><span class="comment">// double_end_stack-top [ 3]</span></span><br><span class="line"><span class="comment">// double_end_stack-top [ 2]</span></span><br><span class="line"><span class="comment">// hash_map: [2: 2]</span></span><br><span class="line"><span class="comment">// hash_map: [3: 3]</span></span><br><span class="line"><span class="comment">// hash_map: [1: 1]</span></span><br><span class="line"><span class="comment">// tree_map: [1: 1]</span></span><br><span class="line"><span class="comment">// tree_map: [2: 2]</span></span><br><span class="line"><span class="comment">// tree_map: [3: 3]</span></span><br></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法本质上就是业务逻辑的抽象，在日常大部分需求中主要就是排序，剩余的就是一些去重过滤、类型转换等操作了，这部分核心体现的是抽象，说白了就是些<strong>工具包</strong>！</p><p>C++里用 <a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp">absl</a> 这种工具包就行了或者别的吧，这部分存粹是造轮子所以大家不需要太关心，底层算法自己了解一下就行了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_desc</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">auto</span> i, <span class="keyword">auto</span> j) &#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt; j;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">sort_desc</span>(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我以最简单的快速排序为例子，临时写的，代码写的比较垃圾见谅</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">    arr[j] = arr[i];</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [5] 3 4 2 6 1 7</span></span><br><span class="line"><span class="comment">//             1 7</span></span><br><span class="line"><span class="comment">//     3 4 2 6</span></span><br><span class="line"><span class="comment">//     3 4 2 1 6 7</span></span><br><span class="line"><span class="comment">//           1</span></span><br><span class="line"><span class="comment">//  1  3 4 2 5 6 7</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_helper</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = arr[left];</span><br><span class="line">    <span class="keyword">int</span> flag_index = left;</span><br><span class="line">    left = left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != left) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt; flag &amp;&amp; right &gt; left) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; flag &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; arr[left]) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag_index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr, flag_index, left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// quick_sort_helper_gpt 写的... 代码不容易理解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_helper_gpt</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[low];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; array[high] &gt;= pivot) --high;</span><br><span class="line">        array[low] = array[high];</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; array[low] &lt;= pivot) ++low;</span><br><span class="line">        array[high] = array[low];</span><br><span class="line">    &#125;</span><br><span class="line">    array[low] = pivot;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; arr = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">quick_sort_helper</span>(arr, <span class="number">0</span>, <span class="built_in"><span class="keyword">int</span></span>(arr.<span class="built_in">size</span>() - <span class="number">1</span>)) &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">print</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么这个例子有个问题，仅支持 std::vector 和 int 类型，怎么解决呢？此时就需要使用模版了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Array&lt;T&gt;&amp; arr, <span class="keyword">typename</span> Array&lt;T&gt;::size_type i, <span class="keyword">typename</span> Array&lt;T&gt;::size_type j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">    arr[j] = arr[i];</span><br><span class="line">    arr[i] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_helper</span><span class="params">(Array&lt;T&gt;&amp; arr, <span class="keyword">typename</span> Array&lt;T&gt;::size_type left, <span class="keyword">typename</span> Array&lt;T&gt;::size_type right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(Array&lt;T&gt;&amp; arr, <span class="keyword">typename</span> Array&lt;T&gt;::size_type left, <span class="keyword">typename</span> Array&lt;T&gt;::size_type right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> index = <span class="built_in">quick_sort_helper</span>(arr, left, right);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, left, index - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">quick_sort</span>(arr, index + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> <span class="title">Array</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort_helper</span><span class="params">(Array&lt;T&gt;&amp; arr, <span class="keyword">typename</span> Array&lt;T&gt;::size_type left, <span class="keyword">typename</span> Array&lt;T&gt;::size_type right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> flag = arr[left];</span><br><span class="line">    <span class="keyword">int</span> flag_index = left;</span><br><span class="line">    left = left + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (right != left) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[right] &gt; flag &amp;&amp; right &gt; left) &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (arr[left] &lt; flag &amp;&amp; left &lt; right) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag &lt; arr[left]) &#123;</span><br><span class="line">        <span class="keyword">return</span> flag_index;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr, flag_index, left);</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版元编程-TMP"><a href="#模版元编程-TMP" class="headerlink" title="模版元编程 (TMP)"></a>模版元编程 (TMP)</h2><p>这个太难了，不建议学习，直接pass掉吧，下面这种简单例子，照葫芦画瓢还行，复杂一点的直接就废了看不懂，当你阅读C++模版+模版动态参数的时候那么久该放弃了，虽然C++17提供了一些模版动态参数表达式，有兴趣可以看下这个文章 <a target="_blank" rel="noopener" href="https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr/">C++17 constexpr</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// factorial 阶乘</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> <span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factorial</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">        value = n * factorial&lt;n - <span class="number">1</span>&gt;::value</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factorial</span>&lt;</span><span class="number">0</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">        value = <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> fact_5 = factorial&lt;<span class="number">5</span>&gt;::value; <span class="comment">// 会在编译时计算为 120</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;5! = &quot;</span> &lt;&lt; fact_5 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们可以使用 <code>constexpr</code> 也可以实现类似的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">factorial</span>(<span class="number">5</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后说实话对于这种存粹的数值计算，C++的编译器已经给你做了，不信我们把 constexpr 去了开启 -O3 优化，代码链接: <a target="_blank" rel="noopener" href="https://godbolt.org/z/e5Thh7GYG">https://godbolt.org/z/e5Thh7GYG</a>，所以大部分情况下我们没有编译器聪明，所以这种编译计算的技巧说实话不如交给编译器去做，我们呢只负责写代码就行了！！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/12-17/70dde801f5c143e080e920fe0da2e6b2.png" alt="image-20231217232841126"></p><h2 id="类型萃取-trait"><a href="#类型萃取-trait" class="headerlink" title="类型萃取 (trait)"></a>类型萃取 (trait)</h2><p>对于大部分C++开发者来说，这个我觉得是C++模版的核心了，因此我们需要根据trait需要编写一些复杂的模版代码！在C++ 中<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/header/type_traits">type_traits</a>头文件已经提供了大量的trait函数，实际上我们一些简单的trait直接使用它提供的就行了！</p><p>trait是C++类型处理的核心实现，因为C++这个语言不会在提供runtime阶段提供类型判断，即大部分涉及到类型判断的逻辑都需要在编译阶段解决，这个原因也是为了代码的性能，即模版不会带到运行时！</p><h3 id="trait-类型"><a href="#trait-类型" class="headerlink" title="trait 类型"></a>trait 类型</h3><p>下面是简单实现了一个 <code>is_integral&lt;T&gt;</code> 的trait，本质上是用了C++类模版的重载实现的，相对来说比较简单和易读！</p><p>代码地址: <a target="_blank" rel="noopener" href="https://godbolt.org/z/hGvMrPrbW">https://godbolt.org/z/hGvMrPrbW</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span> :</span> std::false_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span>&lt;</span><span class="keyword">char</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span>&lt;</span><span class="keyword">short</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span>&lt;</span><span class="keyword">int</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral</span>&lt;</span><span class="keyword">long</span>&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">bool</span> is_integral_v = is_integral&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_integral_v&lt;std::string&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_integral_v&lt;<span class="keyword">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子显然是最简单的，日常需求大部分trait类型基本都可以参考上面这种写法，不过像<code>std::is_convertible</code> 和 <code>std::is_same</code> 这种实现可能会和上诉这个类型判断有差异的，感兴趣的人可以详细了解下！</p><h3 id="trait-方法"><a href="#trait-方法" class="headerlink" title="trait 方法"></a>trait 方法</h3><p>例如我要判断一个类型是否有 <code>std::string to_string()</code> 方法？ 通常我们都是定义一个类去判断，这种比较方便，定义方法的比较少！</p><p>下面代码本质上就是利用了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a> (Substitution Failure Is Not An Error) 这个也是C++20之前模版编程的核心了，其本质是一种模版匹配机制，即我会在所有的模版定义中去匹配，哪个匹配成功用哪个，其次它匹配不会去匹配你的代码逻辑只会匹配你的模版申明，注意这个！</p><p>代码地址： <a target="_blank" rel="noopener" href="https://godbolt.org/z/adG7nMGWf">https://godbolt.org/z/adG7nMGWf</a>，这个例子核心就是了解下 <code>std::declval</code> 的用法，我个人感觉这个属于编译器的一个test行为和decltype本质上应该是一样的！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">1. 继承 std::false_type</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_to_string_func : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">偏特化 has_to_string_func 方法，继承 std::true_type</span></span><br><span class="line"><span class="comment">1. std::is_same_v&lt;T1,T2&gt; 这个主要是进行判断类型是否相等</span></span><br><span class="line"><span class="comment">2. std::enable_if_t&lt;bool,void&gt; 上面相等判断完成后需要进行bool表达式判断，因此  std::enable_if_t 进行判断</span></span><br><span class="line"><span class="comment">3. std::declval&lt;T&gt;() 可以创建一个类型T的对象，注意这个实际上不会创建，只是编译器的一种模版匹配机制</span></span><br><span class="line"><span class="comment">4. decltype 这个就很简单了，就是提取类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_to_string_func</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::declval&lt;T&gt;().<span class="built_in">to_string</span>()), std::string&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">    <span class="function">std::string <span class="title">to_string2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test3</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">to_string</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; has_to_string_func&lt;Test&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; has_to_string_func&lt;Test2&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; has_to_string_func&lt;Test3&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="实现to-string方法"><a href="#实现to-string方法" class="headerlink" title="实现to_string方法"></a>实现to_string方法</h3><p>上面这个例子实际上我们会发现有个缺点即需要用户在类里面申明<code>to_string()</code> 方法，这个缺点太坑了侵入型比较大，而且可能不同框架对于 <code>to_string()</code> 方法的函数签名要求不一样，所以通常做法都是通过模版类特化的方式实现 <code>to_string()</code> 方法！</p><p>我们知道Go支持interface, rust支持trait，实际上两者对于此场景提供了很好的支持，这里我觉得比较方便的是rust的trait，因此我们可以参考rust的trait的实现来实现一个可拓展的 Stringer trait，说实话我是参考的libfmt! （注意: rust大部分思想应该来源于c++，只不过取其精华罢了）</p><ol><li>定义模版类<code>Stringer</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span> &#123;</span></span><br><span class="line">    <span class="built_in">Stringer</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>实现一个 <code>Stringer</code> 类型的trait，代码地址: <a target="_blank" rel="noopener" href="https://godbolt.org/z/YxjfMa6qd">https://godbolt.org/z/YxjfMa6qd</a></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span> &#123;</span></span><br><span class="line">    <span class="built_in">Stringer</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct is_stringer : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_stringer</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::declval&lt;Stringer&lt;T&gt;&gt;().<span class="built_in">to_string</span>(std::declval&lt;T&gt;())), std::string&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span>&lt;</span>Test&gt; &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> Test&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span>&lt;</span>Test2&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test3</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_stringer&lt;Test&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_stringer&lt;Test2&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_stringer&lt;Test3&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>至此呢我们就可以实现一个可拓展比较高的 <code>to_string</code> 方法，代码地址: <a target="_blank" rel="noopener" href="https://godbolt.org/z/Tq99aq3MP">https://godbolt.org/z/Tq99aq3MP</a></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span> &#123;</span></span><br><span class="line">    <span class="built_in">Stringer</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct is_stringer : std::false_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_stringer</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::declval&lt;Stringer&lt;T&gt;&gt;().<span class="built_in">to_string</span>(std::declval&lt;T&gt;())), std::string&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct has_to_string_func : std::false_type &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">has_to_string_func</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::declval&lt;T&gt;().<span class="built_in">to_string</span>()), std::string&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::<span class="keyword">enable_if_t</span>&lt;has_to_string_func&lt;T&gt;::value, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">to_string</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::<span class="keyword">enable_if_t</span>&lt;is_stringer&lt;T&gt;::value, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> (Stringer&lt;T&gt;&#123;&#125;).<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::<span class="keyword">enable_if_t</span>&lt;std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">inline</span> std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::<span class="built_in">string</span>(std::declval&lt;T&gt;())), std::string&gt;, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Test1(&quot;</span> + std::<span class="built_in">string</span>(<span class="string">&quot;name=&quot;</span>) + name + <span class="string">&quot;, f2=&quot;</span> + ::<span class="built_in">to_string</span>(age) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">    std::string f1;</span><br><span class="line">    <span class="keyword">int</span> f2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span>&lt;</span>Test2&gt; &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> Test2&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Test2(&quot;</span> + std::<span class="built_in">string</span>(<span class="string">&quot;f1=&quot;</span>) + t.f1 + <span class="string">&quot;, f2=&quot;</span> + ::<span class="built_in">to_string</span>(t.f2) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(Test1&#123;.name = <span class="string">&quot;tom&quot;</span>, .age = <span class="number">18</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(Test2&#123;.f1 = <span class="string">&quot;F1&quot;</span>, .f2 = <span class="number">2</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">false</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">true</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1.11</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1111</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Test1(name=tom, f2=18)</span></span><br><span class="line"><span class="comment">// Test2(f1=F1, f2=2)</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1.110000</span></span><br><span class="line"><span class="comment">// 1111</span></span><br><span class="line"><span class="comment">// 1111</span></span><br></pre></td></tr></table></figure><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><h4 id="rust-trait"><a href="#rust-trait" class="headerlink" title="rust-trait"></a>rust-trait</h4><p>上诉我讲到了rust的trait，这里我们可以简单写一个Stringer trait，说实话我发现rust的写法真像python+typehints</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="built_in">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="built_in">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> hello_cargo::Tweet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Stringer</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_string</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Stringer <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">to_string</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;Tweet username: &#123;&#125;, content: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>(item: &amp;<span class="keyword">impl</span> Stringer) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;test func: &#123;&#125;&quot;</span>, item.to_string());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">&quot;xiaoming&quot;</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">&quot;from chinese&quot;</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news &#123;&#125;&quot;</span>, tweet.to_string());</span><br><span class="line">    test(&amp;tweet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>执行</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">➜  bazel_simple git:(master) ✗ cargo run</span><br><span class="line">   Compiling hello_cargo v0.1.0 (/Users/bytedance/go/src/github.com/anthony-dong/bazel_simple)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.23s</span><br><span class="line">     Running `target/debug/hello_cargo`</span><br><span class="line">Breaking news Tweet username: xiaoming, content: from chinese</span><br><span class="line">test func: Tweet username: xiaoming, content: from chinese</span><br></pre></td></tr></table></figure><h4 id="libfmt"><a href="#libfmt" class="headerlink" title="libfmt"></a>libfmt</h4><p>我个人觉得你如果能写出来 libfmt 这种框架，那么你对于C++的模版的理解已经超越了99% 的人了！</p><p>下面我们可以简单使用下libfmt实现一个logger库，自己编译的话选择cmake自己构建下就行了！</p><ol><li><code>cpp/log/logger.h</code> 文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;fmt/core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cpp/utils/time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;absl/time/time.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;absl/time/clock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> cpp::log &#123;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Level</span> &#123;</span></span><br><span class="line">    Debug,</span><br><span class="line">    Info,</span><br><span class="line">    Warn,</span><br><span class="line">    Error,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NAMESPACE cpp::log</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO(...) LOG_NAMESPACE::Log(LOG_NAMESPACE::Level::Info, __FILE__, __LINE__, __FUNCTION__, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Log</span><span class="params">(Level level, <span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">int</span> line, <span class="keyword">const</span> <span class="keyword">char</span>* func, fmt::format_string&lt;Args...&gt; format, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> file_base = [](<span class="keyword">const</span> <span class="keyword">char</span>* name) -&gt; std::string &#123;</span><br><span class="line">        <span class="keyword">const</span> std::string_view <span class="built_in">file</span>(name);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> index = file.<span class="built_in">find_last_of</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;file.<span class="built_in">begin</span>() + index + <span class="number">1</span>, file.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">using</span> clock = std::chrono::system_clock;</span><br><span class="line">    <span class="keyword">static</span> std::unordered_map&lt;Level, std::string&gt; level_string_map = &#123;</span><br><span class="line">        &#123;Level::Debug, <span class="string">&quot;DEBUG&quot;</span>&#125;,</span><br><span class="line">        &#123;Level::Info, <span class="string">&quot;INFO&quot;</span>&#125;,</span><br><span class="line">        &#123;Level::Warn, <span class="string">&quot;WARN&quot;</span>&#125;,</span><br><span class="line">        &#123;Level::Error, <span class="string">&quot;ERROR&quot;</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> level_name = level_string_map[level];</span><br><span class="line">    <span class="keyword">if</span> (level_name.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        level_name = <span class="string">&quot;-&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt::<span class="built_in">println</span>(<span class="string">&quot;[&#123;&#125;] &#123;&#125; &#123;&#125;:&#123;&#125; &#123;&#125;&quot;</span>, level_name, absl::<span class="built_in">FormatTime</span>(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, absl::<span class="built_in">Now</span>(), absl::<span class="built_in">LocalTimeZone</span>()), <span class="built_in">file_base</span>(filename), line, fmt::format(format, std::forward&lt;Args&gt;(args)...));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace cpp::log</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>test/log/logger_test.cpp</code> 文件</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;gtest/gtest.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;cpp/log/logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;source_location&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyTest</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nop</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;Nop&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Context&gt;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">parse</span><span class="params">(Context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 特化模版 fmt::formatter&lt;T&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;MyTest&gt; : fmt::formatter&lt;Nop&gt; &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Context&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">format</span><span class="params">(<span class="keyword">const</span> MyTest&amp; data, Context&amp; ctx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fmt::format_to(ctx.<span class="built_in">out</span>(), <span class="string">&quot;name: &#123;&#125;. age: &#123;&#125;&quot;</span>, data.name, data.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST</span>(LogTest, Print) &#123;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;hello &#123;&#125;&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line">    MyTest data&#123;.age = <span class="number">1</span>, .name = <span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;MyTest &#123;&#125;&quot;</span>, data);</span><br><span class="line"></span><br><span class="line">    cpp::log::<span class="built_in">Log</span>(cpp::log::Level::Debug, <span class="string">&quot;logger_test.cpp&quot;</span>, <span class="number">7</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;hello &#123;&#125;&quot;</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意c++20支持sourcelocation，更加的easy https://en.cppreference.com/w/cpp/utility/source_location</span></span><br><span class="line">    std::source_location location = std::source_location::<span class="built_in">current</span>();</span><br><span class="line">    <span class="built_in">INFO</span>(<span class="string">&quot;source_location: filename: &#123;&#125;, line: &#123;&#125;&quot;</span>, location.<span class="built_in">file_name</span>(), location.<span class="built_in">line</span>()); <span class="comment">// logger_test.cpp,  37</span></span><br><span class="line">&#125;:</span><br></pre></td></tr></table></figure><p>3.output</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO] 2023-12-18 16:13:22 logger_test.cpp:29 hello world</span><br><span class="line">[INFO] 2023-12-18 16:13:22 logger_test.cpp:32 MyTest name: hello. age: 1</span><br><span class="line">[DEBUG] 2023-12-18 16:13:22 logger_test.cpp:7 hello 1111</span><br><span class="line">[INFO] 2023-12-18 16:13:22 logger_test.cpp:38 source_location: filename: /Users/bytedance/go/src/github.com/anthony-dong/cpp/test/log/logger_test.cpp, line: 37</span><br></pre></td></tr></table></figure><h4 id="模版匹配机制"><a href="#模版匹配机制" class="headerlink" title="模版匹配机制"></a>模版匹配机制</h4><ol><li>我们首先写一个 to_string 函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;    <span class="comment">// pass</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">true</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>我们发现这个函数不满足我们需求，比如参数是一个 string 类型上面代码走不通，因此我改成了，此时问题来了，编译器直接爆错<code>redefinition of &#39;to_string&#39;</code>，这个报错我理解大家都懂重复定义了函数！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>我们继续改，解决这个问题，那么此时函数签名不一致了，但是我们执行报错说 <code>call to &#39;to_string&#39; is ambiguous</code></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123; <span class="comment">// #1</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="keyword">enable_if_t</span>&lt;std::is_convertible_v&lt;T, std::string&gt;, std::string&gt; <span class="built_in">to_string</span>(T t) &#123; <span class="comment">// #2</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// pass</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">true</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// pass</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>继续改，我们需要解决二义性问题，即一个类型不能匹配成功两个函数，比如上面这个例子就是输入参数 <code>t=&quot;1111&quot;</code>它既可以匹配<code>#1</code>的模版，也可以匹配 <code>#2</code>的模版 ，这个就是二义性问题，即不能同时匹配多个模版函数！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;<span class="keyword">decltype</span>(std::<span class="built_in">to_string</span>(std::declval&lt;T&gt;())), std::string&gt;, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::<span class="keyword">enable_if_t</span>&lt;std::is_convertible_v&lt;T, std::string&gt;, std::string&gt; <span class="built_in">to_string</span>(T t) &#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;      <span class="comment">// pass</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">true</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>;   <span class="comment">// pass</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// pass</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concept"><a href="#concept" class="headerlink" title="concept"></a><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constraints">concept</a></h2><p>上面例子我们发现写法非常的丑陋，大量使用<code>std::enable_if</code>, 本质上concept就是替换这种写法的，功能是一模一样的！我们可以使用 concept重写上面的代码，注意concept是c++20提供的！其次concept的报错上会优于模版！</p><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>类型约束，其实就是要替代上面讲到的trait类型，写法也比较简单，这里不多赘述了，具体可以看下面的代码: <a target="_blank" rel="noopener" href="https://godbolt.org/z/xze71f49W">https://godbolt.org/z/xze71f49W</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_numeric = std::same_as&lt;T, <span class="keyword">int</span>&gt; || std::same_as&lt;T, <span class="keyword">float</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质上就是下面这个代码，我们发现concept是不是非常简单呢！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct is_numeric_c : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_numeric_c</span>&lt;</span>T, std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;T, <span class="keyword">int</span>&gt; || std::is_same_v&lt;T, <span class="keyword">float</span>&gt;&gt;&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_numeric&lt;<span class="keyword">int</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_numeric&lt;<span class="keyword">float</span>&gt; &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_numeric&lt;<span class="keyword">bool</span>&gt; &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; is_numeric_c&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_numeric_c&lt;<span class="keyword">float</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_numeric_c&lt;<span class="keyword">bool</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="复杂类型约束"><a href="#复杂类型约束" class="headerlink" title="复杂类型约束"></a>复杂类型约束</h3><p>复杂类型约束, 这里我们可以实现类似于 Go的 Writer/Reader 接口，具体可以看下面这个例子：<a target="_blank" rel="noopener" href="https://godbolt.org/z/PfrrrfjGG">https://godbolt.org/z/PfrrrfjGG</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;concepts&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// go 里面我们定义了一个 ReadWriter</span></span><br><span class="line"><span class="comment">// type Reader interface &#123;</span></span><br><span class="line"><span class="comment">//	Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// type Writer interface &#123;</span></span><br><span class="line"><span class="comment">//	Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="comment">// ReadWriter is the interface that groups the basic Read and Write methods.</span></span><br><span class="line"><span class="comment">// type ReadWriter interface &#123;</span></span><br><span class="line"><span class="comment">//	Reader</span></span><br><span class="line"><span class="comment">//	Writer</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在C++中我们可以定义一个 concept来实现， 是不是非常牛逼哇！！！</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Reader = <span class="built_in"><span class="keyword">requires</span></span>(T t) &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in"><span class="keyword">requires</span></span>(std::string&amp; buffer) &#123;</span><br><span class="line">        &#123; t.<span class="built_in">Read</span>(buffer) &#125; -&gt; std::same_as&lt;<span class="keyword">size_t</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> Writer = <span class="built_in"><span class="keyword">requires</span></span>(T t) &#123;</span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in"><span class="keyword">requires</span></span>(std::string&amp; buffer) &#123;</span><br><span class="line">        &#123; t.<span class="built_in">Write</span>(buffer) &#125; -&gt; std::same_as&lt;<span class="keyword">size_t</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> ReadWriter = Reader&lt;T&gt; &amp;&amp; Writer&lt;T&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单实现一个StringBuffer</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringBuffer</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">StringBuffer</span><span class="params">(std::string&amp;&amp; buffer)</span> : buffer_(std::move(buffer)) &#123;</span></span><br><span class="line">        w = buffer_.<span class="built_in">size</span>();</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">Read</span><span class="params">(std::string&amp; buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> size = buffer.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (w == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (w - r &lt; size) &#123;</span><br><span class="line">            size = w - r;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">copy</span>(buffer_.<span class="built_in">begin</span>() + <span class="built_in"><span class="keyword">long</span></span>(r), buffer_.<span class="built_in">begin</span>() + <span class="built_in"><span class="keyword">long</span></span>(r) + <span class="built_in"><span class="keyword">long</span></span>(size), buffer.<span class="built_in">begin</span>());</span><br><span class="line">        r = r + size;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">Write</span><span class="params">(std::string&amp; buffer)</span> </span>&#123;</span><br><span class="line">        buffer_.<span class="built_in">append</span>(buffer, <span class="number">0</span>, buffer.<span class="built_in">size</span>());</span><br><span class="line">        w = w + buffer.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> buffer.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">Write</span><span class="params">(std::string&amp;&amp; buffer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Write</span>(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> r, w;</span><br><span class="line">    std::string buffer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现ioutil.ReadAll(reader) 方法</span></span><br><span class="line"><span class="keyword">template</span> &lt;ReadWriter Rw&gt;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ReadAll</span><span class="params">(Rw&amp; reader, std::string&amp; buffer)</span> </span>&#123;</span><br><span class="line">    buffer.<span class="built_in">clear</span>();</span><br><span class="line">    std::string bw&#123;&#125;;</span><br><span class="line">    bw.<span class="built_in">resize</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> size = reader.<span class="built_in">Read</span>(bw); size &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer.<span class="built_in">append</span>(bw, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buffer.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">StringBuffer <span class="title">sb</span><span class="params">(<span class="string">&quot;C++是世界上最好的语言&quot;</span>)</span></span>;</span><br><span class="line">    sb.<span class="built_in">Write</span>(<span class="string">&quot;!!!!!&quot;</span>);</span><br><span class="line">    std::string buffer&#123;&#125;;</span><br><span class="line">    <span class="built_in">ReadAll</span>(sb, buffer);</span><br><span class="line">    std::cout &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// C++是世界上最好的语言!!!!!</span></span><br></pre></td></tr></table></figure><h3 id="实现to-string方法-1"><a href="#实现to-string方法-1" class="headerlink" title="实现to_string方法"></a>实现to_string方法</h3><p>我们还是以上面trait里讲到的 to_string 方法进行重写，代码地址: <a target="_blank" rel="noopener" href="https://godbolt.org/z/vqxfqEY66">https://godbolt.org/z/vqxfqEY66</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;concepts&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span> &#123;</span></span><br><span class="line">    <span class="built_in">Stringer</span>() = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> has_to_string_func = <span class="built_in"><span class="keyword">requires</span></span>(T t) &#123;</span><br><span class="line">    <span class="comment">// &#123;expression&#125; noexcept(optional) -&gt; type-constraint;</span></span><br><span class="line">    <span class="comment">// 本质上就是，std::is_same_v&lt;decltype(std::declval&lt;Stringer&lt;T&gt;&gt;().to_string(std::declval&lt;T&gt;())), std::string&gt;</span></span><br><span class="line">    &#123; t.<span class="built_in">to_string</span>() &#125; -&gt; std::same_as&lt;std::string&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_stringer = <span class="built_in"><span class="keyword">requires</span></span>(T t) &#123;</span><br><span class="line">    <span class="comment">// &#123;expression&#125; noexcept(optional) -&gt; type-constraint;</span></span><br><span class="line">    <span class="keyword">requires</span> <span class="built_in"><span class="keyword">requires</span></span>(Stringer&lt;T&gt; s) &#123;</span><br><span class="line">        &#123; s.<span class="built_in">to_string</span>(t) &#125; -&gt; std::same_as&lt;std::string&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以这么写，不过推荐上面这种写法</span></span><br><span class="line">    <span class="comment">//    &#123; std::declval&lt;Stringer&lt;T&gt;&gt;().to_string(t) &#125; -&gt; std::same_as&lt;std::string&gt;;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;has_to_string_func T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">to_string</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;is_stringer T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (Stringer&lt;T&gt;&#123;&#125;).<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">requires</span> std::is_integral_v&lt;T&gt; || <span class="function">std::is_floating_point_v&lt;T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">to_string</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">requires</span> std::convertible_to&lt;T, std::string&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::string <span class="title">to_string</span><span class="params">(<span class="keyword">bool</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Test1(&quot;</span> + std::<span class="built_in">string</span>(<span class="string">&quot;name=&quot;</span>) + name + <span class="string">&quot;, f2=&quot;</span> + ::<span class="built_in">to_string</span>(age) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">    std::string f1;</span><br><span class="line">    <span class="keyword">int</span> f2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stringer</span>&lt;</span>Test2&gt; &#123;</span><br><span class="line">    <span class="function">std::string <span class="title">to_string</span><span class="params">(<span class="keyword">const</span> Test2&amp; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Test2(&quot;</span> + std::<span class="built_in">string</span>(<span class="string">&quot;f1=&quot;</span>) + t.f1 + <span class="string">&quot;, f2=&quot;</span> + ::<span class="built_in">to_string</span>(t.f2) + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(Test1&#123;.name = <span class="string">&quot;tom&quot;</span>, .age = <span class="number">18</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(Test2&#123;.f1 = <span class="string">&quot;F1&quot;</span>, .f2 = <span class="number">2</span>&#125;) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">false</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="literal">true</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1.11</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="number">1111</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">to_string</span>(<span class="string">&quot;1111&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// Test1(name=tom, f2=18)</span></span><br><span class="line"><span class="comment">// Test2(f1=F1, f2=2)</span></span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1.110000</span></span><br><span class="line"><span class="comment">// 1111</span></span><br><span class="line"><span class="comment">// 1111</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="模版与左右值的关系"><a href="#模版与左右值的关系" class="headerlink" title="模版与左右值的关系"></a>模版与左右值的关系</h3><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++的模版可以说是C++的灵魂所在，例如上面的例子我们通过类模版的特化就很轻松的实现了一个 rust 的<code>trait</code> 类型哇，我们用 concept/template 就实现了类似于Go的Interface呢，所以C++的技巧太多了，平时可以多阅读一些优秀的代码，自己也会变得优秀！</p><p>我理解日常需求中我们只要学会了本文讲到的实际上已经基本够用了！</p><p>其次模版相关的文章太少了，大家有不懂的代码和语法直接问GPT就行了，说实话我也是问人家的，然后自己多动手！</p></div><div class="reward-container"><div>本人坚持原创技术分享，如果你觉得文章对您有用，请随意打赏! 如果有需要咨询的请发送到我的邮箱!</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Anthony-Dong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="Anthony-Dong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Anthony-Dong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anthony-dong.github.io/2023/12/18/d35c07b4c6e5ba2745977d866bfc0e0f/" title="C++模版">https://anthony-dong.github.io/2023/12/18/d35c07b4c6e5ba2745977d866bfc0e0f/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"># C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/09/16/91c61c1043b15978e6cca833236c4694/" rel="prev" title="C++ 继承的底层设计与原理"><i class="fa fa-chevron-left"></i> C++ 继承的底层设计与原理</a></div><div class="post-nav-item"><a href="/2024/02/28/d60ca162f1a2911c884053ddc7786384/" rel="next" title="HTTPS抓包的原理和实现">HTTPS抓包的原理和实现 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">容器类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E5%85%83%E7%BC%96%E7%A8%8B-TMP"><span class="nav-number">4.</span> <span class="nav-text">模版元编程 (TMP)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96-trait"><span class="nav-number">5.</span> <span class="nav-text">类型萃取 (trait)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#trait-%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.</span> <span class="nav-text">trait 类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#trait-%E6%96%B9%E6%B3%95"><span class="nav-number">5.2.</span> <span class="nav-text">trait 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0to-string%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">实现to_string方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%87%E6%B3%A8"><span class="nav-number">5.4.</span> <span class="nav-text">备注</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#rust-trait"><span class="nav-number">5.4.1.</span> <span class="nav-text">rust-trait</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#libfmt"><span class="nav-number">5.4.2.</span> <span class="nav-text">libfmt</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E5%8C%B9%E9%85%8D%E6%9C%BA%E5%88%B6"><span class="nav-number">5.4.3.</span> <span class="nav-text">模版匹配机制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#concept"><span class="nav-number">6.</span> <span class="nav-text">concept</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">6.1.</span> <span class="nav-text">类型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F"><span class="nav-number">6.2.</span> <span class="nav-text">复杂类型约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0to-string%E6%96%B9%E6%B3%95-1"><span class="nav-number">6.3.</span> <span class="nav-text">实现to_string方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">7.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E7%89%88%E4%B8%8E%E5%B7%A6%E5%8F%B3%E5%80%BC%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">7.1.</span> <span class="nav-text">模版与左右值的关系</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">8.</span> <span class="nav-text">总结</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Anthony-Dong" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Anthony-Dong</p><div class="site-description" itemprop="description">喜欢写代码</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">36</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">48</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anthony-dong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anthony-dong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@gmail.com" title="E-Mail → mailto:fanhaodong516@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/4248168663101320" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4248168663101320" rel="noopener" target="_blank"><i class="fas fa-book fa-fw"></i>掘金</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@163.com" title="国内邮箱 → mailto:fanhaodong516@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>国内邮箱</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Anthony-Dong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">520k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">7:52</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/medium-zoom.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.js",()=>{new Gitalk({clientID:"b1c466a9c5677a8d374a",clientSecret:"7cf9512c7e4b46b574e901b18983be7ae5b47d74",repo:"anthony-dong.github.io",owner:"Anthony-Dong",admin:["Anthony-Dong"],id:"d8b2341235e93d417575fe5817e704fa",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>
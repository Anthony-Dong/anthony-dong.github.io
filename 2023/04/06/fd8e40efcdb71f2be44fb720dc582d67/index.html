<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anthony-dong.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C&#x2F;C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C&#x2F;C++有着丰富的生态，很多高级语言也提供了接口可以对接C&#x2F;C++ (JNI&#x2F;CGO等) ，这样你可以很方便的将一些底层C&#x2F;C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门到放弃"><meta property="og:url" content="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/index.html"><meta property="og:site_name" content="Anthony-Dong"><meta property="og:description" content="C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C&#x2F;C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C&#x2F;C++有着丰富的生态，很多高级语言也提供了接口可以对接C&#x2F;C++ (JNI&#x2F;CGO等) ，这样你可以很方便的将一些底层C&#x2F;C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/10-6/7bd539e74f1c4a51b278966952888c7c.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/8-25/305c9fff224e4c5d998d19b8a51c6441.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/2a0b8ed1e97440e49abd23990d48cd77.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/668842e1a693400abc7faf276e4bcc8b.png"><meta property="article:published_time" content="2023-04-06T10:01:37.000Z"><meta property="article:modified_time" content="2023-11-27T07:35:07.607Z"><meta property="article:author" content="Anthony-Dong"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/10-6/7bd539e74f1c4a51b278966952888c7c.png"><link rel="canonical" href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++ 入门到放弃 | Anthony-Dong</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?899b2a5c34078209c5f30853eaaa7846";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anthony-Dong</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Anthony-Dong技术博客</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Anthony-Dong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Anthony-Dong"><meta itemprop="description" content="喜欢写代码"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anthony-Dong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ 入门到放弃</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-06 18:01:37" itemprop="dateCreated datePublished" datetime="2023-04-06T18:01:37+08:00">2023-04-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-11-27 15:35:07" itemprop="dateModified" datetime="2023-11-27T15:35:07+08:00">2023-11-27</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>54k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>49 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C/C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C/C++有着丰富的生态，很多高级语言也提供了接口可以对接C/C++ (JNI/CGO等) ，这样你可以很方便的将一些底层C/C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++写的，而非我从事C++相关领域开发！</p><p>个人觉得C++本身包含了几门语言：面向对象语言 + 内存管理语言 + 模版语言，其中最臭名昭著的就是模版，大量的SFINAE实现，难以理解的报错信息，让很多人讨厌C++，其次就是C++委员会对于各种语法的支持！</p><p>本篇文章会长期更新和补充，而且篇幅过长，我平时喜欢把学习语言语法相关的文档归类到一起，所以会存在体积较大的问题，方便平时当作工具书使用！</p><span id="more"></span><h2 id="学习环境"><a href="#学习环境" class="headerlink" title="学习环境"></a>学习环境</h2><p>个人觉得如果你是一个新手，一定要选一个利于学习的环境，个人比较推荐新手用 clion（或者vscode+clangd 非常适合非cmake项目或者比较大的项目）！目前C++ 版本应该已经到了C++23了 ！编译器的话比较推荐clang，编译工具的话推荐cmake，版本的话目前比较推荐 C++17，不过2023年了更加推荐C++20！camke学习成本并不是太高(bazel复杂度有点高)，可以看我写的文章: <a href="https://anthony-dong.github.io/2023/04/23/291f1489dc6255cedb0b626e74c04f9d/">cmake入门</a>！</p><ul><li>11：STL + 智能指针</li><li>14、17 优化了语法和新增部分API，所以如果不用c++20最好的选择就是c++17了！</li><li>20 支持了 coroutine(无栈协程)、concept(新版的SFINAE)、模块(目前还没大量使用)</li></ul><p>如果你是c++开发同学最好选择自己公司的编译工具和开发规范！C++规范，按照公司的来即可，如果没有的话可以参考Google的：<a target="_blank" rel="noopener" href="https://github.com/google/styleguide">https://github.com/google/styleguide</a></p><p>学习文档的话，语法学习仅建议学习官方文档：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language%EF%BC%8C">https://en.cppreference.com/w/cpp/language，</a> 原因就是内容最全面、分类最具体，如果你东看西看可能<strong>概念很模糊</strong>！技巧学习的话我建议多看看开源项目，其次就是看一下经验的书 <code>Effective c++</code> 和 <code>C++ Template 第二版</code>，实践才是硬道理。</p><p>C++的语法应该是没有任何一个语言能超越的，复杂恶心，所以死啃开源项目，啃完就好了，最难理解的就是模版元编程！</p><h2 id="从hello-world-开始"><a href="#从hello-world-开始" class="headerlink" title="从hello world 开始"></a>从hello world 开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不清楚大家对于上面代码比较好奇的是哪里了？比如说我好奇的是为啥<code>&lt;&lt;</code>就可以输出了， 为啥还可以 &lt;&lt; 实现 append 输出？ 对，这个就是我的疑问！</p><p>思考一下是不是等价于下面这个代码了？是不是很容易理解了就！可以把 <code>operator&lt;&lt;</code> 理解为一个方法名！ 具体细节下文会讲解！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">operator</span>&lt;&lt;(std::cout,<span class="string">&quot;Hello&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot; &quot;</span>).<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot;World!&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>注意C++很多时候都是跨端开发，所以具体基础类型得看你的系统环境，常见的基础类型你可以直接在 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a> 这里查看 ！</p><h3 id="char-和-char-和-std-string"><a href="#char-和-char-和-std-string" class="headerlink" title="char* 和 char[] 和 std::string"></a>char* 和 char[] 和 std::string</h3><blockquote><p>本块内容可以先了解一遍，看完本篇内容再回头看一下会理解一些！</p></blockquote><p>字符串在编程中处于一个必不可少的操作，那么C++中提供的 std::string 和 char* 区别在呢了？</p><p>简单来说<code>const char* xxx= &quot;字面量&quot;</code> 的性能应该是最高的，因为字面量分配在常量区域，更加安全，但是注意奥不可修改的！</p><p><code>char[]= &quot;字面量&quot; | new char[]&#123;&#125;</code> 分配在栈上或者堆上非常不安全，这种需求直接用 <code>std::vector</code> 或者 <code>std::array</code> 更好！</p><p><code>std::string</code> 在C++11有了移动语意后，性能已经在部分场景优化了很多，进行字符串操作比较多的话介意用这个，别乱用<code>std::string*</code> 。使用 <code>std::string</code> 一般不会涉及到内存安全问题，无非就是多几次拷贝！ <strong>如果用指针最好也别用裸指针，别瞎<code>new</code>，可以用智能指针，或者参数[引用]传递！</strong></p><p>下面是一个简单的例子，可以参考学习！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getStackStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 不能这么返回，属于不安全的行为，因为arr分配在栈上，你返回了一个栈上的地址，但是这个函数调用这个栈就消亡了，所以不安全!</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getConstStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不会有内存安全问题，就是永远指向常量池的一块内存</span></span><br><span class="line">    <span class="comment">// 对于这种代码，我们非常推荐用 const char*</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* arr = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getHeapStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stack 分配在栈上, 将数据拷贝到返回函数 arr上!</span></span><br><span class="line">    <span class="keyword">char</span> stack[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(stack) + <span class="number">1</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr, stack);</span><br><span class="line">    *arr = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 分配在堆上，我们返回了一个裸指针，用户需要手动释放，不释放有内存安全问题</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里std::string直接分配在堆上, 它的回收取决于 std::unique_ptr 的消亡, 具体有兴趣可以看下智能指针</span></span><br><span class="line"><span class="comment">// 注意: 千万别用函数返回一个裸指针，那么它是非常不安全的，需要手动释放!</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">getUniquePtrStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> str = std::unique_ptr&lt;std::string&gt;(<span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;hello world.&quot;</span>));</span><br><span class="line">    str-&gt;<span class="built_in">append</span>(<span class="string">&quot; i am from heap and used unique_ptr.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 这里返回的str实际上进行了一次拷贝，实现在std::string的拷贝构造函数上!</span></span><br><span class="line"><span class="function">std::string <span class="title">getStdStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello world.&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot; i am from stack and used copy constructor.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a是一个指针，指向常量区， &quot;hello world&quot; 分配在常量区，对于这种申明C++11推荐用 const 标记出来，因为常量区我们程序运行时是无法修改的</span></span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b是一个指针，指向常量区，&quot;c++&quot; 分配在常量区</span></span><br><span class="line">    <span class="comment">// 常量区编译器会优化，也就是说 a 和 b 俩人吧他们的内容都一模一样，那么所以常量只有一份</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* b = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c = <span class="string">&quot;hello world c&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 分配在栈上，当函数调用结束就销毁了！</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱码!!!</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getStackStr</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getConstStr</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量是不会重复分配内存的，所以下面3个输出结果是一样的!</span></span><br><span class="line">    <span class="keyword">auto</span> arr1 = <span class="built_in">getConstStr</span>();</span><br><span class="line">    <span class="keyword">auto</span> arr2 = <span class="built_in">getConstStr</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> arr3 = <span class="built_in">getHeapStr</span>();</span><br><span class="line">    <span class="comment">// 正常打印</span></span><br><span class="line">    cout &lt;&lt; arr3 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 需要手动释放</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string 是一个类，也就是说它内存开销非常的高，而且对于大的数据会分配在堆上性能以及效率会差一些!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里本质上调用的是 str的copy constructor函数，属于隐式类型转换!</span></span><br><span class="line">    std::string str = arr1;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, str.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务中如何使用 std::string了，最好使用std:unique_ptr，可以减少内存的拷贝!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++ 中一般不推荐return一个复杂的数据结构(因为涉及到拷贝,</span></span><br><span class="line">    <span class="comment">// 或者你就用指针，或者C++11引入了移动语意，降低拷贝)，而是推荐通过参数把返回变量传递过去，进而减少拷贝!</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">getUniquePtrStr</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getStdStr</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="关于-x-和-x"><a href="#关于-x-和-x" class="headerlink" title="关于 x++ 和 ++x"></a>关于 x++ 和 ++x</h3><p>首先学过Java/C的同学都知道，x++ 返回的是x+1之前的值， ++x返回的是x+1后的值！ 他俩都可以使x加1，但是他俩的返回值不同罢了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 x++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xadd</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ++x</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">addx</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//    int tmp = x++;</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">xadd</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//    tmp = ++x;</span></span><br><span class="line">    tmp = <span class="built_in">addx</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 10</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 11</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用-左值-右值-万能引用"><a href="#引用-左值-右值-万能引用" class="headerlink" title="引用 (左值/右值/万能引用)"></a>引用 (左值/右值/万能引用)</h3><p>引用本质上就是指针，但是它解决了空指针的问题，我个人觉得他是一个比较完美的解决方案！</p><ol><li>下面是一个简单的例子，可以看到引用的效果 （单说引用一般是指的左值引用）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> inc)</span> </span>&#123;</span><br><span class="line">    a = a + inc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">inc</span>(a, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><ol start="2"><li>其实上面这个例子（inc函数）属于左值引用，为什么叫左值引用，是因为它只能引用 <strong>左值（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#lvalue">lvalue</a>）</strong> ， 你可以理解为左值 <strong>是一个被定义类型的变量</strong>，那么它一定可以被取址（因为左引用很多编译器就是用的指针去实现的）， <strong>右值则相反，例如字面量</strong>； 右值包含<strong>纯右值（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#prvalue">prvalue</a>）</strong>和<strong>将亡值（<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_category#xvalue">xvalue</a>）</strong>(将亡值我个人理解是如果没有使用那么下一步就被回收了，生命到达终点的那种！)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// x: 是一个变量，其内存分配在栈空间上，为左值，我可以取x的指针，那么x指针指向的就是栈上的某个空间</span></span><br><span class="line"><span class="comment">// 10: 是一个字面量，为右值，如果没有x那么它就和谁也没关系，认为是垃圾(注意右值引用就是要用垃圾，让垃圾生命延续)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>下面是一个左值(lvalue)/右值(rvalue)/万能引用(Universal Reference)在实际开发中的例子</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: -std=c++17</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SafeMap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// T 为万能引用(注意: 万能引用会涉及到类型推断, 区别于右值引用)</span></span><br><span class="line">    <span class="comment">// 万能引用一定要和std::forward(万能转发)结合使用, 不然没啥意义</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">Get</span><span class="params">(T &amp;&amp;key)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> map[std::forward&lt;T&gt;(key)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// K 为右值引用</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Exist</span><span class="params">(K &amp;&amp;key)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;kv = map.<span class="built_in">find</span>(key); kv == map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Put</span><span class="params">(K key, <span class="keyword">const</span> V &amp;value)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        map[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">Size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> map.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unordered_map&lt;K, V&gt; map;</span><br><span class="line">    std::shared_mutex mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> StringSafeMap = SafeMap&lt;std::string, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string key = <span class="string">&quot;1&quot;</span>;</span><br><span class="line">    StringSafeMap&lt;<span class="keyword">int</span>&gt; map;</span><br><span class="line">    map.<span class="built_in">Put</span>(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; map.<span class="built_in">Get</span>(<span class="string">&quot;1&quot;</span>) &lt;&lt; std::endl; <span class="comment">// 右值引用</span></span><br><span class="line">    std::cout &lt;&lt; map.<span class="built_in">Get</span>(key) &lt;&lt; std::endl; <span class="comment">// 左值引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// map.Exist(key); // 编译不过去，因为没有定义左值引用函数</span></span><br><span class="line">    <span class="keyword">if</span> (map.<span class="built_in">Exist</span>(<span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;exist&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;not exist&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的可以看文章:</p><ul><li><a target="_blank" rel="noopener" href="https://paul.pub/cpp-value-category/">https://paul.pub/cpp-value-category/</a></li><li><a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/reference/">https://oi-wiki.org/lang/reference/</a></li><li><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_6343747/5464960">https://blog.51cto.com/u_6343747/5464960</a></li></ul><p>总结:</p><ul><li>右值引用可以降低内存拷贝，但是需要实现移动语义！</li><li>引用本质上就是指针，所以使用引用一定要注意对象的生命周期，推荐生命周期明确引用传递，不明确值传递(值传递可以通过移动进行优化本质上开销并不大)！</li><li>常量左值引用，可传递右值！</li><li>万能引用可以减少代码量，尤其是参数多的情况下，万能引用需要配合 <code>std::forword</code> 万能转发使用！</li></ul><h2 id="类的初始化函数"><a href="#类的初始化函数" class="headerlink" title="类的初始化函数"></a>类的初始化函数</h2><h3 id="类的基本的成员函数"><a href="#类的基本的成员函数" class="headerlink" title="类的基本的成员函数"></a>类的基本的成员函数</h3><blockquote><p><strong>这个是C++ 最难的地方，新手做到知道即可，不建议深挖，无底洞一个，显然禁止拷贝和移动才是最佳选择！</strong></p></blockquote><p>C++ 的类，最基本也会有几个部分组成，就算你定义了一个空的类，那么<strong>它也会有（前提你使用了这些操作）</strong>，和Java的有点像！</p><ul><li>default constructor: <strong>默认构造函数</strong></li><li>copy constructor: <strong>拷贝构造函数</strong> （注意: 编译器默认生成的拷贝构造函数是浅拷贝！）</li><li>copy assignment constructor: <strong>拷贝赋值构造函数</strong></li><li>deconstructor: <strong>析构函数</strong> ！</li><li>C++11引入了 move constructor （<strong>移动构造函数 <strong>） 、 move assigment constructor（</strong>移动赋值构造函数</strong>），你不定义是不会生成的。</li></ul><p>下面例子我是根据<a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/move-constructors-and-move-assignment-operators-cpp?view=msvc-170">此教程</a>写的，大概可以解释6个函数 <a target="_blank" rel="noopener" href="https://coliru.stacked-crooked.com/a/ae31c28f852e3220">https://coliru.stacked-crooked.com/a/ae31c28f852e3220</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// g++ -std=c++17 -O0 -Wall main.cpp -o main &amp;&amp; ./main</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Memory</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Memory</span><span class="params">(<span class="keyword">size_t</span> size)</span> : size_(size), data_(new char[size]) &#123;</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory constructors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">Memory</span>() &#123;</span><br><span class="line">        <span class="built_in">clearMemory</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory deconstructors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数(就是创建一个b，把a拷贝到b)</span></span><br><span class="line">    <span class="built_in">Memory</span>(Memory &amp;from) : <span class="built_in">size_</span>(from.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="keyword">char</span>[from.size_]) &#123;</span><br><span class="line">        <span class="comment">// 参数: start,end,dst</span></span><br><span class="line">        std::<span class="built_in">copy</span>(from.data_, from.data_ + from.size_, data_);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory Copy constructors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 拷贝赋值函数(就是做拷贝，把a拷贝到b)</span></span><br><span class="line">    Memory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Memory &amp;from) &#123;</span><br><span class="line">        <span class="comment">// 很可能自身移动, 这里一般都需要这么处理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;from) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Memory Copy assignment constructors (=)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory Copy assignment constructors (!=)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 1. 清理自己</span></span><br><span class="line">        <span class="built_in">clearMemory</span>();</span><br><span class="line">        <span class="comment">// 2. 拷贝</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;size_ = from.size_;</span><br><span class="line">        <span class="keyword">this</span>-&gt;data_ = <span class="keyword">new</span> <span class="keyword">char</span>[from.size_];</span><br><span class="line">        std::<span class="built_in">copy</span>(from.data_, from.data_ + from.size_, data_);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">Memory</span>(Memory &amp;&amp;from) <span class="keyword">noexcept</span> : <span class="built_in">size_</span>(<span class="number">0</span>), <span class="built_in">data_</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory Move constructors&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// https://blog.csdn.net/p942005405/article/details/84644069</span></span><br><span class="line">        <span class="comment">// 1. std::move 强制变成了右值</span></span><br><span class="line">        <span class="comment">// 2. 调用移动赋值构造函数</span></span><br><span class="line">        *<span class="keyword">this</span> = std::<span class="built_in">move</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值构造函数, 这些函数需要 noexcept</span></span><br><span class="line">    Memory &amp;<span class="keyword">operator</span>=(Memory &amp;&amp;from) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;from) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Memory Move Assignment constructors(=)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory Move Assignment constructors(!=)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 先清理自己的内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] data_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        data_ = from.data_;</span><br><span class="line">        size_ = from.size_;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记空，防止析构函数失败</span></span><br><span class="line">        from.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        from.size_ = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里没记录写偏移量，所以这里就只支持set函数了.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *data, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size &gt; size_) &#123;</span><br><span class="line">            size = size_;</span><br><span class="line">        &#125;</span><br><span class="line">        std::<span class="built_in">copy</span>(data, data + size, data_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;out, Memory &amp;from) &#123;</span><br><span class="line">        <span class="keyword">if</span> (from.data_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> out &lt;&lt; <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out &lt;&lt; from.data_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;data_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;data_; <span class="comment">// 正常来说如果不存在移动可以这么写</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> size_&#123;&#125;;</span><br><span class="line">    <span class="keyword">char</span> *data_&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Memory <span class="title">getMemory</span><span class="params">(<span class="keyword">bool</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x) &#123;</span><br><span class="line">        <span class="function">Memory <span class="title">mm</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">        mm.<span class="built_in">Set</span>(<span class="string">&quot;true&quot;</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="keyword">return</span> mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Memory <span class="title">mm</span><span class="params">(<span class="number">16</span>)</span></span>;</span><br><span class="line">    mm.<span class="built_in">Set</span>(<span class="string">&quot;false&quot;</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> mm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Memory <span class="title">memory1</span><span class="params">(<span class="number">20</span>)</span></span>; <span class="comment">// constructor</span></span><br><span class="line">    memory1.<span class="built_in">Set</span>(<span class="string">&quot;hello world&quot;</span>, <span class="number">11</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory1: &quot;</span> &lt;&lt; memory1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Memory memory2 = memory1; <span class="comment">// copy constructor (这个属于编译器优化了, 不然你这个代码也执行不通哇，因为我们没有默认构造函数, 所以左值是无法初始化的)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory2: &quot;</span> &lt;&lt; memory2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Memory <span class="title">memory3</span><span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// constructor</span></span><br><span class="line">    memory3 = memory2; <span class="comment">// copy assignment constructor</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory3: &quot;</span> &lt;&lt; memory3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Memory memory4 = <span class="built_in">getMemory</span>(<span class="literal">true</span>); <span class="comment">// move constructor(如果未定义移动构造函数，则会调用拷贝构造函数，所以移动构造函数是不会默认生成的)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory4: &quot;</span> &lt;&lt; memory4 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    memory3 = <span class="built_in">getMemory</span>(<span class="literal">false</span>); <span class="comment">// move constructor + move assignment constructor</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory3: &quot;</span> &lt;&lt; memory3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Memory memory5 = std::<span class="built_in">move</span>(memory3);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory3: &quot;</span> &lt;&lt; memory3 &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;memory5: &quot;</span> &lt;&lt; memory5 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：拷贝可以避免堆内存随意引用问题，比如我定义了A对象，此时我在A对象上分配了10M空间，此时B对象拷贝自我，那么此时B引用了A的10M内存，此时A/B回收的时候到底要清理A还是B的10M内存了？ 第二个就是移动解决的问题，对于一些右值可能会存在冗余拷贝的问题，此时就可以使用移动优化内存拷贝。 本质上这些构造函数都是为了解决一个问题内存分配！！</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>这里我们要知道一点就是 C++ 类的初始化内置类型(builtin type)是不会自动初始化为0的，但是类类型(非指针类型)的话却会自动调用默认构造函数，具体为啥了，兼容C，不然会很慢，因为假如你要初始化一个类，例如定义了10个内置类型的字段，我需要10次赋值调用才能把10个字段初始化成0，而不初始化只需要开辟固定的内存空间即可，可以大大提高代码运行效率！</p><blockquote><p>大部分情况下都是推荐使用初始化列表的！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct Info&#123;</span></span><br><span class="line"><span class="comment">//     int id;</span></span><br><span class="line"><span class="comment">//     long salary;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">Demo</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;init demo&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> salary;</span><br><span class="line">    Demo wrapper;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 未使用初始化列表</span></span><br><span class="line">    Info info;</span><br><span class="line">    cout &lt;&lt; info.id &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; info.wrapper.id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    Info* infop;</span><br><span class="line">    cout &lt;&lt; infop &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用初始化列表</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======= C++11 初始化列表 &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Info info1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; info1.id &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; info1.wrapper.id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> x1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; x1 &lt;&lt; endl;</span><br><span class="line">    Info* infop1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; infop1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// init demo</span></span><br><span class="line"><span class="comment">// 185313075</span></span><br><span class="line"><span class="comment">// 88051808</span></span><br><span class="line"><span class="comment">// 32759</span></span><br><span class="line"><span class="comment">// 0x10b11c010</span></span><br><span class="line"><span class="comment">// ======= C++11 初始化列表</span></span><br><span class="line"><span class="comment">// init demo</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0x0</span></span><br></pre></td></tr></table></figure><p>类的初始化列表：</p><ul><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html</a></li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_initialization">https://en.cppreference.com/w/cpp/language/value_initialization</a></li></ul><h3 id="类的初始化写法"><a href="#类的初始化写法" class="headerlink" title="类的初始化写法"></a>类的初始化写法</h3><p>C++11 就下面这三种写法</p><ul><li><code>( expression-list )</code>小括号括起来的表达式列表</li><li><code>= expression</code> 表达式</li><li><code>&#123; initializer-list &#125;</code> 大括号括起来的表达式列表，C++11比较推荐这种写法</li></ul><p>然后这三种写法大题分为了几大类，这几大类主要是为了区分吧，我个人觉得就是语法上的归类，主要是cpp历史包袱太重了，其次追求高性能，进而分类了很多初始化写法，具体可以看官方文档： <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/initialization">https://en.cppreference.com/w/cpp/language/initialization</a> ！</p><h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><blockquote><p>前期先掌握基本语法吧，实际用到的时候再深入学习，类的继承在C++中特别复杂，因为会涉及到模版、类型转换、虚函数、析构函数，注意事项非常多！</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>c++的继承非常复杂，底层设计以及各种细节，所以我单独写了一篇文章： <a href="https://anthony-dong.github.io/2023/09/16/91c61c1043b15978e6cca833236c4694/">C++继承的底层设计</a></p><ol><li>基类 base class ，基类需要把析构函数设置为虚函数，派生类 derived class，基类 和 派生类是相对关系</li><li>三种继承方式:</li></ol><ul><li>public: 基类的 public 和 protected 成员的访问属性在派生类中保持不变(传递性)，但基类的 private 成员不可直接访问</li><li>protect: 基类的 public 和 protected 成员都以 protected 身份出现在派生类中(传递性)，但基类的 private 成员不可直接访问</li><li>private: 基类的 public 和 protected 成员都以 private 身份出现在派生类中(传递性)，但基类的 private 成员不可直接访问</li><li>总结:<ul><li>public 一劳永逸，protect、private 的话会修改基类的访问属性。业务中一般用public，不想对外暴露基类除外</li><li>struct 默认继承是public , class 默认继承是private</li><li>多写写代码尝试下，就行了</li></ul></li></ul><ol start="7"><li>使用虚继承可以降低内存开销，解决多继承的二义性问题</li><li>具体例子可以看：</li></ol><ul><li><a target="_blank" rel="noopener" href="https://godbolt.org/z/TEEsYra7f">https://godbolt.org/z/TEEsYra7f</a></li><li><a target="_blank" rel="noopener" href="https://godbolt.org/z/rxeza5EEa">https://godbolt.org/z/rxeza5EEa</a></li></ul><h3 id="override-、final"><a href="#override-、final" class="headerlink" title="override 、final"></a>override 、final</h3><blockquote><p>override（重写） 和 overload（重载） 区别在于 override 是继承引入的概念！</p></blockquote><p>这俩修饰词主要是解决继承中重写的问题！</p><ol><li>类被修饰为 final</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">final</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我不想被继承&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123; <span class="comment">// 这里会被编译报错，说A无法被继承！</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法被修饰为 final</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我不想被继承&quot;</span> &lt;&lt; endl; &#125;; <span class="comment">// 申明我这个函数无法被继承，注意: final只能修饰virtual函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 这里编译报错，无法重写父类方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>方法修饰为 override</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 这里编译报错，重写需要父类有定义！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>public 和 private其实没多必要介绍， 但是涉及到继承，<strong>仅允许我的子类访问那么就需要protected关键词了</strong>，区别于Java的protected.</p><h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h3><p>friend （友元）表示外部方法可以访问我的private/protected变量， 正常来说我定义一个一些私有的成员变量，外部函数调用的话，是访问不了的，但是友元函数可以，例如下面这个case：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Data&amp; c);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id&#123;&#125;;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Data&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(Id=&quot;</span> &lt;&lt; c.id &lt;&lt; <span class="string">&quot;,Name=&quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Data&#123;&#125; &lt;&lt; std::endl;  <span class="comment">// 这里会涉及到运算符重载的一些细节，具体可以看本篇文章!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针的一些细节"><a href="#指针的一些细节" class="headerlink" title="指针的一些细节"></a>指针的一些细节</h2><p>注意：<strong>别瞎new指针, new了地方要么用智能指针自动回收，要么用delete手动回收！</strong> 手动new的一定会分配在堆上，所以性能本身就不高，推荐用<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/memory">智能指针</a> + <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/raii">raii</a>！</p><p>什么叫指针，你可以理解为就是一个long类型的值，但是呢这个long类型的值是一个内存地址，你可以通过操作这个内存地址进行 获取值（因为指针是有类型的），修改内存等操作！</p><p>在C/C++ 语言中，表示指针很简单，例如 <code>int* ptr</code> 表示ptr是一个int类型的指针 或者 一个int类型的数组！c++ 判断指针为空用 <code>nullptr</code> !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈是 高地址-&gt;低地址 走了</span></span><br><span class="line">    <span class="comment">// x,y都是分配在栈上</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针就是一个long类型的值</span></span><br><span class="line">    <span class="keyword">long</span> yp = (<span class="keyword">long</span>)(&amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于他在栈上分配，所以不需要转换一次了，直接+-就可以挪动内存了，最后在给他转换成真是的指针类型</span></span><br><span class="line">    <span class="keyword">int</span> *xp = (<span class="keyword">int</span> *)((yp) + <span class="number">4</span>);</span><br><span class="line">    *xp = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure><h3 id="例子1-数组与指针"><a href="#例子1-数组与指针" class="headerlink" title="例子1: 数组与指针"></a>例子1: 数组与指针</h3><p>C++/C 中数组和指针最奇妙，原因是 <strong>数组</strong> 和 <strong>指针</strong> 基本概念等价，因为两者都是指向内存的首地址，区别在于数组名定义了数组的长度，但是指针没有数组长度的概念，因此我们无法通过一个指针获取数组长度！</p><p>类似于下面这个例子， arr 是一个数组，p1、p2是一个数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p1 = arr;</span><br><span class="line">    <span class="keyword">int</span>* p2 = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(arr)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; <span class="string">&quot;, sizeof(arr[1])=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">1</span>]) &lt;&lt; <span class="string">&quot;, sizeof(p1)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p1) &lt;&lt; <span class="string">&quot;, sizeof(p2)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr len=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr=&quot;</span> &lt;&lt; arr &lt;&lt; <span class="string">&quot;, p1=&quot;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;, p2=&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, (arr+i)=&quot;</span> &lt;&lt; arr + i &lt;&lt; <span class="string">&quot;, (p1+i)=&quot;</span> &lt;&lt; p1 + i &lt;&lt; <span class="string">&quot;, arr[i]=&quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, *(p1+i)=&quot;</span> &lt;&lt; *(p1 + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sizeof(arr)=20, sizeof(arr[1])=4, sizeof(p1)=8, sizeof(p2)=8</span><br><span class="line">arr len=5</span><br><span class="line">arr=0x7ff7bd9999f0, p1=0x7ff7bd9999f0, p2=0x7ff7bd9999f0</span><br><span class="line">i=0, (arr+i)=0x7ff7bd9999f0, (p1+i)=0x7ff7bd9999f0, arr[i]=1, *(p1+i)=1</span><br><span class="line">i=1, (arr+i)=0x7ff7bd9999f4, (p1+i)=0x7ff7bd9999f4, arr[i]=2, *(p1+i)=2</span><br><span class="line">i=2, (arr+i)=0x7ff7bd9999f8, (p1+i)=0x7ff7bd9999f8, arr[i]=3, *(p1+i)=3</span><br><span class="line">i=3, (arr+i)=0x7ff7bd9999fc, (p1+i)=0x7ff7bd9999fc, arr[i]=4, *(p1+i)=4</span><br><span class="line">i=4, (arr+i)=0x7ff7bd999a00, (p1+i)=0x7ff7bd999a00, arr[i]=5, *(p1+i)=5</span><br></pre></td></tr></table></figure><p>结论:</p><ol><li>数组、数组指针其实都是 数组的第一个元素对应的内存地址（指针）</li><li>数组+1 和 指针+1 ，其实不是简单的int+1的操作，而是偏移了类型的长度，原因是 <strong>指针是有类型的，且指针默认重载了 + 运算符</strong>！</li><li>数组是可以获取数组的长度的，但是数组指针不可以！</li></ol><p>注意：</p><ul><li>数组delete 和 delete[] 需要特别注意，因为 delete[]与new[] 成对出现，以及 delete和new成对出现</li></ul><h3 id="例子2-数组长度"><a href="#例子2-数组长度" class="headerlink" title="例子2: 数组长度"></a>例子2: 数组长度</h3><p>通常，我们不可能在main函数里写代码，是不是，我们更多都是函数调用，那么问题来了？ 函数调用如何安全的操作呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">get_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        *(arr + i) = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = <span class="built_in">get_array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123; <span class="comment">// 这里无法获取数组指针 arr 的长度</span></span><br><span class="line">        cout &lt;&lt; *(arr + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题： 如何获取arr的长度的呢？ 显然是不可以获取的！</p><h3 id="例子3-常量指针"><a href="#例子3-常量指针" class="headerlink" title="例子3: 常量指针"></a>例子3: 常量指针</h3><ol><li>常量指针(<strong>Constant Pointer</strong>)，表示的是指针指向的内存（内容）不可以修改，也就是说 <code>*p</code> 不可以修改，但是 <code>p</code>可以修改</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p; <span class="comment">// const 修饰的是 *p， *p不可以变（指向的内容），但是p可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p; <span class="comment">// 写法上没啥区别, 都修饰的是 *p, 我比较推荐这种写法</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;x;</span><br><span class="line">    <span class="comment">// *p = 10; // 不允许改变 指针指向的值</span></span><br><span class="line">    p = p2; <span class="comment">// 允许</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// p: 0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指针常量(<strong>pointer to a constant</strong>：指向常量的指针)，表示 p 不可以修改，但是 <code>*p</code> 可以修改</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;x;</span><br><span class="line">    *p = <span class="number">20</span>; <span class="comment">// 允许改变 指针指向的值</span></span><br><span class="line">    <span class="comment">// p = p2; // 不允许</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// p: 20</span></span><br></pre></td></tr></table></figure><ol start="3"><li>指向常量的常量指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p; <span class="comment">// 它兼容了两者的全部优点！</span></span><br></pre></td></tr></table></figure><ol start="4"><li>总结</li></ol><p>大部分case都是使用常量指针，因为指针传递是不安全的，<strong>如果我们的目的是不让指针去操作内存</strong>，那么我们就用 <strong>常量指针</strong>，对与指针本身来说就是一个64位的int它变与不变你不用管！</p><h3 id="补充一些小点"><a href="#补充一些小点" class="headerlink" title="补充一些小点"></a>补充一些小点</h3><ol><li>指针到底写在 类型上好 <code>int* p</code>，还是变量上好 <code>int *p</code>, 没有正确答案，我是写Go的所以习惯写到类型上！具体可以看 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52305847?rf=21136956">https://www.zhihu.com/question/52305847?rf=21136956</a></li><li>指向成员的指针运算符: (比较难理解，个人感觉实际上就是定义了一个指针 alies )<ol><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">.* 和 -&gt;*</a></li><li><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2019/03/quick-q-pointer-to-class-data-member">::*</a></li></ol></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在C++11中存在四种智能指针：<code>std::auto_ptr</code>，<code>std::unique_ptr</code>，<code>std::shared_ptr</code>，<code>std::weak_ptr</code>，</p><p>auto_ptr : c++98 中提供了，目前已经不推荐使用了</p><p>unique_ptr: 这个对象没有实现拷贝构造函数，所以我们用的时候只能用 <code>std::move</code> 进行移动赋值 ，<strong>经常使用</strong>！</p><p>shared_ptr: 其实类似于GC语言的对象，他通过引用计数【循环引用会导致内存泄露】，实现自动回收，<strong>经常使用</strong>吧！</p><p>weak_ptr: 本质上就是解决 shared_ptr 循环引用的问题，它持有 shared_ptr，但是不会使得shared_ptr引用计数增加，<strong>很少使用</strong>吧！</p><p>c++14新增了<code>make_unique</code> 的api，这里的原理会涉及到 <code>std::move</code> 和 <code>std::forward</code> 函数相关知识， 有兴趣可以了解下 完美转发和万能引用，以及移动语意！</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x_)</span> : x(x_) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;release: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test* <span class="title">newTestFunc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Test</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Test&gt; test1 = std::unique_ptr&lt;Test&gt;(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// unique_ptr只有移动语意，没有拷贝语义</span></span><br><span class="line">    <span class="keyword">auto</span> test2 = std::<span class="built_in">move</span>(test1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test1 is null ptr: &quot;</span> &lt;&lt; (test1 == <span class="literal">nullptr</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test2.x: &quot;</span> &lt;&lt; test2-&gt;x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset 会先释放原来指针，然后再赋值</span></span><br><span class="line">    test2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放引用, 例如理论上 test2 会在main函数结束后会释放，但是我其实想要这个内容，我自己管理，就可以用 release 函数释放指针</span></span><br><span class="line">    Test* test2_ = test2.<span class="built_in">release</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test2_-&gt;x: &quot;</span> &lt;&lt; test2_-&gt;x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> test2_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不推荐这么写，这样裸指针很危险，也容易忘记释放.</span></span><br><span class="line"><span class="comment">//    Test* test3 = newTestFunc(3);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 推荐使用智能包装一层</span></span><br><span class="line">    <span class="keyword">auto</span> test = std::unique_ptr&lt;Test&gt;(<span class="built_in">newTestFunc</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>shared_ptr 实际上基本已经对标主流的垃圾回收语言了，它使用引用计数的方式实现了垃圾回收！</p><p>shared_ptr 会存储一个引用计数器+指针，每次拷贝都会使得计数器+1然后再拷贝数据，当调用析构函数(或者 reset函数)的时候会使得计数器-1；当为0的时候会直接会去释放指针！所以原理并不复杂吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAB</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;AStruct&gt; &amp;ap)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[0]: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    bp-&gt;Num = <span class="number">111</span>;</span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[1]: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;         <span class="comment">// 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[1.1]: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer: bp释放 count=1, 未触发回收;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">setAB</span>(ap);</span><br><span class="line">    std::cout &lt;&lt; ap-&gt;bPtr-&gt;Num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[2]: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer ap 释放 -&gt; bp释放后 bp.count=0 释放bp!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个也注定有一个陷阱，就是循环引用无法解决！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;AStruct&gt; aPtr;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLoopReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    bp-&gt;aPtr = ap;</span><br><span class="line">  <span class="comment">// 无法释放 ap 和 bp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestLoopReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><p>weak_ptr 本质上并不能算的上是一个智能指针，只能说是为了解决 shared_ptr 循环引用的问题 [不能根本解决]，weak_ptr相当于拷贝了一份 shared_ptr， 但是引用次数并不会增加，为此假如 shared_ptr 已经被释放了，那么weak_ptr也会指向空指针！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::weak_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    std::weak_ptr&lt;AStruct&gt; aPtr;</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLoopReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    bp-&gt;Num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak ptr 本身就是弱引用，此时只是只要ap/bp生命周期(也就是这个函数没执行结束)没结束就一直可以使用!</span></span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    bp-&gt;aPtr = ap;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BStruct.Num: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">lock</span>()-&gt;Num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestLoopReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="智能指针和数组"><a href="#智能指针和数组" class="headerlink" title="智能指针和数组"></a>智能指针和数组</h3><ol><li>针对于数组指针, 需要自己定义delete函数 <a target="_blank" rel="noopener" href="https://coliru.stacked-crooked.com/a/83d4d163afb6cdd8">https://coliru.stacked-crooked.com/a/83d4d163afb6cdd8</a></li><li>针对于数组，无需特殊处理 <a target="_blank" rel="noopener" href="https://coliru.stacked-crooked.com/a/b3e9c0103382fe3b">https://coliru.stacked-crooked.com/a/b3e9c0103382fe3b</a></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组</span></span><br><span class="line">    std::shared_ptr&lt;Int[]&gt; data&#123;&#125;;</span><br><span class="line">    data.<span class="built_in">reset</span>(<span class="keyword">new</span> Int[<span class="number">10</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组指针</span></span><br><span class="line">    std::shared_ptr&lt;Int&gt; data2&#123;&#125;;</span><br><span class="line">    data.<span class="built_in">reset</span>(<span class="keyword">new</span> Int[<span class="number">10</span>], [](<span class="keyword">auto</span> p) &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] p; <span class="comment">// 首地址的前8字节(64位)地址就是数组长度，所以可以删除成功</span></span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 发现个很神奇的地方，删除数组是从尾到首部删除...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内存回收的一些思考"><a href="#内存回收的一些思考" class="headerlink" title="内存回收的一些思考"></a>内存回收的一些思考</h3><ol><li>虽然C++中提供了 raii 和 智能指针，但是内存的频繁分配和频繁销毁，会给cpu造成一些开销(性能慢、延时高等)，那么业务中经常遇到那种巨型结构进行序列化反序列化，那么业内也有一些解决方案，就是使用 arena ，具体可以参考</li></ol><ul><li><a target="_blank" rel="noopener" href="https://protobuf.dev/reference/cpp/arenas/">https://protobuf.dev/reference/cpp/arenas/</a></li><li><a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf/issues/4327">https://github.com/protocolbuffers/protobuf/issues/4327</a></li></ul><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>C++的 const 表达的意思是只读的意思，就是不可变的意思！</p><ol><li>这里主要是介绍一个双重指针，其他疑问可以看这个链接: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/433076446">https://www.zhihu.com/question/433076446</a>！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span>* x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span>* p = &amp;x; <span class="comment">// 表示*p是常量</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    **p = <span class="number">100</span>; <span class="comment">// **p允许修改</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// *p = x2; // *p不允许修改!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>** p = &amp;x; <span class="comment">// 表示**p是常量, 因为它也不需要要用常量*x初始化, 不然编译报错!</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>); <span class="comment">// *p可以修改</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// **p = 10; // **p不可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo1</span>();</span><br><span class="line">    <span class="built_in">foo2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>const 可以修饰方法的返回值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> str = <span class="built_in">getString</span>();</span><br><span class="line">    *(str + <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 这里编译报错，只读 str</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>const 修饰方法的参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125; <span class="comment">// 这里无法修改str</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printStr</span>(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>const 修饰方法， 表示此方法是一个只读的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">this</span>-&gt;a = <span class="number">1</span>; &#125; <span class="comment">// 编译报错，无法修改 this-&gt;a !</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><p>constexpr 常量表达式，就是它可以在编译后直接替换为计算所得的值！可以看下面这个例子，直接计算出 <code>fib(6)</code> 的值直接赋值给了<code>esi</code> (参数一) ！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/10-6/7bd539e74f1c4a51b278966952888c7c.png" alt="image-20231006164550798"></p><p>constexpr 目前已经是非常成熟的能力了，但是它会给编译器带来比较大的压力！</p><p>C++11：仅支持简单的常量表达式</p><p>C++14：支持逻辑语句</p><p>C++17：支持Lambda</p><p>参考文章</p><ul><li><a target="_blank" rel="noopener" href="https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr/">https://zhxilin.github.io/post/tech_stack/1_programming_language/modern_cpp/cpp17/constexpr/</a></li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/constexpr">https://en.cppreference.com/w/cpp/language/constexpr</a></li></ul><p>说实话，一堆花里胡哨的东西你很难理解它的实际用途，像上面这种常量表达式计算，人家编译器可能直接给你优化了，完全不需要你申明 consteptr</p><p>主要实用的用途就是：</p><ul><li><p>让编译器提前优化代码（提前的意思表示可能未来编译器就优化了），类似于上面那个纯粹的计算函数</p></li><li><p>编译时期进行 static_assert，进行一些类型、常量检测</p></li><li><p>编译器进行条件判断，减少代码量，但是实际上这个例子可以用 cpp17的 fold expression</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(T t, Args ... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; t &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) &gt; <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(args ...);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(args) == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模版元编程: 太过于强大，此处不建议学习</li></ul><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>static 主要是内存分配的问题，在程序初始化阶段会有一个静态内存区域专门存储静态变量的，其次静态局部变量可以保证多线程安全（c++11后）！</p><blockquote><p>注意: <strong>c++中static定义在头文件中会被初始化多次，不要在头文件中定义全局static变量</strong>，别误以为是static作用域失效了！</p></blockquote><ol><li>全局 静态变量、静态方法</li></ol><ul><li>静态成员变量可以初始化，但只能在类体外进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> example &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberY = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberZ = NumberY + <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;, z: &#123;&#125;\n&quot;</span>, NumberX, NumberY, NumberZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace example</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> example::Class::x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> example::Class::y = z + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> example::Class::z = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">void</span> example::Class::<span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;, z: &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    example::<span class="built_in">print</span>();</span><br><span class="line">    example::Class::<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// x: 100, y: 200, z: 500</span></span><br><span class="line"><span class="comment">// x: 1, y: 4, z: 2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>全局静态方法和静态变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">inc</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">inc</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>模版的静态变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AA&lt;T&gt;::num = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> :</span> <span class="keyword">public</span> AA&lt;BB&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> :</span> <span class="keyword">public</span> AA&lt;CC&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;B::num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;C::num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;BB::num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;CC::num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 0x10f2c5030</span></span><br><span class="line"><span class="comment">// 0x10f2c5030</span></span><br><span class="line"><span class="comment">// 0x10f2c5034</span></span><br><span class="line"><span class="comment">// 0x10f2c5038</span></span><br></pre></td></tr></table></figure><ol start="4"><li>写一个单例对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;absl/base/call_once.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        absl::<span class="built_in">call_once</span>(ThreadSafeSingleton&lt;T&gt;::create_once_, &amp;ThreadSafeSingleton&lt;T&gt;::Create);</span><br><span class="line">        <span class="keyword">return</span> *ThreadSafeSingleton&lt;T&gt;::instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span> </span>&#123; instance_ = <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;</span><br><span class="line">    <span class="keyword">static</span> absl::once_flag create_once_;</span><br><span class="line">    <span class="keyword">static</span> T *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">absl::once_flag ThreadSafeSingleton&lt;T&gt;::create_once_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T *ThreadSafeSingleton&lt;T&gt;::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 11 可以这么写，因为static线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstSingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T *t = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">return</span> *t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> &#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ExampleStructSingleton = ThreadSafeSingleton&lt;ExampleStruct&gt;;</span><br><span class="line"><span class="keyword">using</span> ExampleStructConstSingleton = ConstSingleton&lt;ExampleStruct&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExampleStructSingleton::<span class="built_in">get</span>().name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;name = &#123;&#125;\n&quot;</span>, ExampleStructSingleton::<span class="built_in">get</span>().name);</span><br><span class="line"></span><br><span class="line">    ExampleStructConstSingleton::<span class="built_in">get</span>().name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;name = &#123;&#125;\n&quot;</span>, ExampleStructConstSingleton::<span class="built_in">get</span>().name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ol><li><code>extern C</code> 主要是解决C++ -&gt; C 链接方式不得同，以及C与C++函数互相调用的问题</li><li>其他待补充！</li></ol><h3 id="auto-和-decltype"><a href="#auto-和-decltype" class="headerlink" title="auto 和 decltype"></a>auto 和 decltype</h3><blockquote><p>看这里之前建议先学习模版</p></blockquote><p><code>auto</code> 实际上是大部分高级语言现在都有的一个功能，就是类型推断，c++11引入<code>auto</code> 原因也是因为<code>模版</code>, 其次更加方便！</p><p><code>decltype</code> 本质上也是类型推断，但是它与 auto 是俩场景，解决不同的场景的问题，非常好用，decltype并不会真正的调用函数，只是获取函数的类型，非常好用，尤其是面对复杂模版的时候！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123; <span class="comment">// 返回类型的后置写法!</span></span><br><span class="line">    <span class="keyword">using</span> Sum = <span class="keyword">decltype</span>(t + u);</span><br><span class="line">    Sum s = t + u;</span><br><span class="line">    s = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> num = <span class="built_in">add</span>(<span class="built_in"><span class="keyword">float</span></span>(<span class="number">1.1</span>), <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码，如果没有 <code>decltype</code> 很难去实现，如果仅用模版根本无法推断出到底返回类型是啥，可能是int 也可能是 float ！</p><p>注意:</p><ol><li>decltype 最难的地方还是在于它保留了 左值/右值信息，这个就给编程带来了一定的难度！</li><li>c++14 有更精简的语法，具体可以看c++14语法</li></ol><h3 id="using-和-typedef"><a href="#using-和-typedef" class="headerlink" title="using 和 typedef"></a>using 和 typedef</h3><blockquote><p>看这里之前先学习模版</p></blockquote><p>虽然大部分case两者差距不大，using 这里主要解决了一些case 语法过于复杂的问题！</p><p>例如 typedef 无法解决模版的问题，只能依赖于类模版去实现！</p><p>using 更加方便！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span> =</span> std::allocator&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_list = MyAllocList&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : my_list) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用typedef 我们只能定义一个 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span> =</span> std::allocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList2</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_list_2 = MyAllocList2&lt;<span class="keyword">int</span>&gt;::type&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="switch-amp-break"><a href="#switch-amp-break" class="headerlink" title="switch &amp; break"></a>switch &amp; break</h3><p>其实我这里就想说一点，就是switch当匹配到case后，如果case没有执行break，会继续执行下面的case，已经不管case是否匹配了！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>break用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (x) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="typename"><a href="#typename" class="headerlink" title="typename"></a>typename</h3><p>C++ 为什么要引入一个 typename 关键词，不光光是申明一个 模版参数列表 这么简单，其次更重要的是申明模版依赖(dependency)，需要配合 <code>template</code> 关键词使用！在模版元编程中大量使用！</p><p>比较感兴趣的两个话题：</p><ul><li><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/613132#613132">https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/613132#613132</a></p></li><li><p><a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~driscoll/typename.html">https://pages.cs.wisc.edu/~driscoll/typename.html</a></p></li></ul><p>typename和class有着相同的能力在模版这里，但是typename更多的是为了支持模版！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;spdlog/spdlog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fmt</span>:</span>:formatter&lt;Test&gt; : fmt::formatter&lt;std::string&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">auto</span> <span class="title">format</span><span class="params">(<span class="keyword">const</span> Test &amp;my, fmt::format_context &amp;ctx)</span> -&gt; <span class="title">decltype</span><span class="params">(ctx.out())</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> format_to(ctx.<span class="built_in">out</span>(), <span class="string">&quot;[test name=&#123;&#125;]&quot;</span>, my.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">has_const_formatter</span><span class="params">(T t)</span> -&gt; <span class="title">decltype</span><span class="params">(<span class="keyword">typename</span> fmt::formatter&lt;T&gt;().format(std::declval&lt;<span class="keyword">const</span> T &amp;&gt;(), std::declval&lt;fmt::format_context &amp;&gt;()), <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; has_const_formatter&lt;&gt;(Test&#123;&#125;) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载-运算符重载"><a href="#操作符重载-运算符重载" class="headerlink" title="操作符重载(运算符重载)"></a>操作符重载(运算符重载)</h2><p>本质上操作符重载就是可以理解为方法的重载，和普通方法没啥差别！但是C++支持将一些 一元/二元/三元的运算符进行重载！</p><p>实际上运算符重载是支持 <strong>类内重载、类外重载</strong>的，两者是等价的！但是有些运算符必须要类内重载，例如 <code>=</code> 、<code>[]</code>、<code>()</code>、<code>-&gt;</code> 等运算符必须类内重载！</p><p>这也就是为啥 ostream 的 <code>&lt;&lt;</code>仅仅重载了部分类型，就可以实现输出任意类型了（只要你实现了重载），有别于一些其他语言的实现了，例如Java依赖于Object#ToString继承，Go依赖于接口实现等！运算符重载的好处在于编译器就可以做到检测！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> re, im;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">int</span> re, <span class="keyword">int</span> im) : <span class="built_in">re</span>(re), <span class="built_in">im</span>(im) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 语法就是 type operator&lt;operator-symbol&gt;(parameter-list)</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re + other.re, <span class="keyword">this</span>-&gt;im + other.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;re: &quot;</span> &lt;&lt; re &lt;&lt; <span class="string">&quot;, im: &quot;</span> &lt;&lt; im &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    Complex a = <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Complex b = <span class="built_in">Complex</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Complex c = a + b;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// re: 3, im: 3</span></span><br></pre></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>首先lambda 其实在函数式编程很常见，但实际上我个人还是不理解，如果为了更短的代码，我觉得毫无意义，只不过是一个语法糖罢了，本质上C++的Lambda就是语法糖，编译后会发现实际上是一个匿名的仿函数！</p><p>那么什么才是lambda？我觉得函数式编程，一个很强的概念就是(anywhere define function)任意地方都可以定义函数，例如我现在经常写Go，我定义了一个方法，我需要用到某个方法，但是呢这个作用范围我不想放到外面，因为外面也用不到。因此分为了立即执行函数和变量函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	newDemo := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> *<span class="title">Demo</span></span> &#123; <span class="comment">// newDemo变量 是一个函数类型</span></span><br><span class="line">		<span class="keyword">return</span> &amp;Demo&#123;</span><br><span class="line">			Name: <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &amp;v</span><br><span class="line">			&#125;(v), <span class="comment">// 立即执行函数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	demo1 := newDemo(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	demo2 := newDemo(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	fmt.Println(demo1.Name)</span><br><span class="line">	fmt.Println(demo2.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么换做C++，我怎么写呢？ 是的如此强大的C++完全支持， 哈哈哈哈！注意是C++11 ！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newDemo = [](<span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Demo</span>([&amp;] &#123;</span><br><span class="line">            <span class="keyword">if</span> (*name == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> * null;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;;</span><br><span class="line">    Demo* d1 = <span class="built_in">newDemo</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    Demo* d2 = <span class="built_in">newDemo</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; d1-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; d2-&gt;name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上面的例子我们大概知道了如何定义一个 变量的类型是函数 ， 其次如何定义一个立即执行函数！</p><ul><li>函数类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[=]：通过值捕捉所有变量</span></span><br><span class="line"><span class="comment">[&amp;]：通过引用捕捉所有变量</span></span><br><span class="line"><span class="comment">[&amp;x]只通过引用捕捉x，不捕捉其他变量。</span></span><br><span class="line"><span class="comment">[x]只通过值捕捉x，不捕捉其他变量。</span></span><br><span class="line"><span class="comment">[=, &amp;x， &amp;y]默认通过值捕捉，变量x和y例外，这两个变量通过引用捕捉。</span></span><br><span class="line"><span class="comment">[&amp;, x]默认通过引用捕捉，变量x例外，这个变量通过引用捕捉。</span></span><br><span class="line"><span class="comment">[&amp;x, &amp;y]非法，因为标志符不允许重复。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lam = [&amp;]() &#123; <span class="comment">// [&amp;] 表示引用传递</span></span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">        y = y + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lam = [=]() &#123; <span class="comment">// [=] 表示值传递，不可以做写操作，类似于const属性</span></span><br><span class="line">        <span class="comment">// x = x+1; // 不可以操作</span></span><br><span class="line">        <span class="comment">// y = y+1; // 不可以操作</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &amp;x表示传递x的引用</span></span><br><span class="line">    <span class="comment">// y 表示函数参数</span></span><br><span class="line">    <span class="comment">// 类型是: std::function&lt;int(int)&gt;</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; lam = [&amp;x](<span class="keyword">int</span> y) &#123;</span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>立即执行函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lam: 函数类型</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; lam = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">lam</span>(<span class="number">1</span>, <span class="number">9</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">lam</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即执行函数</span></span><br><span class="line">    [] &#123; std::cout &lt;&lt; <span class="string">&quot;立即执行函数&quot;</span> &lt;&lt; std::endl; &#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 10 8</span></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br></pre></td></tr></table></figure><ul><li>函数作为参数传递</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">print</span><span class="params">(std::string str)</span> <span class="title">throw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;str is empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [=] &#123; std::cout &lt;&lt; <span class="string">&quot;print: &quot;</span> &lt;&lt; str &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)();</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;函数执行失败, 异常信息: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: </span></span><br><span class="line"><span class="comment">// 函数执行失败, 异常信息: str is empty</span></span><br><span class="line"><span class="comment">// print: abc</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>区别于仿函数，仿函数是重载了<code>()</code>运算符，仿函数本质上是类，但是C++11引入了<code>std::function</code> 也就是 lamdba 简化了仿函数，所以C++11 不再推荐仿函数了！</li><li>区别于函数指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberPrint</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NumberPrint</span><span class="params">(<span class="keyword">int</span> max)</span> : max(max)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 仿函数</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; vector, <span class="keyword">void</span> (*foo)(<span class="keyword">int</span>))</span> </span>&#123; std::for_each(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), foo); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printVector</span>(std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, printNum);</span><br><span class="line">    <span class="keyword">auto</span> arr = std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">NumberPrint</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数指针的致命缺陷， 就是函数指针不支持捕获参数，所以最好别用函数指针，除非对接C！</li></ul><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/8-25/305c9fff224e4c5d998d19b8a51c6441.png" alt="image-20230825180008956"></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的枚举继承了C，也就是支持 enum 和 enum class，两者的区别主要是在于作用范围的不同， 例如下面 <code>Child</code> 和 <code>Student</code> 都定义了 Girl 和 Body，如果不是 enum class 的话则会报错！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许指定类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    Girl, <span class="comment">// 不指定且位置是第一个就是0</span></span><br><span class="line">    Boy = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::map&lt;Child, std::string&gt; child_map = &#123;&#123;</span><br><span class="line">                                                           Child::Girl,</span><br><span class="line">                                                           <span class="string">&quot;Girl&quot;</span>,</span><br><span class="line">                                                       &#125;,</span><br><span class="line">                                                       &#123;</span><br><span class="line">                                                           Child::Boy,</span><br><span class="line">                                                           <span class="string">&quot;Boy&quot;</span>,</span><br><span class="line">                                                       &#125;&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="keyword">const</span> Child&amp; child) &#123; <span class="comment">// 重载方法 &lt;&lt; 方法</span></span><br><span class="line">    <span class="keyword">auto</span> kv = child_map.<span class="built_in">find</span>(child);</span><br><span class="line">    <span class="keyword">if</span> (kv == child_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;Unknown[&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(child) &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; kv-&gt;second;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    Girl,</span><br><span class="line">    Boy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child x = Child::Boy;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(x) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Child</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><ul><li>template: 模版</li><li>template specialization: 模版特化</li><li>学习文档推荐：<ul><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/templates">https://en.cppreference.com/w/cpp/language/templates</a></li><li>C++ Template （第二版）</li></ul></li></ul><p>C++的模版是现代C++的灵魂，支持包含类型限定、抽象，其灵活性非常之高！为什么是模版呢，模版本质上就是一个代码生成器，因为为了追求高性能，不允许存在运行时的性能损耗，所以C++采用了模版的技术来实现泛型(generic)。</p><p>模版在实例化的过程中会存在一个问题就是 C++类型退化 的问题, 这里可能会使用到 <code>std::decay</code> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/heartchord/p/5039894.html">https://www.cnblogs.com/heartchord/p/5039894.html</a> 。</p><h3 id="类模版"><a href="#类模版" class="headerlink" title="类模版"></a>类模版</h3><p>类模版支持全特化和偏特化</p><blockquote><p>参考文章:</p><ul><li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_parameters">https://en.cppreference.com/w/cpp/language/template_parameters</a></p></li><li><p><a target="_blank" rel="noopener" href="https://harttle.land/2015/10/03/cpp-template.html">https://harttle.land/2015/10/03/cpp-template.html</a></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doc: https://en.cppreference.com/w/cpp/language/template_parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-type template parameter</span></span><br><span class="line"><span class="comment">// 这里的Non-type 可以理解为它是一个具体类型，而非 &#x27;typename T&#x27; or &#x27;class T&#x27;</span></span><br><span class="line"><span class="comment">// 其中类型可以是，具体参考上面文章就行了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type template parameter</span></span><br><span class="line"><span class="comment">// 这里可以是 &#x27;typename T&#x27; or &#x27;class T&#x27;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span> &#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版实例化: 偏特化</span></span><br><span class="line"><span class="comment">// 偏特化: 仅特化 type template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span>&lt;</span>K, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> type_id = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版实例化: 全特化</span></span><br><span class="line"><span class="comment">// 全特化: 特化全部的 type template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> type_id = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版，此处打印 type_id</span></span><br><span class="line"><span class="comment">// 注意模版在编译器会检查，如果没有用到就不会检查语法错误</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_type_id</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type_id: &quot;</span> &lt;&lt; T::type_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> S&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TArray</span> &#123;</span></span><br><span class="line">    T array[S];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template template parameter</span></span><br><span class="line"><span class="comment">// 实际上个人感觉吧比较适合于, 限定 template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">size_t</span> Size = <span class="number">16</span>, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">size_t</span> S&gt; class ArrayValue = TArray&gt;</span><br><span class="line">struct ArrayKV &#123;</span><br><span class="line">    Key key;</span><br><span class="line">    ArrayValue&lt;Value, Size&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KV&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv1&#123;&#125;;</span><br><span class="line">    KV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt; kv2&#123;&#125;;</span><br><span class="line">    KV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *&gt; kv3&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv1); <span class="comment">// type_id: 2</span></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv2); <span class="comment">// type_id: 1</span></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv3); <span class="comment">// error: 编译失败</span></span><br><span class="line"></span><br><span class="line">    ArrayKV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt; kv4&#123;&#125;;</span><br><span class="line">    kv4.value.array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    kv4.value.array[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数模版"><a href="#函数模版" class="headerlink" title="函数模版"></a>函数模版</h3><p>注意: 函数不支持偏特化，仅支持全特化，即不允许特化模版函数有模版参数，原因是函数支持重载</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化 模版</span></span><br><span class="line"><span class="comment">// 注意函数模版不需要手动申明 &#x27;&lt;模版实参&gt;&#x27; (如果出现推断冲突的情况下也可以申明)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="comment">// 理论上的偏特化, 但是函数支持重载, 因此函数不支持偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(K key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 如果出现歧义，例如2/3/4代码，其实就是歧义了，可以通过申明模版实参解决</span></span><br><span class="line">    <span class="built_in">do_print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);                  <span class="comment">// func1</span></span><br><span class="line">    do_print&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt;(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// func2</span></span><br><span class="line">    do_print&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);      <span class="comment">// func3</span></span><br><span class="line">    <span class="built_in">do_print</span>(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);                    <span class="comment">// func3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>注意</li></ol><ul><li>模版由于其特殊性实现部分只能在头文件中定义，主要原因是因为函数模版的实例化过程实际上在编译过程中，我们很多情况下仅依赖头文件和链接(编译后的产物)，所以实现部分必须定义在头文件，我们才可以使用头文件的模版！</li><li>或者通过模版全特化的方案</li><li>其次就是参考 fmt 包的方案</li></ul><ol start="4"><li>class 与 template 区别</li></ol><blockquote><p>有点面试经感觉，说实话我个人觉得只是语法支持度上的差异: <a target="_blank" rel="noopener" href="https://liam.page/2018/03/16/keywords-typename-and-class-in-Cxx/">https://liam.page/2018/03/16/keywords-typename-and-class-in-Cxx/</a></p></blockquote><h3 id="type-traits"><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h3><p>模版的类型推断是非常强大，那么基本上高级玩法都差不多，我们可以看以下几个例子</p><ol><li>移除指针, 头文件 <code>type_traits</code> 的内容</li></ol><p>实现思路很简单，就是模版在匹配的时候，我们把指针引用的类型拿到就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer                      &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp*&gt;                &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* const&gt;          &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* volatile&gt;       &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* const volatile&gt; &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>限定类型，这个用处最多，他是通过参数2来限定参数1的类型，例如下面仅允许指针类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPoint</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有指针类型: 才有value字段，且value为true</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPoint</span>&lt;</span>T *&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> Enable, <span class="keyword">typename</span> T = <span class="keyword">void</span>&gt;</span><br><span class="line">struct EnableIf &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅有Enable=true的时候，才会有type申明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EnableIf</span>&lt;</span><span class="literal">true</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// std::is_pointer&lt;T&gt;::value 相当于如果你是指针，那么会有一个value=true</span></span><br><span class="line"><span class="comment">// std::enable_if&lt;bool,T=void&gt; 当true的时候会定义一个type类型，且这个type默认是void类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_point</span><span class="params">(T t, <span class="keyword">typename</span> std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type * = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, *t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = <span class="number">10086</span>;</span><br><span class="line">    <span class="built_in">do_print_point</span>(&amp;x1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">do_print_point</span>(x1); <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模版实际上并不会检查语法，因此可以限定函数执行，具体编译后函数可以看: <a target="_blank" rel="noopener" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgp0ZW1wbGF0ZSA8Y2xhc3MgSW5wdXRJdGVyYXRvciwgY2xhc3MgRnVuY3Rpb24+CkZ1bmN0aW9uIEZvckVhY2goSW5wdXRJdGVyYXRvciBfZmlyc3QsIElucHV0SXRlcmF0b3IgX2xhc3QsIEZ1bmN0aW9uIF9mKSB7CiAgICBmb3IgKDsgX2ZpcnN0ICE9IF9sYXN0OyArK19maXJzdCkgeyBfZigqX2ZpcnN0KTsgfQogICAgcmV0dXJuIF9mOwp9CgppbnQgbWFpbigpIHsKICAgIGludCBhcnJbMTBde307CiAgICBGb3JFYWNoKGFyciwgJmFycls5XSwgW10oaW50ICZ4KSB7IHggPSAxMDsgfSk7CiAgICBGb3JFYWNoKGFyciwgJmFycls5XSwgW10oY29uc3QgaW50ICZ4KSB7IHN0ZDo6Y291dCA8PCB4IDw8IHN0ZDo6ZW5kbDsgfSk7Cn0=&insightsOptions=cpp11&std=cpp11&rev=1.0">链接</a></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">ForEach</span><span class="params">(InputIterator _first, InputIterator _last, Function _f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; _first != _last; ++_first) &#123; _f(*_first); &#125;</span><br><span class="line">    <span class="keyword">return</span> _f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(arr, &amp;arr[<span class="number">9</span>], [](<span class="keyword">int</span> &amp;x) &#123; x = <span class="number">10</span>; &#125;);</span><br><span class="line">    <span class="built_in">ForEach</span>(arr, &amp;arr[<span class="number">9</span>], [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x) &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>std::declval</li></ol><h3 id="可变参数模版"><a href="#可变参数模版" class="headerlink" title="可变参数模版"></a>可变参数模版</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/338785886">https://zhuanlan.zhihu.com/p/338785886</a></p><p>可变参数模版本质上就是编译器实现的一个代码展开罢了！在C++11的时候我们大概率只能这么写，可以看下面的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T firstArg, Types... args)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; firstArg &lt;&lt; <span class="string">&#x27; &#x27;</span>; <span class="comment">// print first argument</span></span><br><span class="line">    <span class="built_in">print</span>(args...);               <span class="comment">// call print() for remaining arguments</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">1</span>, <span class="number">1.11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 展开后</span></span><br><span class="line"><span class="comment">/* First instantiated from: insights.cpp:13 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>, <span class="keyword">double</span>&gt;(<span class="keyword">const</span> <span class="keyword">char</span> * firstArg, <span class="keyword">int</span> __args1, <span class="keyword">double</span> __args2)</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::<span class="keyword">operator</span>&lt;&lt;(std::cout, firstArg), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(__args1, __args2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First instantiated from: insights.cpp:9 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="keyword">int</span>, <span class="keyword">double</span>&gt;(<span class="keyword">int</span> firstArg, <span class="keyword">double</span> __args1)</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(firstArg), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>(__args1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* First instantiated from: insights.cpp:9 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> INSIGHTS_USE_TEMPLATE</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> print&lt;<span class="keyword">double</span>&gt;(<span class="keyword">double</span> firstArg)</span><br><span class="line">&#123;</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;(std::cout.<span class="keyword">operator</span>&lt;&lt;(firstArg), <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">  <span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C++17以后，支持了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/fold">Fold Expressions</a>，写法上有点奇怪</p><p>大概率分为几部分组成 <code>...</code> 、<code>operator</code> 、<code>pack(function)</code> ，然后首位用 () 括起来！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">( pack op ... )	(1)	 // (E1 op (... op (EN-1 op EN)))</span><br><span class="line">( ... op pack )	(2)	 // (((E1 op E2) op ...) op EN)</span><br><span class="line">( pack op ... op init )	(3)	 // (E1 op (... op (EN−1 op (EN op I))))</span><br><span class="line">( init op ... op pack )	(4)	// ((((I op E1) op E2) op ...) op EN)</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">output</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    (std::cout &lt;&lt; ... &lt;&lt; args) &lt;&lt; <span class="string">&quot;\n&quot;</span>;                     <span class="comment">// ( init op ... op pack )</span></span><br><span class="line">    ((std::cout &lt;&lt; <span class="string">&quot;[info]: &quot;</span>), ..., <span class="built_in">output</span>(args)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// ( init op ... op pack )</span></span><br><span class="line">    (<span class="built_in">output</span>(args), ..., (std::cout &lt;&lt; <span class="string">&quot; [end]\n&quot;</span>));         <span class="comment">// ( pack op ... op init ) </span></span><br><span class="line"></span><br><span class="line">    (..., (std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// ( ... op pack ) left</span></span><br><span class="line">    (..., <span class="built_in">output</span>(args)) &lt;&lt; <span class="string">&quot;\n&quot;</span>;               <span class="comment">// ( ... op pack ) left</span></span><br><span class="line"></span><br><span class="line">    ((std::cout &lt;&lt; args &lt;&lt; <span class="string">&quot; &quot;</span>), ...) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// ( pack op ... ) right</span></span><br><span class="line">    (<span class="built_in">output</span>(args), ...) &lt;&lt; <span class="string">&quot;\n&quot;</span>;               <span class="comment">// ( pack op ... ) right</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error">SFINAE</a></h3><p>sfinae 是模版元编程的核心思想，说白了就是代码匹配，如果A类型匹配上就是A否则就是B，可以看下面的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral_helper</span> &#123;</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral_helper</span>&lt;</span><span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_integral_helper</span>&lt;</span><span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::enable_if&lt;is_integral_helper&lt;T&gt;::value, T&gt;::<span class="function">type <span class="title">add</span><span class="params">(T t1, T t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; is_integral_helper&lt;<span class="keyword">int</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_integral_helper&lt;<span class="keyword">bool</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; is_integral_helper&lt;<span class="keyword">float</span>&gt;::value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>); <span class="comment">// 报错，看不懂的报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="concept"><a href="#concept" class="headerlink" title="concept"></a>concept</h3><p>说白了 concept 就是简化了 模版匹配, 上面的例子我们可以这么简化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> is_integral=is_integral_helper&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> is_integral&lt;T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T t1, T t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 + t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>cpp设定类型实际上是取巧，通过限制返回值类型去限定类型，可以发现实际上 requires 本质上就是等价于 std::enable_if_t 的设定！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> std::is_same_v&lt;std::string, K&gt; &amp;&amp; std::is_integral_v&lt;V&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(std::unordered_map&lt;K, V&gt; &amp;map)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有concept+requires之前</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line">std::<span class="keyword">enable_if_t</span>&lt;std::is_same_v&lt;std::string, K&gt; &amp;&amp; std::is_integral_v&lt;V&gt;, <span class="keyword">void</span>&gt;</span><br><span class="line"><span class="built_in">foo2</span>(std::unordered_map&lt;K, V&gt; &amp;map) &#123;&#125;</span><br></pre></td></tr></table></figure><p>现代的泛型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>[<span class="title">KEY</span> <span class="title">string</span>, <span class="title">VALUE</span> <span class="title">float32</span> | <span class="title">float64</span>]<span class="params">(kv <span class="keyword">map</span>[KEY]VALUE)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸭子类型，像Go和rust有点喜欢鸭子类型，就是你长的跟我像就行！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## STL</span><br><span class="line"></span><br><span class="line">STL：（Standard Template Library）叫做C++标准模版库，其实可以理解为C++最核心的部分，很多人望而却步，其实我感觉还好！</span><br><span class="line"></span><br><span class="line">主要包含：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 容器类模板： 基本的数据结构，数组、队列、栈、map、图 等，如果你学习过很多高级语言，那么对于C++这些容器结构我觉得其实不用太投入，只要熟悉几个API就可以了！</span><br><span class="line"></span><br><span class="line">![img](https:<span class="comment">//tyut.oss-accelerate.aliyuncs.com/image/2023/4-4/29a85e81682f4bc9af672afc2f45fa40.png)</span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>算法（函数）模板：基本的算法，排序和统计等 ， 其实就是一些工具包</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>迭代器类模板：我觉得在Java中很常见，因为你要实现 for each 就需要实现 iterator 接口，其实迭代器类模版也就是这个了！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>总结</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>  <span class="comment">// 算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span>  <span class="comment">// 迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>    <span class="comment">// 容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到targetVal位置，并在targetVal前面插入insertVal</span></span><br><span class="line"><span class="comment">// 未找到则在尾部插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="keyword">const</span> V&amp; targetVal, <span class="keyword">const</span> V&amp; insertVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">using</span> std::begin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container), targetVal);</span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    <span class="keyword">auto</span> arr = std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">findAndInsert</span>(arr, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">decltype</span>(*arr.<span class="built_in">begin</span>()) elem) &#123; cout &lt;&lt; elem &lt;&lt; endl; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>现在很多高级语言都支持切片，可以说是大大提高了开发效率，但是cpp也有，也很简单，区别在于是c++实现的是拷贝，而非内存复用，所以这种需求还是用迭代器比较好！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> IntVector = std::vector&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(std::vector&lt;T&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;item : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index != <span class="number">0</span>) &#123; std::cout &lt;&lt; <span class="string">&quot;, &quot;</span>; &#125;</span><br><span class="line">        std::cout &lt;&lt; item;</span><br><span class="line">        ++index;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;]&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IntVector v1&#123;&#125;;</span><br><span class="line">    v1.<span class="built_in">reserve</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123; v1.<span class="built_in">push_back</span>(x); &#125;</span><br><span class="line">    <span class="built_in">print</span>(v1);</span><br><span class="line">    <span class="comment">// [:4]</span></span><br><span class="line">    <span class="keyword">auto</span> v2 = <span class="built_in">IntVector</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">begin</span>() + <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line">    <span class="comment">// [1:-1]</span></span><br><span class="line">    <span class="keyword">auto</span> v3 = <span class="built_in">IntVector</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, v1.<span class="built_in">end</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">print</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更加推荐，传递迭代器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> begin = v1.<span class="built_in">begin</span>(); begin != v1.<span class="built_in">begin</span>() + <span class="number">4</span>; begin++) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;range: &quot;</span> &lt;&lt; *begin &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++14支持lambda表达式参数用auto</span></span><br><span class="line">    std::for_each(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, v1.<span class="built_in">begin</span>() + <span class="number">4</span>, [](<span class="keyword">auto</span> elem) &#123; std::cout &lt;&lt; <span class="string">&quot;for_each: &quot;</span> &lt;&lt; elem &lt;&lt; std::endl; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理器-宏"><a href="#预处理器-宏" class="headerlink" title="预处理器 - 宏"></a>预处理器 - 宏</h2><p>宏本质上就是在预处理阶段把宏替换成对应的代码，属于代码模版[ C++/C 思想真的超前 ]，可以省去不少代码工作量，其次就是性能更好，不需要函数调用，直接预处理阶段内联到代码中去了，例如我这里就用了宏 <a target="_blank" rel="noopener" href="https://github.com/Anthony-Dong/protobuf/blob/master/pb_include.h">https://github.com/Anthony-Dong/protobuf/blob/master/pb_include.h</a> ！</p><p>宏的玩法太高级，很多源码满满的宏，不介意新手去深入了解！只要能看懂就行了，简单实用一下也完全可以的哈！</p><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> product(x) x* x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">product</span>((<span class="number">1</span> + <span class="number">1</span>)) + <span class="number">10</span>; <span class="comment">// 展开后:  (1 + 1)*(1 + 1) + 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">product</span>(<span class="number">1</span> + <span class="number">1</span>) + <span class="number">10</span>; <span class="comment">// 展开后: 1 + 1*1 + 1 + 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print debug&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line">x: <span class="number">14</span></span><br><span class="line">y: <span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="class-宏-类名的意义"><a href="#class-宏-类名的意义" class="headerlink" title="class+宏+类名的意义"></a>class+宏+类名的意义</h3><blockquote><p>注意: 这里要是有windows环境的话可以自己体验下！</p></blockquote><p>不清楚大家阅读过c++源码吗，发现开源的代码中基本都有一个 ,那么问题是 <code>PROTOBUF_EXPORT</code> 干啥了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PROTOBUF_EXPORT</span> <span class="title">CodedInputStream</span> &#123;</span></span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上你自己写代码没啥问题，定不定义这个宏，你要把代码/ddl提供给别人用windows的开发者来说就有问题了，别人引用你的api需要申明一个 <code>__declspec(dllexport)</code> 宏定义，表示导出这个class，具体可以看 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes">https://learn.microsoft.com/en-us/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes</a> 所以说对于跨端开发来说是非常重要的这点！</p><p>其次这个东西很多时候可以在编译器层面做手脚，表示特殊标识，反正 大概你知道 windows 下需求这个东东就行了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DllExport</span> <span class="title">C</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>待补充！</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread">https://en.cppreference.com/w/cpp/thread</a></p><p>cpp11 的 thread、mutex、lock_guard、lock_uniq、feature</p><p>cpp14 支持了 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/thread/shared_lock">shared_lock</a></p><p>cpp17 支持了 async 、shared_mutex</p><p>cpp20 支持了 jthread 和 coroutine</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> GuardLock = std::lock_guard&lt;std::mutex&gt;;</span><br><span class="line">    <span class="keyword">using</span> UniqueLock = std::unique_lock&lt;std::mutex&gt;;</span><br><span class="line">    std::mutex mutex;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> test = [&amp;count, &amp;mutex]() &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">100000</span>; y++) &#123;</span><br><span class="line">                GuardLock <span class="built_in">lock</span>(mutex);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="function">std::jthread <span class="title">tt</span><span class="params">(test)</span></span>;</span><br><span class="line">        <span class="function">std::jthread <span class="title">t2</span><span class="params">(test)</span></span>;</span><br><span class="line">        <span class="function">std::jthread <span class="title">t3</span><span class="params">(test)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;main&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="new-与-malloc"><a href="#new-与-malloc" class="headerlink" title="new 与 malloc"></a>new 与 malloc</h3><p>我们知道，我们可以再 C语言里使用 <code>malloc</code> 和 <code>frees</code> 初始化内存，但是C++ 里更加推荐使用 new 和 delete ，那么区别在哪里了！</p><p>首先我们知道C++引入了 构造函数 和 析构函数，因此我们用 c系列的api操作，会丢失这些信息，这就是最主要的区别，也是特别需要注意的！</p><p>例子一: 最常见的乱用行为！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x_)</span> : x(x_) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;release: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test* test = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 错误行为</span></span><br><span class="line"><span class="comment">//    free(test);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确，会调用析构函数！</span></span><br><span class="line">    <span class="keyword">delete</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二： 业务中为了做一些事情，例如有些特殊case需要用 void* 指针进行操作（例如导出C），解决内存拷贝的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test* test = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">    CClass c&#123;</span><br><span class="line">        .point = test,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 正确行为，需要强制转换成 Test*；</span></span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span> (Test*)c.point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-与-delete"><a href="#new-与-delete" class="headerlink" title="new[] 与 delete[]"></a>new[] 与 delete[]</h3><p>我们可以简单看下面这个例子，就大概明白了，new与delete的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">builtin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> list = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">        list[x] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)list - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出不确定</span></span><br><span class="line">    <span class="keyword">delete</span>[] list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">external</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> list = <span class="keyword">new</span> Test[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">        list[x].x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)list - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出10</span></span><br><span class="line">    <span class="keyword">delete</span>[] list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>内置类型的话，内存中不会存储长度字段</li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/2a0b8ed1e97440e49abd23990d48cd77.png" alt="image-20230517005229594"></p><ol start="2"><li>其他类型，会在首地址-8 的位置存储长度，也就是64位是8字节</li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/668842e1a693400abc7faf276e4bcc8b.png" alt="image-20230517005016406"></p><ol start="3"><li>所以对于<code>new[]</code> 的指针对象，一定要用<code>delete[]</code> 释放，不然的话你会内存泄漏奥！</li></ol><h3 id="C-位域"><a href="#C-位域" class="headerlink" title="C++ 位域"></a>C++ 位域</h3><p><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-bit-fields?view=msvc-170">https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-bit-fields?view=msvc-170</a> 可以节约内存开销</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">http_parser</span> &#123;</span></span><br><span class="line">    <span class="comment">/** PRIVATE **/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> type : <span class="number">2</span>;                   <span class="comment">/* enum http_parser_type */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags : <span class="number">8</span>;                  <span class="comment">/* F_* values from &#x27;flags&#x27; enum; semi-public */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> state : <span class="number">7</span>;                  <span class="comment">/* enum state from http_parser.c */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> header_state : <span class="number">7</span>;           <span class="comment">/* enum header_state from http_parser.c */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index : <span class="number">5</span>;                  <span class="comment">/* index into current matcher */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> uses_transfer_encoding : <span class="number">1</span>; <span class="comment">/* Transfer-Encoding header is present */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> allow_chunked_length : <span class="number">1</span>;   <span class="comment">/* Allow headers with both</span></span><br><span class="line"><span class="comment">                                              * `Content-Length` and</span></span><br><span class="line"><span class="comment">                                              * `Transfer-Encoding: chunked` set */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lenient_http_headers : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> nread;          <span class="comment">/* # bytes read in various scenarios */</span></span><br><span class="line">    <span class="keyword">uint64_t</span> content_length; <span class="comment">/* # bytes in body. `(uint64_t) -1` (all bits one)</span></span><br><span class="line"><span class="comment">                              * if no Content-Length header.</span></span><br><span class="line"><span class="comment">                              */</span></span><br><span class="line">    <span class="comment">/** READ-ONLY **/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> http_major;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> http_minor;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> status_code : <span class="number">16</span>; <span class="comment">/* responses only */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method : <span class="number">8</span>;       <span class="comment">/* requests only */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> http_errno : <span class="number">7</span>;</span><br><span class="line">    <span class="comment">/* 1 = Upgrade header was present and the parser has exited because of that.</span></span><br><span class="line"><span class="comment">     * 0 = No upgrade header present.</span></span><br><span class="line"><span class="comment">     * Should be checked when http_parser_execute() returns in addition to</span></span><br><span class="line"><span class="comment">     * error checking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> upgrade : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** PUBLIC **/</span></span><br><span class="line">    <span class="keyword">void</span> *data; <span class="comment">/* A pointer to get hook to the &quot;connection&quot; or &quot;socket&quot; object */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(http_parser) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 32</span></span><br></pre></td></tr></table></figure><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>我们知道c语言是没有namespace的概念的，作用域是全局的，所以导致头文件如果存在公共定义是可能会存在问题的。</p><p>c++ 支持了namespace，解决命名冲突的问题，但是同样的它会造成编译的时候 符号连接会带上namespace，导致c语言无法和c++链接，此时就需要用到 <code>extern &quot;C&quot;</code> 了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Misc &#123;</span><br><span class="line"><span class="keyword">namespace</span> Utils &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Consts</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Utils</span></span><br><span class="line">&#125; <span class="comment">// namespace Misc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Misc &#123;</span><br><span class="line"><span class="keyword">namespace</span> Network &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TcpConnect</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> Consts = Utils::Consts; <span class="comment">// 他们都存在Misc namespace下，所以可以这么引用，因为必须要全限定namespace(这种日常开发中经常会使用)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> FullConsts = Misc::Utils::Consts; <span class="comment">// 不推荐</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace Network</span></span><br><span class="line">&#125; <span class="comment">// namespace Misc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><ul><li>absl: <a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp">https://github.com/abseil/abseil-cpp</a></li><li>protobuf： <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></li><li>fmt: <a target="_blank" rel="noopener" href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></li><li>libevent: <a target="_blank" rel="noopener" href="https://libevent.org/">https://libevent.org/</a></li><li>googletest: <a target="_blank" rel="noopener" href="https://github.com/google/googletest">https://github.com/google/googletest</a></li></ul><h2 id="其他学习资料"><a href="#其他学习资料" class="headerlink" title="其他学习资料"></a>其他学习资料</h2><ul><li><a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org/</a> 一个C++ 转 汇编的工具</li><li><a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a> 可以看到编译器编译后的结果</li><li><a target="_blank" rel="noopener" href="https://coliru.stacked-crooked.com/">https://coliru.stacked-crooked.com/</a> 可以运行c++代码</li><li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs">https://gcc.gnu.org/onlinedocs</a></li><li>C++学习的一些网站资料（直接去Github找）<ul><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language">https://en.cppreference.com/w/cpp/language</a> 无脑推荐的百科全书</li><li><a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/iterator/">https://oi-wiki.org/lang/csl/iterator/</a></li><li><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/">https://cntransgroup.github.io/EffectiveModernCppChinese/</a></li><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/operator-overloading">https://learn.microsoft.com/zh-cn/cpp/cpp/operator-overloading</a></li></ul></li></ul></div><div class="reward-container"><div>本人坚持原创技术分享，如果你觉得文章对您有用，请随意打赏! 如果有需要咨询的请发送到我的邮箱!</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Anthony-Dong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="Anthony-Dong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Anthony-Dong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/" title="C++ 入门到放弃">https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"># C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/31/5c4904cd995fb585e97a439065161818/" rel="prev" title="Protobuf-SourceCodeInfo 介绍"><i class="fa fa-chevron-left"></i> Protobuf-SourceCodeInfo 介绍</a></div><div class="post-nav-item"><a href="/2023/04/23/291f1489dc6255cedb0b626e74c04f9d/" rel="next" title="Cmake学习">Cmake学习 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">学习环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8Ehello-world-%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">从hello world 开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#char-%E5%92%8C-char-%E5%92%8C-std-string"><span class="nav-number">3.1.</span> <span class="nav-text">char* 和 char[] 和 std::string</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-x-%E5%92%8C-x"><span class="nav-number">4.1.</span> <span class="nav-text">关于 x++ 和 ++x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8-%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC-%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">引用 (左值&#x2F;右值&#x2F;万能引用)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">类的初始化函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">类的基本的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%99%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">类的初始化写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">6.</span> <span class="nav-text">类的多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#override-%E3%80%81final"><span class="nav-number">6.2.</span> <span class="nav-text">override 、final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected"><span class="nav-number">6.3.</span> <span class="nav-text">protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#friend"><span class="nav-number">6.4.</span> <span class="nav-text">friend</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="nav-number">7.</span> <span class="nav-text">指针的一些细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%901-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">7.1.</span> <span class="nav-text">例子1: 数组与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%902-%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-number">7.2.</span> <span class="nav-text">例子2: 数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%903-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">7.3.</span> <span class="nav-text">例子3: 常量指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%82%B9"><span class="nav-number">7.4.</span> <span class="nav-text">补充一些小点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-ptr"><span class="nav-number">8.1.</span> <span class="nav-text">std::unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-shared-ptr"><span class="nav-number">8.2.</span> <span class="nav-text">std::shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-weak-ptr"><span class="nav-number">8.3.</span> <span class="nav-text">std::weak_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="nav-number">8.4.</span> <span class="nav-text">智能指针和数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83"><span class="nav-number">8.5.</span> <span class="nav-text">内存回收的一些思考</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">9.</span> <span class="nav-text">关键词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">9.1.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#constexpr"><span class="nav-number">9.2.</span> <span class="nav-text">constexpr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">9.3.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern"><span class="nav-number">9.4.</span> <span class="nav-text">extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E5%92%8C-decltype"><span class="nav-number">9.5.</span> <span class="nav-text">auto 和 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-%E5%92%8C-typedef"><span class="nav-number">9.6.</span> <span class="nav-text">using 和 typedef</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#switch-amp-break"><span class="nav-number">9.7.</span> <span class="nav-text">switch &amp; break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#typename"><span class="nav-number">9.8.</span> <span class="nav-text">typename</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">10.</span> <span class="nav-text">操作符重载(运算符重载)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda"><span class="nav-number">11.</span> <span class="nav-text">lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">12.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%89%88"><span class="nav-number">13.</span> <span class="nav-text">模版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E7%89%88"><span class="nav-number">13.1.</span> <span class="nav-text">类模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E7%89%88"><span class="nav-number">13.2.</span> <span class="nav-text">函数模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#type-traits"><span class="nav-number">13.3.</span> <span class="nav-text">type traits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E7%89%88"><span class="nav-number">13.4.</span> <span class="nav-text">可变参数模版</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SFINAE"><span class="nav-number">13.5.</span> <span class="nav-text">SFINAE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#concept"><span class="nav-number">13.6.</span> <span class="nav-text">concept</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-%E5%AE%8F"><span class="nav-number">14.</span> <span class="nav-text">预处理器 - 宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">14.1.</span> <span class="nav-text">简单的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-%E5%AE%8F-%E7%B1%BB%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">14.2.</span> <span class="nav-text">class+宏+类名的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTTI"><span class="nav-number">15.</span> <span class="nav-text">RTTI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">16.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">17.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E4%B8%8E-malloc"><span class="nav-number">17.1.</span> <span class="nav-text">new 与 malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E4%B8%8E-delete"><span class="nav-number">17.2.</span> <span class="nav-text">new[] 与 delete[]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%BD%8D%E5%9F%9F"><span class="nav-number">17.3.</span> <span class="nav-text">C++ 位域</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace"><span class="nav-number">17.4.</span> <span class="nav-text">namespace</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E5%BA%93"><span class="nav-number">18.</span> <span class="nav-text">常用库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99"><span class="nav-number">19.</span> <span class="nav-text">其他学习资料</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Anthony-Dong" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Anthony-Dong</p><div class="site-description" itemprop="description">喜欢写代码</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anthony-dong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anthony-dong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@gmail.com" title="E-Mail → mailto:fanhaodong516@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/4248168663101320" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4248168663101320" rel="noopener" target="_blank"><i class="fas fa-book fa-fw"></i>掘金</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@163.com" title="国内邮箱 → mailto:fanhaodong516@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>国内邮箱</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Anthony-Dong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">436k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:36</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/medium-zoom.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.js",()=>{new Gitalk({clientID:"b1c466a9c5677a8d374a",clientSecret:"7cf9512c7e4b46b574e901b18983be7ae5b47d74",repo:"anthony-dong.github.io",owner:"Anthony-Dong",admin:["Anthony-Dong"],id:"bae479e8e605922d7c6fd0b73d991a32",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>
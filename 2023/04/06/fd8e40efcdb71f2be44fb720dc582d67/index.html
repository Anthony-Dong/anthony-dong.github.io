<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico"><link rel="mask-icon" href="/images/favicon.ico" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"anthony-dong.github.io",root:"/",scheme:"Pisces",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:"mac"},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!1,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.json"}</script><meta name="description" content="C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C&#x2F;C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C&#x2F;C++有着丰富的生态，很多高级语言也提供了接口可以对接C&#x2F;C++ (JNI&#x2F;CGO等) ，这样你可以很方便的将一些底层C&#x2F;C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++"><meta property="og:type" content="article"><meta property="og:title" content="C++ 入门到放弃"><meta property="og:url" content="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/index.html"><meta property="og:site_name" content="Anthony-Dong"><meta property="og:description" content="C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C&#x2F;C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C&#x2F;C++有着丰富的生态，很多高级语言也提供了接口可以对接C&#x2F;C++ (JNI&#x2F;CGO等) ，这样你可以很方便的将一些底层C&#x2F;C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-6/38778ab329d54946a8ad80a9c4e8ad34.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-7/c419f7baf244478d9843f794f8846b7d.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-4/29a85e81682f4bc9af672afc2f45fa40.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/2a0b8ed1e97440e49abd23990d48cd77.png"><meta property="og:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/668842e1a693400abc7faf276e4bcc8b.png"><meta property="article:published_time" content="2023-04-06T10:01:37.000Z"><meta property="article:modified_time" content="2023-07-17T02:58:03.492Z"><meta property="article:author" content="Anthony-Dong"><meta property="article:tag" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-6/38778ab329d54946a8ad80a9c4e8ad34.png"><link rel="canonical" href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>C++ 入门到放弃 | Anthony-Dong</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?899b2a5c34078209c5f30853eaaa7846";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Anthony-Dong</h1><span class="logo-line-after"><i></i></span></a><p class="site-subtitle" itemprop="description">Anthony-Dong技术博客</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><a href="https://github.com/Anthony-Dong" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="Anthony-Dong"><meta itemprop="description" content="追寻技术的本质！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Anthony-Dong"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ 入门到放弃</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2023-04-06 18:01:37" itemprop="dateCreated datePublished" datetime="2023-04-06T18:01:37+08:00">2023-04-06</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2023-07-17 10:58:03" itemprop="dateModified" datetime="2023-07-17T10:58:03+08:00">2023-07-17</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a></span></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>40k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>36 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><p>C++目前在一些领域处于垄断地位，比如数据库内核、高性能网络代理、基础软件设施 等基本都是C/C++的垄断领域，虽然其他语言也有在做，但是生态、性能等都无法企及，其次C/C++有着丰富的生态，很多高级语言也提供了接口可以对接C/C++ (JNI/CGO等) ，这样你可以很方便的将一些底层C/C++库链接到自己的项目中，避免造轮子！本人学习C++目的是为了看懂别人的代码，因为很多优秀的项目都是C++写的，而非我从事C++相关领域开发！</p><p>个人觉得 C++比较难的是 <strong>内存管理</strong> + <strong>编译工具 + 面向对象</strong> 了，其他就是<strong>庞大且复杂的语法/模版</strong>需要勤加练习和使用，C++灵魂就是<strong>指针+模版</strong>，本文主要就是点到为止！</p><p>本篇文章会长期更新和补充，而且篇幅过长，我平时喜欢把学习语言的文档归类到一起，所以会存在体积较大的问题！</p><span id="more"></span><h2 id="学习环境"><a href="#学习环境" class="headerlink" title="学习环境"></a>学习环境</h2><p>个人觉得如果你是一个新手，一定要选一个利于学习的环境，个人比较推荐新手用 clion！其次本文全部都是基于 C++11 走的，目前C++ 版本有 98、14、20 ！编译工具用的<a target="_blank" rel="noopener" href="https://gcc.gnu.org/releases.html">gcc</a> + <a target="_blank" rel="noopener" href="https://cmake.org/documentation/">cmake</a>，camke学习成本并不是太高(bazel复杂度有点高)，可以看我写的文章: <a href="https://anthony-dong.github.io/2023/04/23/291f1489dc6255cedb0b626e74c04f9d/">cmake入门</a>！</p><p>如果你是c++开发同学最好选择自己公司的编译工具和开发规范！C++规范，按照公司的来即可，如果没有的话可以参考Google的：<a target="_blank" rel="noopener" href="https://github.com/google/styleguide">https://github.com/google/styleguide</a></p><p>学习文档的话，语法学习仅建议学习官方文档：<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language%EF%BC%8C">https://en.cppreference.com/w/cpp/language，</a> 原因就是内容最全面、分类最具体，如果你东看西看可能<strong>概念很模糊</strong>！技巧学习的话我建议多看看开源项目，其次就是看一下经验的书 effective c++，，实践才是硬道理！</p><h2 id="从hello-world-开始"><a href="#从hello-world-开始" class="headerlink" title="从hello world 开始"></a>从hello world 开始</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">              &lt;&lt; <span class="string">&quot;World!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不清楚大家对于上面代码比较好奇的是哪里了？比如说我好奇的是为啥<code>&lt;&lt;</code>就可以输出了， 为啥还可以 &lt;&lt; 实现 append 输出？ 对，这个就是我的疑问！</p><p>那么带着问题，我们可能要熟悉 C++操作符重载 和 C++面向对象编程！ 然后你就可以很好的理解上面代码了！</p><p>思考一下是不是等价于下面这个代码了？是不是很容易理解了就！可以把 <code>operator&lt;&lt;</code> 理解为一个方法名！ 具体细节下文会讲解！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="keyword">operator</span>&lt;&lt;(std::cout,<span class="string">&quot;Hello&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot; &quot;</span>).<span class="keyword">operator</span>&lt;&lt;(<span class="string">&quot;World!&quot;</span>).<span class="keyword">operator</span>&lt;&lt;(std::endl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>注意C++很多时候都是跨端开发，所以具体基础类型得看你的系统环境，常见的基础类型你可以直接在 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/types">https://en.cppreference.com/w/cpp/language/types</a> 这里查看 ！</p><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-6/38778ab329d54946a8ad80a9c4e8ad34.png" alt="image-20230406180051539"></p><h3 id="char-和-char-和-std-string"><a href="#char-和-char-和-std-string" class="headerlink" title="char* 和 char[] 和 std::string"></a>char* 和 char[] 和 std::string</h3><blockquote><p>本块内容可以先了解一遍，看完本篇内容再回头看一下会理解一些！</p></blockquote><p>字符串在编程中处于一个必不可少的操作，那么C++中提供的 std::string 和 char* 区别在呢了？</p><p>简单来说<code>const char* xxx= &quot;字面量&quot;</code> 的性能应该是最高的，因为字面量分配在常量区域，更加安全，但是注意奥不可修改的！</p><p><code>char[]= &quot;字面量&quot; | new char[]&#123;&#125;</code> 分配在栈上或者堆上非常不安全，这种需求直接用 <code>std::vector</code> 或者 <code>std::array</code> 更好！</p><p><code>std::string</code> 在C++11有了移动语意后，性能已经在部分场景优化了很多，进行字符串操作比较多的话介意用这个，别乱用<code>std::string*</code> 。使用 <code>std::string</code> 一般不会涉及到内存安全问题，无非就是多几次拷贝！ <strong>如果用指针最好也别用裸指针，别瞎<code>new</code>，可以用智能指针，或者参数[引用]传递！</strong></p><p>下面是一个简单的例子，可以参考学习！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getStackStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="comment">// 不能这么返回，属于不安全的行为，因为arr分配在栈上，你返回了一个栈上的地址，但是这个函数调用这个栈就消亡了，所以不安全!</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getConstStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不会有内存安全问题，就是永远指向常量池的一块内存</span></span><br><span class="line">    <span class="comment">// 对于这种代码，我们非常推荐用 const char*</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* arr = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getHeapStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// stack 分配在栈上, 将数据拷贝到返回函数 arr上!</span></span><br><span class="line">    <span class="keyword">char</span> stack[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>* arr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(stack) + <span class="number">1</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(arr, stack);</span><br><span class="line">    *arr = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="string">&#x27;E&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 分配在堆上，我们返回了一个裸指针，用户需要手动释放，不释放有内存安全问题</span></span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里std::string直接分配在堆上, 它的回收取决于 std::unique_ptr 的消亡, 具体有兴趣可以看下智能指针</span></span><br><span class="line"><span class="comment">// 注意: 千万别用函数返回一个裸指针，那么它是非常不安全的，需要手动释放!</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;std::string&gt; <span class="title">getUniquePtrStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> str = std::unique_ptr&lt;std::string&gt;(<span class="keyword">new</span> std::<span class="built_in">string</span>(<span class="string">&quot;hello world.&quot;</span>));</span><br><span class="line">    str-&gt;<span class="built_in">append</span>(<span class="string">&quot; i am from heap and used unique_ptr.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意: 这里返回的str实际上进行了一次拷贝，实现在std::string的拷贝构造函数上!</span></span><br><span class="line"><span class="function">std::string <span class="title">getStdStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;hello world.&quot;</span>;</span><br><span class="line">    str += <span class="string">&quot; i am from stack and used copy constructor.&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a是一个指针，指向常量区， &quot;hello world&quot; 分配在常量区，对于这种申明C++11推荐用 const 标记出来，因为常量区我们程序运行时是无法修改的</span></span><br><span class="line">    <span class="keyword">char</span>* a = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b是一个指针，指向常量区，&quot;c++&quot; 分配在常量区</span></span><br><span class="line">    <span class="comment">// 常量区编译器会优化，也就是说 a 和 b 俩人吧他们的内容都一模一样，那么所以常量只有一份</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* b = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* c = <span class="string">&quot;hello world c&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr 分配在栈上，当函数调用结束就销毁了！</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;1111&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 乱码!!!</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getStackStr</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 正常</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">getConstStr</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 常量是不会重复分配内存的，所以下面3个输出结果是一样的!</span></span><br><span class="line">    <span class="keyword">auto</span> arr1 = <span class="built_in">getConstStr</span>();</span><br><span class="line">    <span class="keyword">auto</span> arr2 = <span class="built_in">getConstStr</span>();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, arr2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> arr3 = <span class="built_in">getHeapStr</span>();</span><br><span class="line">    <span class="comment">// 正常打印</span></span><br><span class="line">    cout &lt;&lt; arr3 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 需要手动释放</span></span><br><span class="line">    <span class="keyword">delete</span>[] arr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::string 是一个类，也就是说它内存开销非常的高，而且对于大的数据会分配在堆上性能以及效率会差一些!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里本质上调用的是 str的copy constructor函数，属于隐式类型转换!</span></span><br><span class="line">    std::string str = arr1;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, str.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务中如何使用 std::string了，最好使用std:unique_ptr，可以减少内存的拷贝!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// c++ 中一般不推荐return一个复杂的数据结构(因为涉及到拷贝,</span></span><br><span class="line">    <span class="comment">// 或者你就用指针，或者C++11引入了移动语意，降低拷贝)，而是推荐通过参数把返回变量传递过去，进而减少拷贝!</span></span><br><span class="line">    cout &lt;&lt; *<span class="built_in">getUniquePtrStr</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getStdStr</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="关于-x-和-x"><a href="#关于-x-和-x" class="headerlink" title="关于 x++ 和 ++x"></a>关于 x++ 和 ++x</h3><p>首先学过Java/C的同学都知道，x++ 返回的是x+1之前的值， ++x返回的是x+1后的值！ 他俩都可以使x加1，但是他俩的返回值不同罢了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 x++</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xadd</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = x;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 ++x</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>&amp; <span class="title">addx</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//    int tmp = x++;</span></span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">xadd</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset</span></span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//    tmp = ++x;</span></span><br><span class="line">    tmp = <span class="built_in">addx</span>(x);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tmp = tmp + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, tmp: &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出:</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 10</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 11</span></span><br><span class="line">    <span class="comment">// x: 11, tmp: 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用-左值-右值引用"><a href="#引用-左值-右值引用" class="headerlink" title="引用 (左值/右值引用)"></a>引用 (左值/右值引用)</h3><blockquote><p>不介意前期看，这种东西偏向于面试经！</p></blockquote><p>下面是一个简单的例子，可以看到引用的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span> inc)</span> </span>&#123;</span><br><span class="line">    a = a + inc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">inc</span>(a, <span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>其实上面这个例子属于左值引用，为什么叫左值引用，是因为它只能引用 <strong>左值</strong> ， 你可以理解为左值 <strong>是一个被定义类型的变量</strong>，那么它一定可以被取址（因为左引用很多编译器就是用的指针去实现的）， <strong>右值则相反，例如字面量</strong>； 右值包含<strong>纯右值</strong>和<strong>将亡值</strong>(将亡值我个人理解是如果没有使用那么下一步就被回收了，生命到达终点的那种！)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// x: 是一个变量，其内存分配在栈空间上，为左值，我可以取x的指针，那么x指针指向的就是栈上的某个空间</span></span><br><span class="line"><span class="comment">// 10: 是一个字面量，为右值，如果没有x那么它就和谁也没关系，认为是垃圾(注意右值引用就是要用垃圾，让垃圾生命延续)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* s= <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><p>具体可以看下面这个例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rvalue</span><span class="params">(<span class="keyword">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    x = x + <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lvalue</span><span class="params">(<span class="keyword">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pointValue</span><span class="params">(<span class="keyword">int</span>* x)</span> </span>&#123;</span><br><span class="line">    *x = *x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">lvalue</span>(number);      <span class="comment">// number 可以通过指针查找到，是一个已经明确分配的内存!</span></span><br><span class="line">    <span class="built_in">pointValue</span>(&amp;number); <span class="comment">// number可以取指针</span></span><br><span class="line">    <span class="comment">// rvalue(number);              // 不可以</span></span><br><span class="line">    <span class="built_in">rvalue</span>(<span class="number">10</span>);                  <span class="comment">// 可以，因为10是一个字面量！</span></span><br><span class="line">    <span class="built_in">rvalue</span>([] &#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;()); <span class="comment">// 可以，因为返回值10如果不用就当垃圾销毁了!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// x++ 返回的是右值，额外发生了临时变量拷贝，返回的是拷贝的数字，为右值</span></span><br><span class="line">    <span class="comment">// lvalue(number++);</span></span><br><span class="line">    <span class="built_in">rvalue</span>(number++);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ++x 返回的是左值，直接在x上自增返回！</span></span><br><span class="line">    <span class="built_in">lvalue</span>(++number);</span><br><span class="line">    <span class="comment">// rvalue(++number);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有兴趣的可以看文章:</p><ul><li><a target="_blank" rel="noopener" href="https://paul.pub/cpp-value-category/">https://paul.pub/cpp-value-category/</a></li><li><a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/reference/">https://oi-wiki.org/lang/reference/</a></li></ul><p>补充:</p><ul><li>并不是所有函数返回值都是右值，例如函数可以返回一个左值，例如 <code>++x</code></li><li>右值引用可以降低内存拷贝，也就是部分情况不需要内存拷贝！</li><li>这里了解左值和右值的区别即可</li></ul><h2 id="类的初始化函数"><a href="#类的初始化函数" class="headerlink" title="类的初始化函数"></a>类的初始化函数</h2><h3 id="类的基本的成员函数"><a href="#类的基本的成员函数" class="headerlink" title="类的基本的成员函数"></a>类的基本的成员函数</h3><blockquote><p><strong>这个是C++ 最难的地方，新手做到知道即可，不建议深挖，无底洞一个，显然禁止拷贝和移动才是最佳选择！</strong></p></blockquote><p>C++ 的类，最基本也会有几个部分组成，就算你定义了一个空的类，那么<strong>它也会有（前提你使用了这些操作）</strong>，和Java的有点像！</p><ul><li>default constructor: <strong>默认构造函数</strong></li><li>copy constructor: <strong>拷贝构造函数</strong> （注意: 编译器默认生成的拷贝构造函数是浅拷贝！）</li><li>copy assigment constructor: <strong>拷贝赋值构造函数</strong></li><li>deconstructor: <strong>析构函数</strong> ！</li><li>C++11引入了 move constructor （<strong>移动构造函数 <strong>） 、 move assigment constructor（</strong>移动赋值构造函数</strong>）</li></ul><blockquote><p>补充:</p><ol><li>默认的拷贝/拷贝赋值构造函数是<strong>浅拷贝</strong>， <strong>所以如果不需要拷贝，那么禁用是最佳选择，也是避免BUG的最佳选择！</strong></li><li>默认不会生成移动构造函数和移动赋值构造函数，<strong>如果要追求性能可以考虑使用移动</strong>！</li><li>移动 和 拷贝的区别在于，移动的本质是a指向b， 拷贝的本质是 a 要拷贝一份b的数据，会有新数据的产生，移动一般配置<code>std::move()</code> 使用！</li><li>参考文章: <a target="_blank" rel="noopener" href="https://paul.pub/cpp-value-category/">https://paul.pub/cpp-value-category/</a></li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-7/c419f7baf244478d9843f794f8846b7d.png" alt="image-20230407121445355"></p></blockquote><p>例如下面 <code>TestStrcut</code> 实际上我重写了这几个函数，大概我们看一下它的调用逻辑吧</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStrcut</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TestStrcut</span>() &#123; cout &lt;&lt; <span class="string">&quot;invoke default constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">TestStrcut</span>(<span class="keyword">const</span> TestStrcut&amp; ts) &#123; cout &lt;&lt; <span class="string">&quot;invoke copy constructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    TestStrcut&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> TestStrcut&amp; ts) &#123; <span class="comment">//  注意: 这里的&amp;不是取值符号，而是一个引用符号! https://www.cnblogs.com/haruyuki/p/15683592.html</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoke copy assigment constructor&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TestStrcut</span>() &#123; cout &lt;&lt; <span class="string">&quot;invoke deconstructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TestStrcut <span class="title">foo</span><span class="params">(TestStrcut ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ts;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  省略写法 TestStrcut ts1;</span></span><br><span class="line">    TestStrcut ts1 = <span class="built_in">TestStrcut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略写法 TestStrcut ts2(ts1);</span></span><br><span class="line">    <span class="comment">// ts2为啥了，因为初始化一个新变量的时候是不会执行 copy assigment</span></span><br><span class="line">    <span class="comment">// constructor的，省了一步吧!</span></span><br><span class="line">    TestStrcut ts2 = <span class="built_in">TestStrcut</span>(ts1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ts3这里为啥了? 不直接调用 copy assigment constructor</span></span><br><span class="line">    <span class="comment">// 了，因为你是一个新变量，不需要考虑 = 这种操作符! 但是你需要考虑初始化!</span></span><br><span class="line">    <span class="comment">// 不然ts1 和 ts2都需要调用 = 操作符</span></span><br><span class="line">    TestStrcut ts3 = ts2;</span><br><span class="line">    TestStrcut ts4;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里就做了一个赋值操作，因为ts4已经初始化了，但是要把ts3赋值给ts4.</span></span><br><span class="line">    ts4 = ts3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===start===&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用要值传递，所以要copy一下， ts4 copy给了 foo函数的参数1,</span></span><br><span class="line">    <span class="comment">// 函数有返回值，返回值也需要拷贝一次;</span></span><br><span class="line">    TestStrcut ts5 = <span class="built_in">foo</span>(ts4);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;===end===&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">invoke default constructor</span><br><span class="line">invoke copy constructor</span><br><span class="line">invoke copy constructor</span><br><span class="line">invoke default constructor</span><br><span class="line">invoke copy assigment constructor</span><br><span class="line">===start===</span><br><span class="line">invoke copy constructor</span><br><span class="line">invoke copy constructor</span><br><span class="line">invoke deconstructor</span><br><span class="line">===end===</span><br><span class="line">invoke deconstructor</span><br><span class="line">invoke deconstructor</span><br><span class="line">invoke deconstructor</span><br><span class="line">invoke deconstructor</span><br><span class="line">invoke deconstructor</span><br></pre></td></tr></table></figure><p>总结:</p><p>用到再说！</p><h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><p>这里我们要知道一点就是 C++ 类的初始化内置类型(builtin type)是不会自动初始化为0的，但是类类型(非指针类型)的话却会自动调用默认构造函数，具体为啥了，兼容C，不然会很慢，因为假如你要初始化一个类，例如定义了10个内置类型的字段，我需要10次赋值调用才能把10个字段初始化成0，而不初始化只需要开辟固定的内存空间即可，可以大大提高代码运行效率！</p><blockquote><p>大部分情况下都是推荐使用初始化列表的！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// struct Info&#123;</span></span><br><span class="line"><span class="comment">//     int id;</span></span><br><span class="line"><span class="comment">//     long salary;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="built_in">Demo</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;init demo&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">long</span> salary;</span><br><span class="line">    Demo wrapper;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 未使用初始化列表</span></span><br><span class="line">    Info info;</span><br><span class="line">    cout &lt;&lt; info.id &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; info.wrapper.id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    Info* infop;</span><br><span class="line">    cout &lt;&lt; infop &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用初始化列表</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;======= C++11 初始化列表 &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Info info1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; info1.id &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; info1.wrapper.id &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> x1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; x1 &lt;&lt; endl;</span><br><span class="line">    Info* infop1&#123;&#125;;</span><br><span class="line">    cout &lt;&lt; infop1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// init demo</span></span><br><span class="line"><span class="comment">// 185313075</span></span><br><span class="line"><span class="comment">// 88051808</span></span><br><span class="line"><span class="comment">// 32759</span></span><br><span class="line"><span class="comment">// 0x10b11c010</span></span><br><span class="line"><span class="comment">// ======= C++11 初始化列表</span></span><br><span class="line"><span class="comment">// init demo</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0x0</span></span><br></pre></td></tr></table></figure><p>类的初始化列表：</p><ul><li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html</a></li><li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/value_initialization">https://en.cppreference.com/w/cpp/language/value_initialization</a></li></ul><h3 id="类的初始化写法"><a href="#类的初始化写法" class="headerlink" title="类的初始化写法"></a>类的初始化写法</h3><p>C++11 就下面这三种写法</p><ul><li><code>( expression-list )</code>小括号括起来的表达式列表</li><li><code>= expression</code> 表达式</li><li><code>&#123; initializer-list &#125;</code> 大括号括起来的表达式列表，C++11比较推荐这种写法</li></ul><p>然后这三种写法大题分为了几大类，这几大类主要是为了区分吧，我个人觉得就是语法上的归类，主要是cpp历史包袱太重了，其次追求高性能，进而分类了很多初始化写法，具体可以看官方文档： <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/initialization">https://en.cppreference.com/w/cpp/language/initialization</a> ！</p><h2 id="类的多态"><a href="#类的多态" class="headerlink" title="类的多态"></a>类的多态</h2><blockquote><p>前期先掌握基本语法吧，实际用到的时候再深入学习，类的继承在C++中特别复杂，因为会涉及到模版、类型转换、虚函数、析构函数，注意事项非常多！</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>下面是一个继承的例子，注意c++是支持多继承的，具体原因自行百度！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BasePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;A:BasePrint::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BasePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;B:BasePrint::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BasePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D:BasePrint::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> :</span> <span class="keyword">public</span> B &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;E::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BasePrint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;E:BasePrint::Print&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    B b;</span><br><span class="line">    E e;</span><br><span class="line">    D d;</span><br><span class="line"></span><br><span class="line">    A* pa = &amp;a;</span><br><span class="line">    B* pb = &amp;b;</span><br><span class="line">    D* pd = &amp;d;</span><br><span class="line">    E* pe = &amp;e;</span><br><span class="line"></span><br><span class="line">    pa-&gt;<span class="built_in">Print</span>(); <span class="comment">// A::Print</span></span><br><span class="line">    pa-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// A:BasePrint::Print</span></span><br><span class="line"></span><br><span class="line">    pa = pb;</span><br><span class="line">    pa-&gt;<span class="built_in">Print</span>(); <span class="comment">// B::Print</span></span><br><span class="line">    pa-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// A:BasePrint::Print</span></span><br><span class="line">    pb-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// B:BasePrint::Print</span></span><br><span class="line"></span><br><span class="line">    pa = pd;</span><br><span class="line">    pa-&gt;<span class="built_in">Print</span>(); <span class="comment">// D::Print</span></span><br><span class="line">    pa-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// A:BasePrint::Print</span></span><br><span class="line">    pd-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// D:BasePrint::Print</span></span><br><span class="line"></span><br><span class="line">    pa = pe;</span><br><span class="line">    pa-&gt;<span class="built_in">Print</span>(); <span class="comment">// E::Print</span></span><br><span class="line">    pa-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// A:BasePrint::Print</span></span><br><span class="line">    pe-&gt;<span class="built_in">BasePrint</span>(); <span class="comment">// B:BasePrint::Print</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="override-、final"><a href="#override-、final" class="headerlink" title="override 、final"></a>override 、final</h3><blockquote><p>override（重写） 和 overload（重载） 区别在于 override 是继承引入的概念！</p></blockquote><p>这俩修饰词主要是解决继承中重写的问题！</p><ol><li>类被修饰为 final</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">final</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我不想被继承&quot;</span> &lt;&lt; endl; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123; <span class="comment">// 这里会被编译报错，说A无法被继承！</span></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>方法被修饰为 final</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;我不想被继承&quot;</span> &lt;&lt; endl; &#125;; <span class="comment">// 申明我这个函数无法被继承，注意: final只能修饰virtual函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">// 这里编译报错，无法重写父类方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>方法修饰为 override</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> A &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span></span>; <span class="comment">// 这里编译报错，重写需要父类有定义！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h3><p>public 和 private其实没多必要介绍， 但是涉及到继承，<strong>仅允许我的子类访问那么就需要protected关键词了</strong>，区别于Java的protected.</p><h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a>friend</h3><p>friend （友元）表示外部方法可以访问我的private/protected变量， 正常来说我定义一个一些私有的成员变量，外部函数调用的话，是访问不了的，但是友元函数可以，例如下面这个case：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Data&amp; c);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> id&#123;&#125;;</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="keyword">const</span> Data&amp; c) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;(Id=&quot;</span> &lt;&lt; c.id &lt;&lt; <span class="string">&quot;,Name=&quot;</span> &lt;&lt; c.name &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; Data&#123;&#125; &lt;&lt; std::endl;  <span class="comment">// 这里会涉及到运算符重载的一些细节，具体可以看本篇文章!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针的一些细节"><a href="#指针的一些细节" class="headerlink" title="指针的一些细节"></a>指针的一些细节</h2><p>注意：<strong>别瞎new指针, new了地方要么用智能指针自动回收，要么用delete手动回收！</strong> 手动new的一定会分配在堆上，所以性能本身就不高！</p><p>什么叫指针，可以理解为就是一块内存区域的地址，这个地址就是一个64/32位的无符号整数，可以通过操作这个内存地址进行 获取值（因为指针是有类型的），修改内存等操作！</p><p>在C/C++ 语言中，表示指针很简单，例如 <code>int* ptr</code> 表示ptr是一个int类型的指针 或者 一个int数组！</p><p>判断指针为空用 <code>nullptr</code> !</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* ptr;   <span class="comment">// 表示ptr是一个int类型的指针</span></span><br><span class="line">    ptr = &amp;num; <span class="comment">// 取num的地址</span></span><br><span class="line">    num = *ptr; <span class="comment">// 取ptr的值</span></span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;  <span class="comment">// 判断ptr不为空, 也可以与 nullptr 或 NULL 进行比较，我比较推荐与 nullptr 比较，比较直观！</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ptr is not nil&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>* ptr2 = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ptr2) &#123; <span class="comment">// 判断ptr2为空</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;ptr2 is  nil&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// ptr is not nil</span></span><br><span class="line"><span class="comment">// ptr2 is nil</span></span><br></pre></td></tr></table></figure><h3 id="例子1-数组与指针"><a href="#例子1-数组与指针" class="headerlink" title="例子1: 数组与指针"></a>例子1: 数组与指针</h3><p>C++/C 中数组和指针最奇妙，原因是 <strong>数组</strong> 和 <strong>指针</strong> 基本概念等价，因为两者都是指向内存的首地址，区别在于<strong>数组名定义了数组的长度</strong>，<strong>但是指针没有数组长度的概念，因此我们无法通过一个指针获取数组长度</strong>！</p><p>类似于下面这个例子， arr 是一个数组，p1、p2是一个数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>* p1 = arr;</span><br><span class="line">    <span class="keyword">int</span>* p2 = &amp;arr[<span class="number">0</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(arr)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; <span class="string">&quot;, sizeof(arr[1])=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">1</span>]) &lt;&lt; <span class="string">&quot;, sizeof(p1)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p1) &lt;&lt; <span class="string">&quot;, sizeof(p2)=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(p2) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr len=&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arr=&quot;</span> &lt;&lt; arr &lt;&lt; <span class="string">&quot;, p1=&quot;</span> &lt;&lt; p1 &lt;&lt; <span class="string">&quot;, p2=&quot;</span> &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, (arr+i)=&quot;</span> &lt;&lt; arr + i &lt;&lt; <span class="string">&quot;, (p1+i)=&quot;</span> &lt;&lt; p1 + i &lt;&lt; <span class="string">&quot;, arr[i]=&quot;</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, *(p1+i)=&quot;</span> &lt;&lt; *(p1 + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sizeof(arr)=20, sizeof(arr[1])=4, sizeof(p1)=8, sizeof(p2)=8</span><br><span class="line">arr len=5</span><br><span class="line">arr=0x7ff7bd9999f0, p1=0x7ff7bd9999f0, p2=0x7ff7bd9999f0</span><br><span class="line">i=0, (arr+i)=0x7ff7bd9999f0, (p1+i)=0x7ff7bd9999f0, arr[i]=1, *(p1+i)=1</span><br><span class="line">i=1, (arr+i)=0x7ff7bd9999f4, (p1+i)=0x7ff7bd9999f4, arr[i]=2, *(p1+i)=2</span><br><span class="line">i=2, (arr+i)=0x7ff7bd9999f8, (p1+i)=0x7ff7bd9999f8, arr[i]=3, *(p1+i)=3</span><br><span class="line">i=3, (arr+i)=0x7ff7bd9999fc, (p1+i)=0x7ff7bd9999fc, arr[i]=4, *(p1+i)=4</span><br><span class="line">i=4, (arr+i)=0x7ff7bd999a00, (p1+i)=0x7ff7bd999a00, arr[i]=5, *(p1+i)=5</span><br></pre></td></tr></table></figure><p>结论:</p><ol><li>数组、数组指针其实都是 数组的第一个元素对应的内存地址（指针）</li><li>数组+1 和 指针+1 ，其实不是简单的int+1的操作，而是偏移了类型的长度，原因是 <strong>指针是有类型的，且指针默认重载了 + 运算符</strong>！</li><li>数组是可以获取数组的长度的，但是数组指针不可以！</li></ol><p>注意：</p><ul><li>数组delete 和 delete[] 需要特别注意，因为 delete[]与new[] 成对出现，以及 delete和new成对出现</li></ul><h3 id="例子2-数组长度"><a href="#例子2-数组长度" class="headerlink" title="例子2: 数组长度"></a>例子2: 数组长度</h3><p>通常，我们不可能在main函数里写代码，是不是，我们更多都是函数调用，那么问题来了？ 函数调用如何安全的操作呢？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">get_array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123;</span><br><span class="line">        *(arr + i) = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* arr = <span class="built_in">get_array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) &#123; <span class="comment">// 这里无法获取数组指针 arr 的长度</span></span><br><span class="line">        cout &lt;&lt; *(arr + i) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题： 如何获取arr的长度的呢？ 显然是不可以获取的！</p><h3 id="例子3-常量指针"><a href="#例子3-常量指针" class="headerlink" title="例子3: 常量指针"></a>例子3: 常量指针</h3><ol><li>常量指针(<strong>Constant Pointer</strong>)，表示的是指针指向的内存（内容）不可以修改，也就是说 <code>*p</code> 不可以修改，但是 <code>p</code>可以修改</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* p; <span class="comment">// const 修饰的是 *p， *p不可以变（指向的内容），但是p可以变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* p; <span class="comment">// 写法上没啥区别, 都修饰的是 *p, 我比较推荐这种写法</span></span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* p = &amp;x;</span><br><span class="line">    <span class="comment">// *p = 10; // 不允许改变 指针指向的值</span></span><br><span class="line">    p = p2; <span class="comment">// 允许</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// p: 0</span></span><br></pre></td></tr></table></figure><ol start="2"><li>指针常量(<strong>pointer to a constant</strong>：指向常量的指针)，表示 p 不可以修改，但是 <code>*p</code> 可以修改</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* <span class="keyword">const</span> p</span><br></pre></td></tr></table></figure><p>例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span>* p2 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> p = &amp;x;</span><br><span class="line">    *p = <span class="number">20</span>; <span class="comment">// 允许改变 指针指向的值</span></span><br><span class="line">    <span class="comment">// p = p2; // 不允许</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;p: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// p: 20</span></span><br></pre></td></tr></table></figure><ol start="3"><li>指向常量的常量指针</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p; <span class="comment">// 它兼容了两者的全部优点！</span></span><br></pre></td></tr></table></figure><ol start="4"><li>总结</li></ol><p>大部分case都是使用常量指针，因为指针传递是不安全的，<strong>如果我们的目的是不让指针去操作内存</strong>，那么我们就用 <strong>常量指针</strong>，对与指针本身来说就是一个64位的int它变与不变你不用管！</p><h3 id="补充一些小点"><a href="#补充一些小点" class="headerlink" title="补充一些小点"></a>补充一些小点</h3><ol><li>指针到底写在 类型上好 <code>int* p</code>，还是变量上好 <code>int *p</code>, 没有正确答案，我是写Go的所以习惯写到类型上！具体可以看 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/52305847?rf=21136956">https://www.zhihu.com/question/52305847?rf=21136956</a></li><li>指向成员的指针运算符: (比较难理解，个人感觉实际上就是定义了一个指针 alies )<ol><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/pointer-to-member-operators-dot-star-and-star?view=msvc-170">.* 和 -&gt;*</a></li><li><a target="_blank" rel="noopener" href="https://isocpp.org/blog/2019/03/quick-q-pointer-to-class-data-member">::*</a></li></ol></li></ol><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>在C++11中存在四种智能指针：<code>std::auto_ptr</code>，<code>std::unique_ptr</code>，<code>std::shared_ptr</code>，<code>std::weak_ptr</code>，</p><p>auto_ptr : c++98 中提供了，目前已经不推荐使用了</p><p>unique_ptr: 这个对象没有实现拷贝构造函数，所以我们用的时候只能用 <code>std::move</code> 进行移动赋值 ，<strong>经常使用</strong>！</p><p>shared_ptr: 其实类似于GC语言的对象，他通过引用计数【循环引用会导致内存泄露】，实现自动回收，<strong>经常使用</strong>吧！</p><p>weak_ptr: 本质上就是解决 shared_ptr 循环引用的问题，它持有 shared_ptr，但是不会使得shared_ptr引用计数增加，<strong>很少使用</strong>吧！</p><p>c++14新增了<code>make_unique</code> 的api，这里的原理会涉及到 <code>std::move</code> 和 <code>std::forward</code> 函数相关知识， 有兴趣可以了解下 完美转发和万能引用，以及移动语意！</p><h3 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x_)</span> : x(x_) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;release: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test* <span class="title">newTestFunc</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Test</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::unique_ptr&lt;Test&gt; test1 = std::unique_ptr&lt;Test&gt;(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="comment">// unique_ptr只有移动语意，没有拷贝语义</span></span><br><span class="line">    <span class="keyword">auto</span> test2 = std::<span class="built_in">move</span>(test1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test1 is null ptr: &quot;</span> &lt;&lt; (test1 == <span class="literal">nullptr</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test2.x: &quot;</span> &lt;&lt; test2-&gt;x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reset 会先释放原来指针，然后再赋值</span></span><br><span class="line">    test2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放引用, 例如理论上 test2 会在main函数结束后会释放，但是我其实想要这个内容，我自己管理，就可以用 release 函数释放指针</span></span><br><span class="line">    Test* test2_ = test2.<span class="built_in">release</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;test2_-&gt;x: &quot;</span> &lt;&lt; test2_-&gt;x &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> test2_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不推荐这么写，这样裸指针很危险，也容易忘记释放.</span></span><br><span class="line"><span class="comment">//    Test* test3 = newTestFunc(3);</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 推荐使用智能包装一层</span></span><br><span class="line">    <span class="keyword">auto</span> test = std::unique_ptr&lt;Test&gt;(<span class="built_in">newTestFunc</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-shared-ptr"><a href="#std-shared-ptr" class="headerlink" title="std::shared_ptr"></a>std::shared_ptr</h3><p>shared_ptr 实际上基本已经对标主流的垃圾回收语言了，它使用引用计数的方式实现了垃圾回收！</p><p>shared_ptr 会存储一个引用计数器+指针，每次拷贝都会使得计数器+1然后再拷贝数据，当调用析构函数(或者 reset函数)的时候会使得计数器-1；当为0的时候会直接会去释放指针！所以原理并不复杂吧！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAB</span><span class="params">(<span class="keyword">const</span> std::shared_ptr&lt;AStruct&gt; &amp;ap)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[0]: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line">    bp-&gt;Num = <span class="number">111</span>;</span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[1]: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; std::endl;         <span class="comment">// 2</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[1.1]: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer: bp释放 count=1, 未触发回收;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="built_in">setAB</span>(ap);</span><br><span class="line">    std::cout &lt;&lt; ap-&gt;bPtr-&gt;Num &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;bp-&gt;count[2]: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">use_count</span>() &lt;&lt; std::endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer ap 释放 -&gt; bp释放后 bp.count=0 释放bp!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个也注定有一个陷阱，就是循环引用无法解决！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    std::shared_ptr&lt;AStruct&gt; aPtr;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLoopReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    bp-&gt;aPtr = ap;</span><br><span class="line">  <span class="comment">// 无法释放 ap 和 bp</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestLoopReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-weak-ptr"><a href="#std-weak-ptr" class="headerlink" title="std::weak_ptr"></a>std::weak_ptr</h3><p>weak_ptr 本质上并不能算的上是一个智能指针，只能说是为了解决 shared_ptr 循环引用的问题 [不能根本解决]，weak_ptr相当于拷贝了一份 shared_ptr， 但是引用次数并不会增加，为此假如 shared_ptr 已经被释放了，那么weak_ptr也会指向空指针！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AStruct</span> &#123;</span></span><br><span class="line">    std::weak_ptr&lt;BStruct&gt; bPtr;</span><br><span class="line">    ~<span class="built_in">AStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;AStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BStruct</span> &#123;</span></span><br><span class="line">    std::weak_ptr&lt;AStruct&gt; aPtr;</span><br><span class="line">    <span class="keyword">int</span> Num;</span><br><span class="line">    ~<span class="built_in">BStruct</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;BStruct is deleted!&quot;</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestLoopReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;AStruct&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> AStruct&#123;&#125;)</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;BStruct&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> BStruct&#123;&#125;)</span></span>;</span><br><span class="line">    bp-&gt;Num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak ptr 本身就是弱引用，此时只是只要ap/bp生命周期(也就是这个函数没执行结束)没结束就一直可以使用!</span></span><br><span class="line">    ap-&gt;bPtr = bp;</span><br><span class="line">    bp-&gt;aPtr = ap;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;BStruct.Num: &quot;</span> &lt;&lt; ap-&gt;bPtr.<span class="built_in">lock</span>()-&gt;Num &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">TestLoopReference</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>常量表示不可变的意思，最直接的表达就是，<strong>我这个变量初始化后你就不能进行赋值操作了</strong>！区别于其他语言，其他语言const不能用于函数的参数申明，但是C++可以，现在很多语言都可以了，<strong>主要表达的意思就是 这个参数 不可以做任何修改！</strong></p><p>上文实际中讲到了 常量指针 和 指针常量的区别，所以也不太多解释了，<strong>const修饰的是const右边的值</strong>！</p><p>这里主要是介绍一个双重指针，其他疑问可以看这个链接: <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/433076446">https://www.zhihu.com/question/433076446</a>！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">int</span>* x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span>* p = &amp;x; <span class="comment">// 表示*p是常量</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    **p = <span class="number">100</span>; <span class="comment">// **p允许修改</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// *p = x2; // *p不允许修改!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* x = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>** p = &amp;x; <span class="comment">// 表示**p是常量, 因为它也不需要要用常量*x初始化, 不然编译报错!</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    *p = <span class="keyword">new</span> <span class="built_in"><span class="keyword">int</span></span>(<span class="number">11</span>); <span class="comment">// *p可以修改</span></span><br><span class="line">    cout &lt;&lt; **p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// **p = 10; // **p不可以修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo1</span>();</span><br><span class="line">    <span class="built_in">foo2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>const 可以修饰方法的返回值</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">getString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> str = <span class="built_in">getString</span>();</span><br><span class="line">    *(str + <span class="number">1</span>) = <span class="string">&#x27;a&#x27;</span>;  <span class="comment">// 这里编译报错，只读 str</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>const 修饰方法的参数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123; cout &lt;&lt; str &lt;&lt; endl; &#125; <span class="comment">// 这里无法修改str</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printStr</span>(<span class="string">&quot;1111&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>const 修饰方法， 表示此方法是一个只读的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">this</span>-&gt;a = <span class="number">1</span>; &#125; <span class="comment">// 编译报错，无法修改 this-&gt;a !</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>这个如果你学过Java，static就再陌生不过了，主要差异在于初始化方式上和生命周期上！</p><ol><li>静态变量、静态方法</li></ol><p>注意：</p><ul><li>静态成员变量可以初始化，但只能在类体外进行初始化</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> example &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberX = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberY = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> NumberZ = NumberY + <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;, z: &#123;&#125;\n&quot;</span>, NumberX, NumberY, NumberZ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace example</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> example::Class::x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> example::Class::y = z + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> example::Class::z = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">void</span> example::Class::<span class="built_in">print</span>() &#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;x: &#123;&#125;, y: &#123;&#125;, z: &#123;&#125;&quot;</span>, x, y, z);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    example::<span class="built_in">print</span>();</span><br><span class="line">    example::Class::<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// x: 100, y: 200, z: 500</span></span><br><span class="line"><span class="comment">// x: 1, y: 4, z: 2</span></span><br></pre></td></tr></table></figure><ol start="2"><li>全局静态方法和静态变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ++sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">inc</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">inc</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>模版的静态变量</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> A::num = <span class="number">100</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="keyword">int</span> AA&lt;T&gt;::num = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span> :</span> <span class="keyword">public</span> AA&lt;BB&gt; &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span> :</span> <span class="keyword">public</span> AA&lt;CC&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;B::num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;C::num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;BB::num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, &amp;CC::num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output:</span></span><br><span class="line"><span class="comment">// 0x10f2c5030</span></span><br><span class="line"><span class="comment">// 0x10f2c5030</span></span><br><span class="line"><span class="comment">// 0x10f2c5034</span></span><br><span class="line"><span class="comment">// 0x10f2c5038</span></span><br></pre></td></tr></table></figure><ol start="4"><li>写一个单例对象</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;absl/base/call_once.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeSingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        absl::<span class="built_in">call_once</span>(ThreadSafeSingleton&lt;T&gt;::create_once_, &amp;ThreadSafeSingleton&lt;T&gt;::Create);</span><br><span class="line">        <span class="keyword">return</span> *ThreadSafeSingleton&lt;T&gt;::instance_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">()</span> </span>&#123; instance_ = <span class="keyword">new</span> <span class="built_in">T</span>(); &#125;</span><br><span class="line">    <span class="keyword">static</span> absl::once_flag create_once_;</span><br><span class="line">    <span class="keyword">static</span> T *instance_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">absl::once_flag ThreadSafeSingleton&lt;T&gt;::create_once_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line">T *ThreadSafeSingleton&lt;T&gt;::instance_ = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 11 可以这么写，因为static线程安全</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstSingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T &amp;<span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> T *t = <span class="keyword">new</span> <span class="built_in">T</span>();</span><br><span class="line">        <span class="keyword">return</span> *t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ExampleStruct</span> &#123;</span></span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ExampleStructSingleton = ThreadSafeSingleton&lt;ExampleStruct&gt;;</span><br><span class="line"><span class="keyword">using</span> ExampleStructConstSingleton = ConstSingleton&lt;ExampleStruct&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExampleStructSingleton::<span class="built_in">get</span>().name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;name = &#123;&#125;\n&quot;</span>, ExampleStructSingleton::<span class="built_in">get</span>().name);</span><br><span class="line"></span><br><span class="line">    ExampleStructConstSingleton::<span class="built_in">get</span>().name = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;name = &#123;&#125;\n&quot;</span>, ExampleStructConstSingleton::<span class="built_in">get</span>().name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><ol><li><code>extern C</code> 主要是解决C++ -&gt; C 链接方式不得同，以及C与C++函数互相调用的问题</li><li>其他待补充！</li></ol><h3 id="auto-和-decltype"><a href="#auto-和-decltype" class="headerlink" title="auto 和 decltype"></a>auto 和 decltype</h3><blockquote><p>看这里之前建议先学习模版</p></blockquote><p><code>auto</code> 实际上是大部分高级语言现在都有的一个功能，就是类型推断，c++11引入<code>auto</code> 原因也是因为<code>模版</code>, 其次更加方便！</p><p><code>decltype</code> 本质上也是类型推断，但是它与 auto 是俩场景，解决不同的场景的问题，非常好用，decltype并不会真正的调用函数，只是获取函数的类型，非常好用，尤其是面对复杂模版的时候！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123; <span class="comment">// 返回类型的后置写法!</span></span><br><span class="line">    <span class="keyword">using</span> Sum = <span class="keyword">decltype</span>(t + u);</span><br><span class="line">    Sum s = t + u;</span><br><span class="line">    s = s + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> num = <span class="built_in">add</span>(<span class="built_in"><span class="keyword">float</span></span>(<span class="number">1.1</span>), <span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码，如果没有 <code>decltype</code> 很难去实现，如果仅用模版根本无法推断出到底返回类型是啥，可能是int 也可能是 float ！</p><p>注意:</p><ol><li>decltype 最难的地方还是在于它保留了 左值/右值信息，这个就给编程带来了一定的难度！</li><li>c++14 有更精简的语法，具体可以看c++14语法</li></ol><h3 id="using-和-typedef"><a href="#using-和-typedef" class="headerlink" title="using 和 typedef"></a>using 和 typedef</h3><blockquote><p>看这里之前先学习模版</p></blockquote><p>虽然大部分case两者差距不大，using 这里主要解决了一些case 语法过于复杂的问题！</p><p>例如 typedef 无法解决模版的问题，只能依赖于类模版去实现！</p><p>using 更加方便！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span> =</span> std::allocator&gt;</span><br><span class="line"><span class="keyword">using</span> MyAllocList = std::list&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_list = MyAllocList&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : my_list) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用typedef 我们只能定义一个 类</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">MyAlloc</span> =</span> std::allocator&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyAllocList2</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::list&lt;T, MyAlloc&lt;T&gt;&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> my_list_2 = MyAllocList2&lt;<span class="keyword">int</span>&gt;::type&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="操作符重载-运算符重载"><a href="#操作符重载-运算符重载" class="headerlink" title="操作符重载(运算符重载)"></a>操作符重载(运算符重载)</h2><p>本质上操作符重载就是可以理解为方法的重载，和普通方法没啥差别！但是C++支持将一些 一元/二元/三元的运算符进行重载！</p><p>实际上运算符重载是支持 <strong>类内重载、类外重载</strong>的，两者是等价的！但是有些运算符必须要类内重载，例如 <code>=</code> 、<code>[]</code>、<code>()</code>、<code>-&gt;</code> 等运算符必须类内重载！</p><p>这也就是为啥 ostream 的 <code>&lt;&lt;</code>仅仅重载了部分类型，就可以实现输出任意类型了（只要你实现了重载），有别于一些其他语言的实现了，例如Java依赖于Object#ToString继承，Go依赖于接口实现等！运算符重载的好处在于编译器就可以做到检测！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> re, im;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="keyword">int</span> re, <span class="keyword">int</span> im) : <span class="built_in">re</span>(re), <span class="built_in">im</span>(im) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 语法就是 type operator&lt;operator-symbol&gt;(parameter-list)</span></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; other) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(<span class="keyword">this</span>-&gt;re + other.re, <span class="keyword">this</span>-&gt;im + other.im);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;re: &quot;</span> &lt;&lt; re &lt;&lt; <span class="string">&quot;, im: &quot;</span> &lt;&lt; im &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    Complex a = <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Complex b = <span class="built_in">Complex</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">    Complex c = a + b;</span><br><span class="line">    c.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// re: 3, im: 3</span></span><br></pre></td></tr></table></figure><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p>首先lambda 其实在函数式编程很常见，但实际上我个人还是不理解，如果为了更短的代码，我觉得毫无意义，只不过是一个语法糖罢了，本质上C++的Lambda就是语法糖，编译后会发现实际上是一个匿名的仿函数！</p><p>那么什么才是lambda？我觉得函数式编程，一个很强的概念就是(anywhere define function)任意地方都可以定义函数，例如我现在经常写Go，我定义了一个方法，我需要用到某个方法，但是呢这个作用范围我不想放到外面，因为外面也用不到。因此分为了立即执行函数和变量函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Demo <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	newDemo := <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> *<span class="title">Demo</span></span> &#123; <span class="comment">// newDemo变量 是一个函数类型</span></span><br><span class="line">		<span class="keyword">return</span> &amp;Demo&#123;</span><br><span class="line">			Name: <span class="function"><span class="keyword">func</span><span class="params">(v <span class="keyword">string</span>)</span> *<span class="title">string</span></span> &#123;</span><br><span class="line">				<span class="keyword">if</span> v == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> &amp;v</span><br><span class="line">			&#125;(v), <span class="comment">// 立即执行函数</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	demo1 := newDemo(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	demo2 := newDemo(<span class="string">&quot;&quot;</span>)</span><br><span class="line">	fmt.Println(demo1.Name)</span><br><span class="line">	fmt.Println(demo2.Name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么换做C++，我怎么写呢？ 是的如此强大的C++完全支持， 哈哈哈哈！注意是C++11 ！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Demo</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">    <span class="built_in">Demo</span>(<span class="keyword">const</span> <span class="keyword">char</span>* name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newDemo = [](<span class="keyword">const</span> <span class="keyword">char</span>* name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Demo</span>([&amp;] &#123;</span><br><span class="line">            <span class="keyword">if</span> (*name == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">char</span> * null;</span><br><span class="line">                <span class="keyword">return</span> null;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;;</span><br><span class="line">    Demo* d1 = <span class="built_in">newDemo</span>(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">    Demo* d2 = <span class="built_in">newDemo</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; d1-&gt;name &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; d2-&gt;name &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于上面的例子我们大概知道了如何定义一个 变量的类型是函数 ， 其次如何定义一个立即执行函数！</p><ul><li>函数类型</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[=]：通过值捕捉所有变量</span></span><br><span class="line"><span class="comment">[&amp;]：通过引用捕捉所有变量</span></span><br><span class="line"><span class="comment">[&amp;x]只通过引用捕捉x，不捕捉其他变量。</span></span><br><span class="line"><span class="comment">[x]只通过值捕捉x，不捕捉其他变量。</span></span><br><span class="line"><span class="comment">[=, &amp;x， &amp;y]默认通过值捕捉，变量x和y例外，这两个变量通过引用捕捉。</span></span><br><span class="line"><span class="comment">[&amp;, x]默认通过引用捕捉，变量x例外，这个变量通过引用捕捉。</span></span><br><span class="line"><span class="comment">[&amp;x, &amp;y]非法，因为标志符不允许重复。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lam = [&amp;]() &#123; <span class="comment">// [&amp;] 表示引用传递</span></span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">        y = y + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lam = [=]() &#123; <span class="comment">// [=] 表示值传递，不可以做写操作，类似于const属性</span></span><br><span class="line">        <span class="comment">// x = x+1; // 不可以操作</span></span><br><span class="line">        <span class="comment">// y = y+1; // 不可以操作</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &amp;x表示传递x的引用</span></span><br><span class="line">    <span class="comment">// y 表示函数参数</span></span><br><span class="line">    <span class="comment">// 类型是: std::function&lt;int(int)&gt;</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>)&gt; lam = [&amp;x](<span class="keyword">int</span> y) &#123;</span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lam</span>(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>立即执行函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// lam: 函数类型</span></span><br><span class="line">    std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; lam = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">lam</span>(<span class="number">1</span>, <span class="number">9</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">lam</span>(<span class="number">2</span>, <span class="number">6</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即执行函数</span></span><br><span class="line">    [] &#123; std::cout &lt;&lt; <span class="string">&quot;立即执行函数&quot;</span> &lt;&lt; std::endl; &#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// 10 8</span></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br></pre></td></tr></table></figure><ul><li>函数作为参数传递</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::function&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">print</span><span class="params">(std::string str)</span> <span class="title">throw</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">&quot;str is empty&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [=] &#123; std::cout &lt;&lt; <span class="string">&quot;print: &quot;</span> &lt;&lt; str &lt;&lt; std::endl; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;&quot;</span>)();</span><br><span class="line">    &#125; <span class="built_in"><span class="keyword">catch</span></span> (<span class="keyword">const</span> <span class="keyword">char</span>* v) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;函数执行失败, 异常信息: &quot;</span> &lt;&lt; v &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;abc&quot;</span>)();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出: </span></span><br><span class="line"><span class="comment">// 函数执行失败, 异常信息: str is empty</span></span><br><span class="line"><span class="comment">// print: abc</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>区别于仿函数，仿函数是重载了<code>()</code>运算符，仿函数本质上是类，但是C++11引入了<code>std::function</code> 也就是 lamdba 简化了仿函数，所以C++11 不再推荐仿函数了！</li><li>区别于函数指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumberPrint</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">NumberPrint</span><span class="params">(<span class="keyword">int</span> max)</span> : max(max)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num)</span> <span class="keyword">const</span> </span>&#123; <span class="comment">// 仿函数</span></span><br><span class="line">        <span class="keyword">if</span> (num &lt; max) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> max;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; vector, <span class="keyword">void</span> (*foo)(<span class="keyword">int</span>))</span> </span>&#123; std::for_each(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), foo); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; std::endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printVector</span>(std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, printNum);</span><br><span class="line">    <span class="keyword">auto</span> arr = std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), <span class="built_in">NumberPrint</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>C++的枚举继承了C，也就是支持 enum 和 enum class，两者的区别主要是在于作用范围的不同， 例如下面 <code>Child</code> 和 <code>Student</code> 都定义了 Girl 和 Body，如果不是 enum class 的话则会报错！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许指定类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">char</span> &#123;</span><br><span class="line">    Girl, <span class="comment">// 不指定且位置是第一个就是0</span></span><br><span class="line">    Boy = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">static</span> std::map&lt;Child, std::string&gt; child_map = &#123;&#123;</span><br><span class="line">                                                           Child::Girl,</span><br><span class="line">                                                           <span class="string">&quot;Girl&quot;</span>,</span><br><span class="line">                                                       &#125;,</span><br><span class="line">                                                       &#123;</span><br><span class="line">                                                           Child::Boy,</span><br><span class="line">                                                           <span class="string">&quot;Boy&quot;</span>,</span><br><span class="line">                                                       &#125;&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; out, <span class="keyword">const</span> Child&amp; child) &#123; <span class="comment">// 重载方法 &lt;&lt; 方法</span></span><br><span class="line">    <span class="keyword">auto</span> kv = child_map.<span class="built_in">find</span>(child);</span><br><span class="line">    <span class="keyword">if</span> (kv == child_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        out &lt;&lt; <span class="string">&quot;Unknown[&quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(child) &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    out &lt;&lt; kv-&gt;second;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    Girl,</span><br><span class="line">    Boy</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Child x = Child::Boy;</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in"><span class="keyword">int</span></span>(x) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Child</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h2><p>C++的模版是其语言的灵魂，模版的强大支持包含类型限定、抽象，其灵活性非常之高！</p><ul><li>template: 模版</li><li>template specialization: 模版特化</li><li>学习我只推荐看官方文档: <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/templates">https://en.cppreference.com/w/cpp/language/templates</a></li></ul><ol><li>类模版</li></ol><blockquote><p>参考文章:</p><ul><li><p><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/template_parameters">https://en.cppreference.com/w/cpp/language/template_parameters</a></p></li><li><p><a target="_blank" rel="noopener" href="https://harttle.land/2015/10/03/cpp-template.html">https://harttle.land/2015/10/03/cpp-template.html</a></p></li></ul></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// doc: https://en.cppreference.com/w/cpp/language/template_parameters</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Non-type template parameter</span></span><br><span class="line"><span class="comment">// 这里的Non-type 可以理解为它是一个具体类型，而非 &#x27;typename T&#x27; or &#x27;class T&#x27;</span></span><br><span class="line"><span class="comment">// 其中类型可以是，具体参考上面文章就行了</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> size&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IntArray</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> arr[size];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type template parameter</span></span><br><span class="line"><span class="comment">// 这里可以是 &#x27;typename T&#x27; or &#x27;class T&#x27;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span> &#123;</span></span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版实例化: 偏特化</span></span><br><span class="line"><span class="comment">// 偏特化: 仅特化 type template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span>&lt;</span>K, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    K key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> type_id = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模版实例化: 全特化</span></span><br><span class="line"><span class="comment">// 全特化: 特化全部的 type template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KV</span>&lt;</span><span class="keyword">int</span>, <span class="keyword">int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> type_id = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版，此处打印 type_id</span></span><br><span class="line"><span class="comment">// 注意模版在编译器会检查，如果没有用到就不会检查语法错误</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_type_id</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type_id: &quot;</span> &lt;&lt; T::type_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> S&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TArray</span> &#123;</span></span><br><span class="line">    T array[S];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Template template parameter</span></span><br><span class="line"><span class="comment">// 实际上个人感觉吧比较适合于, 限定 template parameter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">size_t</span> Size = <span class="number">16</span>, <span class="keyword">template</span> &lt;<span class="keyword">typename</span> E, <span class="keyword">size_t</span> S&gt; class ArrayValue = TArray&gt;</span><br><span class="line">struct ArrayKV &#123;</span><br><span class="line">    Key key;</span><br><span class="line">    ArrayValue&lt;Value, Size&gt; value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    KV&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; kv1&#123;&#125;;</span><br><span class="line">    KV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt; kv2&#123;&#125;;</span><br><span class="line">    KV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">const</span> <span class="keyword">char</span> *&gt; kv3&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv1); <span class="comment">// type_id: 2</span></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv2); <span class="comment">// type_id: 1</span></span><br><span class="line">    <span class="built_in">do_print_type_id</span>(kv3); <span class="comment">// error: 编译失败</span></span><br><span class="line"></span><br><span class="line">    ArrayKV&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt; kv4&#123;&#125;;</span><br><span class="line">    kv4.value.array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    kv4.value.array[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数模版</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模版</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func1&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全特化 模版</span></span><br><span class="line"><span class="comment">// 注意函数模版不需要手动申明 &#x27;&lt;模版实参&gt;&#x27; (如果出现推断冲突的情况下也可以申明)</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func2&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载</span></span><br><span class="line"><span class="comment">// 理论上的偏特化, 但是函数支持重载, 因此函数不支持偏特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print</span><span class="params">(K key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;func3&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 如果出现歧义，例如2/3/4代码，其实就是歧义了，可以通过申明模版实参解决</span></span><br><span class="line">    <span class="built_in">do_print</span>(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>);                  <span class="comment">// func1</span></span><br><span class="line">    do_print&lt;<span class="keyword">const</span> <span class="keyword">char</span> *, <span class="keyword">int</span>&gt;(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>); <span class="comment">// func2</span></span><br><span class="line">    do_print&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt;(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);      <span class="comment">// func3</span></span><br><span class="line">    <span class="built_in">do_print</span>(<span class="string">&quot;1&quot;</span>, <span class="number">1</span>);                    <span class="comment">// func3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>注意</li></ol><ul><li>模版由于其特殊性实现部分只能在头文件中定义，主要原因是因为函数模版的实例化过程实际上在编译过程中，我们很多情况下仅依赖头文件和链接(编译后的产物)，所以实现部分必须定义在头文件，我们才可以使用头文件的模版！</li><li>或者通过模版全特化的方案</li><li>其次就是参考 fmt 包的方案</li></ul><ol start="4"><li>class 与 template 区别</li></ol><blockquote><p>有点面试经感觉，说实话我个人觉得只是语法的差异: <a target="_blank" rel="noopener" href="https://liam.page/2018/03/16/keywords-typename-and-class-in-Cxx/">https://liam.page/2018/03/16/keywords-typename-and-class-in-Cxx/</a></p></blockquote><h3 id="高级玩法"><a href="#高级玩法" class="headerlink" title="高级玩法"></a>高级玩法</h3><p>模版的类型推断是非常强大，那么基本上高级玩法都差不多，我们可以看以下几个例子</p><ol><li>移除指针, 头文件 <code>type_traits</code> 的内容</li></ol><p>实现思路很简单，就是模版在匹配的时候，我们把指针引用的类型拿到就行了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer                      &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp*&gt;                &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* const&gt;          &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* volatile&gt;       &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br><span class="line">template &lt;class _Tp&gt; struct _LIBCPP_TEMPLATE_VIS remove_pointer&lt;_Tp* const volatile&gt; &#123;typedef _LIBCPP_NODEBUG_TYPE _Tp type;&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>限定类型，这个用处最多，他是通过参数2来限定参数1的类型，例如下面仅允许指针类型</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPoint</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有指针类型: 才有value字段，且value为true</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IsPoint</span>&lt;</span>T *&gt; &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> Enable, <span class="keyword">typename</span> T = <span class="keyword">void</span>&gt;</span><br><span class="line">struct EnableIf &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅有Enable=true的时候，才会有type申明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EnableIf</span>&lt;</span><span class="literal">true</span>, T&gt; &#123;</span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// std::is_pointer&lt;T&gt;::value 相当于如果你是指针，那么会有一个value=true</span></span><br><span class="line"><span class="comment">// std::enable_if&lt;bool,T=void&gt; 当true的时候会定义一个type类型，且这个type默认是void类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_point</span><span class="params">(T t, <span class="keyword">typename</span> std::enable_if&lt;std::is_pointer&lt;T&gt;::value&gt;::type * = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;&#123;&#125;\n&quot;</span>, *t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x1 = <span class="number">10086</span>;</span><br><span class="line">    <span class="built_in">do_print_point</span>(&amp;x1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">do_print_point</span>(x1); <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>模版实际上并不会检查语法，因此可以限定函数执行，具体编译后函数可以看: <a target="_blank" rel="noopener" href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgp0ZW1wbGF0ZSA8Y2xhc3MgSW5wdXRJdGVyYXRvciwgY2xhc3MgRnVuY3Rpb24+CkZ1bmN0aW9uIEZvckVhY2goSW5wdXRJdGVyYXRvciBfZmlyc3QsIElucHV0SXRlcmF0b3IgX2xhc3QsIEZ1bmN0aW9uIF9mKSB7CiAgICBmb3IgKDsgX2ZpcnN0ICE9IF9sYXN0OyArK19maXJzdCkgeyBfZigqX2ZpcnN0KTsgfQogICAgcmV0dXJuIF9mOwp9CgppbnQgbWFpbigpIHsKICAgIGludCBhcnJbMTBde307CiAgICBGb3JFYWNoKGFyciwgJmFycls5XSwgW10oaW50ICZ4KSB7IHggPSAxMDsgfSk7CiAgICBGb3JFYWNoKGFyciwgJmFycls5XSwgW10oY29uc3QgaW50ICZ4KSB7IHN0ZDo6Y291dCA8PCB4IDw8IHN0ZDo6ZW5kbDsgfSk7Cn0=&insightsOptions=cpp11&std=cpp11&rev=1.0">链接</a></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="keyword">class</span> <span class="title">Function</span>&gt;</span></span><br><span class="line"><span class="function">Function <span class="title">ForEach</span><span class="params">(InputIterator _first, InputIterator _last, Function _f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; _first != _last; ++_first) &#123; _f(*_first); &#125;</span><br><span class="line">    <span class="keyword">return</span> _f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="built_in">ForEach</span>(arr, &amp;arr[<span class="number">9</span>], [](<span class="keyword">int</span> &amp;x) &#123; x = <span class="number">10</span>; &#125;);</span><br><span class="line">    <span class="built_in">ForEach</span>(arr, &amp;arr[<span class="number">9</span>], [](<span class="keyword">const</span> <span class="keyword">int</span> &amp;x) &#123; std::cout &lt;&lt; x &lt;&lt; std::endl; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p>STL：（Standard Template Library）叫做C++标准模版库，其实可以理解为C++最核心的部分，很多人望而却步，其实我感觉还好！</p><p>主要包含：</p><ol><li>容器类模板： 基本的数据结构，数组、队列、栈、map、图 等，如果你学习过很多高级语言，那么对于C++这些容器结构我觉得其实不用太投入，只要熟悉几个API就可以了！</li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/4-4/29a85e81682f4bc9af672afc2f45fa40.png" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li>算法（函数）模板：基本的算法，排序和统计等 ， 其实就是一些工具包</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="3"><li>迭代器类模板：我觉得在Java中很常见，因为你要实现 for each 就需要实现 iterator 接口，其实迭代器类模版也就是这个了！</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li>总结</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span>  <span class="comment">// 算法</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span>  <span class="comment">// 迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span>    <span class="comment">// 容器</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到targetVal位置，并在targetVal前面插入insertVal</span></span><br><span class="line"><span class="comment">// 未找到则在尾部插入</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> V&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container, <span class="keyword">const</span> V&amp; targetVal, <span class="keyword">const</span> V&amp; insertVal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 迭代器</span></span><br><span class="line">    <span class="keyword">using</span> std::begin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">begin</span>(container), <span class="built_in">end</span>(container), targetVal);</span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义容器</span></span><br><span class="line">    <span class="keyword">auto</span> arr = std::vector&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">findAndInsert</span>(arr, <span class="number">4</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 算法</span></span><br><span class="line">    std::for_each(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), [](<span class="keyword">decltype</span>(*arr.<span class="built_in">begin</span>()) elem) &#123; cout &lt;&lt; elem &lt;&lt; endl; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理器-宏"><a href="#预处理器-宏" class="headerlink" title="预处理器 - 宏"></a>预处理器 - 宏</h2><p>宏本质上就是在预处理阶段把宏替换成对应的代码，属于代码模版[ C++/C 思想真的超前 ]，可以省去不少代码工作量，其次就是性能更好，不需要函数调用，直接预处理阶段内联到代码中去了，例如我这里就用了宏 <a target="_blank" rel="noopener" href="https://github.com/Anthony-Dong/protobuf/blob/master/pb_include.h">https://github.com/Anthony-Dong/protobuf/blob/master/pb_include.h</a> ！</p><p>宏的玩法太高级，很多源码满满的宏，不介意新手去深入了解！只要能看懂就行了，简单实用一下也完全可以的哈！</p><h3 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> product(x) x* x</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">product</span>((<span class="number">1</span> + <span class="number">1</span>)) + <span class="number">10</span>; <span class="comment">// 展开后:  (1 + 1)*(1 + 1) + 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y = <span class="built_in">product</span>(<span class="number">1</span> + <span class="number">1</span>) + <span class="number">10</span>; <span class="comment">// 展开后: 1 + 1*1 + 1 + 10</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;y &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;print debug&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line">x: <span class="number">14</span></span><br><span class="line">y: <span class="number">13</span></span><br></pre></td></tr></table></figure><h3 id="class-宏-类名的意义"><a href="#class-宏-类名的意义" class="headerlink" title="class+宏+类名的意义"></a>class+宏+类名的意义</h3><blockquote><p>注意: 这里要是有windows环境的话可以自己体验下！</p></blockquote><p>不清楚大家阅读过c++源码吗，发现开源的代码中基本都有一个 ,那么问题是 <code>PROTOBUF_EXPORT</code> 干啥了？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PROTOBUF_EXPORT</span> <span class="title">CodedInputStream</span> &#123;</span></span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上你自己写代码没啥问题，定不定义这个宏，你要把代码/ddl提供给别人用windows的开发者来说就有问题了，别人引用你的api需要申明一个 <code>__declspec(dllexport)</code> 宏定义，表示导出这个class，具体可以看 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes">https://learn.microsoft.com/en-us/cpp/cpp/using-dllimport-and-dllexport-in-cpp-classes</a> 所以说对于跨端开发来说是非常重要的这点！</p><p>其次这个东西很多时候可以在编译器层面做手脚，表示特殊标识，反正 大概你知道 windows 下需求这个东东就行了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DllExport   __declspec( dllexport )</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DllExport</span> <span class="title">C</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h2><p>待补充！</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>单独补充！</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="new-与-malloc"><a href="#new-与-malloc" class="headerlink" title="new 与 malloc"></a>new 与 malloc</h3><p>我们知道，我们可以再 C语言里使用 <code>malloc</code> 和 <code>frees</code> 初始化内存，但是C++ 里更加推荐使用 new 和 delete ，那么区别在哪里了！</p><p>首先我们知道C++引入了 构造函数 和 析构函数，因此我们用 c系列的api操作，会丢失这些信息，这就是最主要的区别，也是特别需要注意的！</p><p>例子一: 最常见的乱用行为！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Test</span><span class="params">(<span class="keyword">int</span> x_)</span> : x(x_) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">Test</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;release: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test* test = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 错误行为</span></span><br><span class="line"><span class="comment">//    free(test);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正确，会调用析构函数！</span></span><br><span class="line">    <span class="keyword">delete</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子二： 业务中为了做一些事情，例如有些特殊case需要用 void* 指针进行操作（例如导出C），解决内存拷贝的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CClass</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* point;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test* test = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">1</span>);</span><br><span class="line">    CClass c&#123;</span><br><span class="line">        .point = test,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 正确行为，需要强制转换成 Test*；</span></span><br><span class="line">    <span class="built_in"><span class="keyword">delete</span></span> (Test*)c.point;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="new-与-delete"><a href="#new-与-delete" class="headerlink" title="new[] 与 delete[]"></a>new[] 与 delete[]</h3><p>我们可以简单看下面这个例子，就大概明白了，new与delete的区别</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">  	<span class="built_in">Test</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">builtin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> list = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">        list[x] = x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)list - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出不确定</span></span><br><span class="line">    <span class="keyword">delete</span>[] list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">external</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> list = <span class="keyword">new</span> Test[<span class="number">10</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">10</span>; x++) &#123;</span><br><span class="line">        list[x].x = x;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; *((<span class="keyword">unsigned</span> <span class="keyword">long</span>*)list - <span class="number">1</span>) &lt;&lt; endl; <span class="comment">// 输出10</span></span><br><span class="line">    <span class="keyword">delete</span>[] list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>内置类型的话，内存中不会存储长度字段</li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/2a0b8ed1e97440e49abd23990d48cd77.png" alt="image-20230517005229594"></p><ol start="2"><li>其他类型，会在首地址-8 的位置存储长度，也就是64位是8字节</li></ol><p><img src="https://tyut.oss-accelerate.aliyuncs.com/image/2023/5-17/668842e1a693400abc7faf276e4bcc8b.png" alt="image-20230517005016406"></p><ol start="3"><li>所以对于<code>new[]</code> 的指针对象，一定要用<code>delete[]</code> 释放，不然的话你会内存泄漏奥！</li></ol><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a target="_blank" rel="noopener" href="https://godbolt.org/">https://godbolt.org/</a> 一个C++ 转 汇编的工具</li><li><a target="_blank" rel="noopener" href="https://cppinsights.io/">https://cppinsights.io/</a> 可以看到编译器编译后的结果</li><li>C++学习的一些网站资料（直接去Github找）<ul><li><a target="_blank" rel="noopener" href="https://oi-wiki.org/lang/csl/iterator/">https://oi-wiki.org/lang/csl/iterator/</a></li><li><a target="_blank" rel="noopener" href="https://cntransgroup.github.io/EffectiveModernCppChinese/">https://cntransgroup.github.io/EffectiveModernCppChinese/</a></li><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/cpp/cpp/operator-overloading">https://learn.microsoft.com/zh-cn/cpp/cpp/operator-overloading</a></li></ul></li></ul><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul><li>absl: <a target="_blank" rel="noopener" href="https://github.com/abseil/abseil-cpp">https://github.com/abseil/abseil-cpp</a></li><li>protobuf： <a target="_blank" rel="noopener" href="https://github.com/protocolbuffers/protobuf">https://github.com/protocolbuffers/protobuf</a></li><li>fmt: <a target="_blank" rel="noopener" href="https://github.com/fmtlib/fmt">https://github.com/fmtlib/fmt</a></li><li>libevent: <a target="_blank" rel="noopener" href="https://libevent.org/">https://libevent.org/</a></li></ul></div><div class="reward-container"><div>本人坚持原创技术分享，如果你觉得文章对您有用，请随意打赏! 如果有需要咨询的请发送到我的邮箱!</div><button onclick='var qr=document.getElementById("qr");qr.style.display="none"===qr.style.display?"block":"none"'>打赏</button><div id="qr" style="display:none"><div style="display:inline-block"><img src="/images/wechatpay.png" alt="Anthony-Dong 微信支付"><p>微信支付</p></div><div style="display:inline-block"><img src="/images/alipay.png" alt="Anthony-Dong 支付宝"><p>支付宝</p></div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>Anthony-Dong</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/" title="C++ 入门到放弃">https://anthony-dong.github.io/2023/04/06/fd8e40efcdb71f2be44fb720dc582d67/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"># C++</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2023/01/31/5c4904cd995fb585e97a439065161818/" rel="prev" title="Protobuf-SourceCodeInfo 介绍"><i class="fa fa-chevron-left"></i> Protobuf-SourceCodeInfo 介绍</a></div><div class="post-nav-item"><a href="/2023/04/23/291f1489dc6255cedb0b626e74c04f9d/" rel="next" title="Cmake学习">Cmake学习 <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><div class="comments" id="gitalk-container"></div><script>window.addEventListener("tabs:register",()=>{let{activeClass:t}=CONFIG.comments;if(CONFIG.comments.storage&&(t=localStorage.getItem("comments_active")||t),t){let e=document.querySelector(`a[href="#comment-${t}"]`);e&&e.click()}}),CONFIG.comments.storage&&window.addEventListener("tabs:click",t=>{if(!t.target.matches(".tabs-comment .tab-content .tab-pane"))return;let e=t.target.classList[1];localStorage.setItem("comments_active",e)})</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83"><span class="nav-number">1.</span> <span class="nav-text">学习环境</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8Ehello-world-%E5%BC%80%E5%A7%8B"><span class="nav-number">2.</span> <span class="nav-text">从hello world 开始</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">内置类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#char-%E5%92%8C-char-%E5%92%8C-std-string"><span class="nav-number">3.1.</span> <span class="nav-text">char* 和 char[] 和 std::string</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">4.</span> <span class="nav-text">注意点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E-x-%E5%92%8C-x"><span class="nav-number">4.1.</span> <span class="nav-text">关于 x++ 和 ++x</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8-%E5%B7%A6%E5%80%BC-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">4.2.</span> <span class="nav-text">引用 (左值&#x2F;右值引用)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%87%BD%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">类的初始化函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">类的基本的成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%99%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">类的初始化写法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">6.</span> <span class="nav-text">类的多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">6.1.</span> <span class="nav-text">继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#override-%E3%80%81final"><span class="nav-number">6.2.</span> <span class="nav-text">override 、final</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected"><span class="nav-number">6.3.</span> <span class="nav-text">protected</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#friend"><span class="nav-number">6.4.</span> <span class="nav-text">friend</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82"><span class="nav-number">7.</span> <span class="nav-text">指针的一些细节</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%901-%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="nav-number">7.1.</span> <span class="nav-text">例子1: 数组与指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%902-%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6"><span class="nav-number">7.2.</span> <span class="nav-text">例子2: 数组长度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%8B%E5%AD%903-%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88"><span class="nav-number">7.3.</span> <span class="nav-text">例子3: 常量指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A5%E5%85%85%E4%B8%80%E4%BA%9B%E5%B0%8F%E7%82%B9"><span class="nav-number">7.4.</span> <span class="nav-text">补充一些小点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">8.</span> <span class="nav-text">智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#std-unique-ptr"><span class="nav-number">8.1.</span> <span class="nav-text">std::unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-shared-ptr"><span class="nav-number">8.2.</span> <span class="nav-text">std::shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#std-weak-ptr"><span class="nav-number">8.3.</span> <span class="nav-text">std::weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="nav-number">9.</span> <span class="nav-text">关键词</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#const"><span class="nav-number">9.1.</span> <span class="nav-text">const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#static"><span class="nav-number">9.2.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#extern"><span class="nav-number">9.3.</span> <span class="nav-text">extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#auto-%E5%92%8C-decltype"><span class="nav-number">9.4.</span> <span class="nav-text">auto 和 decltype</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#using-%E5%92%8C-typedef"><span class="nav-number">9.5.</span> <span class="nav-text">using 和 typedef</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">10.</span> <span class="nav-text">操作符重载(运算符重载)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lambda"><span class="nav-number">11.</span> <span class="nav-text">lambda</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%9A%E4%B8%BE"><span class="nav-number">12.</span> <span class="nav-text">枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E7%89%88"><span class="nav-number">13.</span> <span class="nav-text">模版</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%8E%A9%E6%B3%95"><span class="nav-number">13.1.</span> <span class="nav-text">高级玩法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">14.</span> <span class="nav-text">STL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-%E5%AE%8F"><span class="nav-number">15.</span> <span class="nav-text">预处理器 - 宏</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number">15.1.</span> <span class="nav-text">简单的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#class-%E5%AE%8F-%E7%B1%BB%E5%90%8D%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">15.2.</span> <span class="nav-text">class+宏+类名的意义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RTTI"><span class="nav-number">16.</span> <span class="nav-text">RTTI</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">17.</span> <span class="nav-text">多线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">18.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E4%B8%8E-malloc"><span class="nav-number">18.1.</span> <span class="nav-text">new 与 malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#new-%E4%B8%8E-delete"><span class="nav-number">18.2.</span> <span class="nav-text">new[] 与 delete[]</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%84%E6%96%99"><span class="nav-number">19.</span> <span class="nav-text">资料</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%93"><span class="nav-number">20.</span> <span class="nav-text">库</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Anthony-Dong" src="/images/avatar.png"><p class="site-author-name" itemprop="name">Anthony-Dong</p><div class="site-description" itemprop="description">追寻技术的本质！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">12</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">42</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/anthony-dong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;anthony-dong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@gmail.com" title="E-Mail → mailto:fanhaodong516@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a> </span><span class="links-of-author-item"><a href="https://juejin.cn/user/4248168663101320" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4248168663101320" rel="noopener" target="_blank"><i class="fas fa-book fa-fw"></i>掘金</a> </span><span class="links-of-author-item"><a href="mailto:fanhaodong516@163.com" title="国内邮箱 → mailto:fanhaodong516@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>国内邮箱</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2023</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Anthony-Dong</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">395k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">6:01</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动</div></div></footer></div><script src="/lib/anime.min.js"></script><script src="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/medium-zoom.min.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll("pre.mermaid").length&&NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/mermaid.min.js",()=>{mermaid.initialize({theme:"forest",logLevel:3,flowchart:{curve:"linear"},gantt:{axisFormat:"%m/%d/%Y"},sequence:{actorMargin:50}})},window.mermaid)</script><link rel="stylesheet" href="//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.css"><script>NexT.utils.loadComments(document.querySelector("#gitalk-container"),()=>{NexT.utils.getScript("//tyut.oss-accelerate.aliyuncs.com/image/2022/4-3/gitalk.min.js",()=>{new Gitalk({clientID:"b1c466a9c5677a8d374a",clientSecret:"7cf9512c7e4b46b574e901b18983be7ae5b47d74",repo:"anthony-dong.github.io",owner:"Anthony-Dong",admin:["Anthony-Dong"],id:"bae479e8e605922d7c6fd0b73d991a32",language:"",distractionFreeMode:!0}).render("gitalk-container")},window.Gitalk)})</script></body></html>